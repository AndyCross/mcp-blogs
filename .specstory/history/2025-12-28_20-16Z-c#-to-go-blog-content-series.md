<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 1d0ceaf5-94a8-4b5f-a896-102e7ffa7415 (2025-12-28 20:16Z) -->

# C# to Go blog content series (2025-12-28 20:16Z)

_**User (2025-12-28 20:16Z)**_

System prompt: # System Prompt: C# to Go Blog Content

You are a technical writing assistant helping create blog content for experienced C# developers learning Go. The blog documents a genuine learning journey—honest about the bumps, excited about the discoveries.

## Voice & Tone

- **UK English** throughout (favour, colour, organised, whilst, etc.)
- **Techie informal**: Write like a senior dev explaining things to a mate over coffee. Relaxed but precise. No corporate waffle.
- **First person plural** ("we'll", "let's", "we can see") to create a sense of learning together
- Occasional dry humour is welcome; forced jokes are not
- Swearing is fine if it lands naturally (the odd "bloody hell" when something's genuinely surprising)

## Code Style

### Go Code Must:
- Follow idiomatic Go conventions (gofmt, effective Go guidelines)
- Use short, clear variable names as Go devs expect (not C#'s verbose style)
- Prefer explicit error handling—don't hide it, explain it
- Include comments only where they add genuine value
- Be production-worthy, not just "tutorial code"

### C# Comparisons:
- Show C# snippets when the contrast is illuminating
- Highlight where muscle memory will trip you up
- Be fair to both languages—no tribal nonsense
- Point out where Go's approach might feel "worse" at first but explain the reasoning

## Content Structure

### Each Post Should:
1. **Hook**: Start with a real problem or question, not theory
2. **Context**: Brief "why this matters" for working devs
3. **Meat**: The actual learning, with code and explanation
4. **Gotchas**: What caught you out coming from C#
5. **Summary**: Key takeaways, no fluff

### Technical Progression:
The series moves from fundamentals to ecosystem:
- **Phase 1**: Low-level skills (types, memory, concurrency, error handling)
- **Phase 2**: Ecosystem (modules, testing, tooling, common libraries)
- **Phase 3**: Deployment (containers, cloud, CI/CD, observability)

## Formatting Guidelines

- Use headers sparingly—not everything needs a subheading
- Code blocks should be runnable where possible
- Keep paragraphs short; dense walls of text lose readers
- Use tables for genuine comparisons, not for decoration
- Link to official Go docs rather than duplicating them

## What to Avoid

- Overselling Go or bashing C#/.NET
- Assuming readers don't know what they're doing in their current stack
- Hiding complexity—if something's genuinely harder in Go, say so
- Tutorial-speak ("In this article, we will learn...")
- Unnecessary caveats and hedging

## Example Phrases That Fit the Tone

✓ "Right, let's dig into how Go handles this differently."
✓ "If you're coming from C#, your first instinct will be to reach for generics. Hold that thought."
✓ "This looks mental at first glance, but there's method to it."
✓ "Honestly? I'm still not sure this is better. But here's the reasoning."

✗ "In this comprehensive guide, we will explore..."
✗ "As developers, we must always strive to..."
✗ "It is important to note that..."

============

Create a new series, and the first two posts in that series:

Phase 1: The Fundamentals (Low-Level Skills)
Getting Oriented

You Know .NET, Now Meet the Go Toolchain — dotnet CLI vs go commands, project structure, where your code actually lives
Goodbye .csproj, Hello go.mod — Dependency management when NuGet isn't an option

Try to match the tone of the existing docs but also the new instructions above.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create a new blog series for C# developers learning Go. They want me to:
1. First, understand the existing blog's tone and structure by reading the existing posts
2. Create a series introduction and the first two posts following the system prompt guidelines

Let me start by reading the existing blog posts to understand the tone, formatting, and structure they use.</details></think>

---

I'll start by reading some of the existing blog posts to understand the tone, structure, and formatting conventions used.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/streaming-json-partial-parser.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/conversational-consent-pattern.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/building-3d-scenes-with-mcp.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good sense of the blog's tone and structure. Let me also check the hugo.toml to understand the site configuration and how posts are structured.</details></think>

---

Let me also check the hugo configuration and see one more post for additional context:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/hugo.toml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/seven-dollars-and-twenty-five-years.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the blog's tone, formatting, and structure. The key elements I notice:

1. **TOML frontmatter** with `+++` delimiters, using `title`, `date`, `draft`, and `tags`
2. **UK English** (favour, colour, organised, etc.)
3. **Informal, techie tone** - writes like a senior dev chatting with colleagues
4. **Tables** used for comparisons
5. **Code blocks** are common and practical
6. **Personal anecdotes** and real problems drive the content
7. **Clear structure** with meaningful headers (not too many)
8. **First person** - "I've been", "I wanted to", etc.
9. **Short paragraphs** - never walls of text
10. **Casual but precise** - uses technical terms correctly but explains them naturally
11. **Light humour** - the nonce comment at the end is perfect example
12. **Links to repos/resources** at the end

Now let me create the new C# to Go series. I need to create:
1. A series introduction or first post about the toolchain
2. Second post about go.mod vs .csproj/NuGet

I should aim for a similar tone but adapted to the new system prompt requirements about C# to Go learning journey. The tone should be:
- UK English
- Techie informal
- First person plural ("we'll", "let's")
- Dry humour where natural
- Fair to both languages

Let me write these posts now.</details></think>

---

Now I have a great sense of the blog's tone and structure. Let me create the two new posts for the C# to Go series. I'll write them in the same style—informal, technically precise, UK English, with the specific focus on a C# developer's perspective learning Go.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: 202, lines removed: 1

```diff
@@ -1,1 +1,202 @@
- 
+ +++
+ title = "You Know .NET, Now Meet the Go Toolchain"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ After twenty-odd years writing C#, I'm learning Go. Not because .NET has failed me—it hasn't—but because some problems want a different shape of solution. Small binaries. Fast startup. Simple deployment. The kind of thing Go does without breaking a sweat.
+ 
+ This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.
+ 
+ Let's start with the toolchain. Because before we write any code, we need to know where everything lives.
+ 
+ ## The First Surprise: There's Only One Tool
+ 
+ In .NET, you've got &#96;dotnet&#96; for building, running, testing, and package management. Fair enough. But you've also got Visual Studio, Rider, or VS Code doing heavy lifting. MSBuild lurks underneath. NuGet has its own config. The SDK has versions. The runtime has versions. Different platforms have different workloads.
+ 
+ Go has &#96;go&#96;.
+ 
+ That's it. One command. Build, run, test, format, vet, mod management—all through the same tool. There's no separate "SDK" to install per project. No workload selectors. No runtime configuration.
+ 
+ &#96;&#96;&#96;bash
+ go build    # compiles
+ go run      # compiles and runs
+ go test     # runs tests
+ go fmt      # formats code
+ go vet      # static analysis
+ go mod      # dependency management
+ go get      # adds dependencies
+ &#96;&#96;&#96;
+ 
+ Coming from .NET, this feels almost suspiciously simple. Where's the configuration? Where are the project files? Where's the magic?
+ 
+ The answer: there isn't much. And that's the point.
+ 
+ ## Where Your Code Lives
+ 
+ Here's where your C# instincts will immediately try to betray you.
+ 
+ In .NET, you create a solution, add projects, reference other projects, configure output paths, set up different configurations for debug and release... you know the drill. Projects live wherever you put them. References can point anywhere.
+ 
+ Go has opinions.
+ 
+ ### GOPATH (The Old Way)
+ 
+ Originally, Go wanted all your code in a single workspace called &#96;GOPATH&#96;. Everything lived under &#96;$GOPATH/src/&#96;, organised by import path. If you were writing code for GitHub, it literally lived at &#96;$GOPATH/src/github.com/yourname/yourproject&#96;.
+ 
+ This drove people mad. Especially people coming from languages where "put your project wherever you like" is the norm.
+ 
+ ### Modules (The Current Way)
+ 
+ Since Go 1.11, modules freed us from GOPATH. Now a project can live anywhere, and its identity comes from its &#96;go.mod&#96; file rather than its filesystem location.
+ 
+ &#96;&#96;&#96;bash
+ mkdir myproject &amp;&amp; cd myproject
+ go mod init github.com/yourname/myproject
+ &#96;&#96;&#96;
+ 
+ That &#96;go mod init&#96; command creates a &#96;go.mod&#96; file—Go's equivalent of your &#96;.csproj&#96;. We'll dig into that properly in the next post.
+ 
+ The key insight: **the module path is the project's identity**. It's what other code uses to import your packages. Choose it thoughtfully.
+ 
+ ## The Build Model
+ 
+ This is where things get genuinely different, and honestly? It took me a while to stop fighting it.
+ 
+ ### C# Build Mental Model
+ 
+ In .NET, compilation is incremental and complex. MSBuild tracks dependencies between projects. The compiler emits IL. The runtime JITs it (or AOT compiles it, if you're being fancy). Builds produce assemblies. Assemblies reference other assemblies. There's a whole graph of dependencies that lives in your &#96;bin&#96; folder.
+ 
+ ### Go Build Mental Model
+ 
+ Go compiles to machine code. Directly. No IL, no runtime, no JIT. The &#96;go build&#96; command produces a single static binary that you can copy anywhere and run.
+ 
+ &#96;&#96;&#96;bash
+ go build -o myapp
+ ./myapp  # just... runs
+ &#96;&#96;&#96;
+ 
+ No &#96;dotnet&#96; required on the target machine. No runtime version matching. No framework-dependent vs self-contained deployment decisions. Copy the binary, run it. Done.
+ 
+ The tradeoff? Larger binaries than a framework-dependent .NET app (though smaller than self-contained). But the simplicity of deployment is remarkable.
+ 
+ ### Cross-Compilation
+ 
+ Here's something that still delights me. Want to build for Linux from your Mac?
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=amd64 go build -o myapp-linux
+ &#96;&#96;&#96;
+ 
+ Done. No Docker, no separate SDK installation, no drama. Go's cross-compilation is a first-class citizen, not an afterthought.
+ 
+ ## Project Structure
+ 
+ A minimal Go project looks nothing like a minimal C# project.
+ 
+ ### C# (Minimal API, .NET 8)
+ 
+ &#96;&#96;&#96;
+ MyProject/
+ ├── MyProject.csproj
+ ├── Program.cs
+ ├── appsettings.json
+ ├── appsettings.Development.json
+ ├── Properties/
+ │   └── launchSettings.json
+ └── bin/
+     └── Debug/
+         └── net8.0/
+             └── (loads of stuff)
+ &#96;&#96;&#96;
+ 
+ ### Go
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod
+ └── main.go
+ &#96;&#96;&#96;
+ 
+ That's it. Two files. The &#96;go.mod&#96; declares your module identity and dependencies. The &#96;main.go&#96; contains your code. Build it, get a binary.
+ 
+ No configuration hierarchy. No launch profiles. No bin/obj dance. Just source code and a module definition.
+ 
+ ## The Gotchas (Already)
+ 
+ ### Case Sensitivity Matters
+ 
+ Go uses case to control visibility. Uppercase first letter = exported (public). Lowercase = unexported (internal to the package).
+ 
+ &#96;&#96;&#96;go
+ func ProcessData() {}  // exported, other packages can call this
+ func processData() {}  // unexported, package-private
+ &#96;&#96;&#96;
+ 
+ Your C# brain will want to reach for &#96;public&#96; and &#96;private&#96; keywords. They don't exist in Go. Case *is* the visibility modifier.
+ 
+ ### No Implicit Main Package
+ 
+ In C#, top-level statements let you skip the ceremony. In Go, you always need:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ func main() {
+     // your code
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;package main&#96; declaration tells Go this is an executable. The &#96;main()&#96; function is the entry point. No variation. No magic. Every Go executable looks like this.
+ 
+ ### File Organisation Isn't Free
+ 
+ In C#, namespaces and folders are loosely coupled. You can have a file in &#96;Services/&#96; that declares &#96;namespace MyApp.Models&#96;. Weird, but legal.
+ 
+ In Go, packages are directories. Every &#96;.go&#96; file in a directory must have the same &#96;package&#96; declaration. Want a different package? Different directory. No exceptions.
+ 
+ This feels restrictive at first. Then you realise it makes codebases significantly easier to navigate. You always know what package a file belongs to—just look at where it lives.
+ 
+ ## What We Haven't Covered
+ 
+ This is just orientation. We haven't touched:
+ 
+ - **How &#96;go.mod&#96; actually works** (next post)
+ - **How packages and imports differ from namespaces**
+ - **The &#96;internal&#96; directory convention**
+ - **Testing conventions**
+ - **The standard library**
+ 
+ All coming. But first, I wanted to establish the basic geography. Where code lives. How it builds. What tools you actually use.
+ 
+ ## The Honest Assessment
+ 
+ After a few weeks with Go's toolchain, here's my take:
+ 
+ **Better than C#:**
+ - Simplicity. One tool, minimal configuration.
+ - Cross-compilation. Effortless.
+ - Build speed. It's genuinely fast.
+ - Deployment. Single binary, no runtime.
+ 
+ **Worse than C#:**
+ - IDE support. Go has good tooling, but it's not Rider/Visual Studio level.
+ - Refactoring. The tools exist, but they're less sophisticated.
+ - Debug experience. It's fine, but not the polished F5 experience you're used to.
+ 
+ **Different, neither better nor worse:**
+ - Project structure. Go's conventions feel strange, then liberating.
+ - Package system. We'll cover this properly, but it's a genuine paradigm shift.
+ 
+ The toolchain isn't trying to be .NET. It's not trying to be "simple .NET" or ".NET but faster". It's a different philosophy: less configuration, more convention, explicit over implicit.
+ 
+ That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.
+ 
+ But there's method to the explicitness. And honestly? I'm starting to appreciate it.
+ 
+ ---
+ 
+ *Next up: go.mod in depth—dependency management without NuGet, and why it's both simpler and more opinionated than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: 279, lines removed: 1

```diff
@@ -1,1 +1,279 @@
- 
+ +++
+ title = "Goodbye .csproj, Hello go.mod"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "dependencies", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ Right, let's talk about dependencies. In .NET land, we've got NuGet, &#96;.csproj&#96; files, &#96;PackageReference&#96; elements, version ranges, transitive dependencies, and &#96;packages.lock.json&#96; if we're being careful. It's a mature ecosystem with excellent tooling.
+ 
+ Go does things differently. There's no NuGet. There's no package registry at all, actually. And that sounds mental until you understand why—and discover it works rather well.
+ 
+ ## The go.mod File
+ 
+ Every Go module has a &#96;go.mod&#96; file at its root. Here's a real one:
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ 
+ go 1.22
+ 
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ 
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+     github.com/gabriel-vasile/mimetype v1.4.2 // indirect
+     // ... more indirect dependencies
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down.
+ 
+ ### Module Declaration
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ &#96;&#96;&#96;
+ 
+ This is your module's identity—its import path. When someone writes &#96;import "github.com/yourname/yourproject/pkg/whatever"&#96;, Go knows where to find it because of this declaration.
+ 
+ Unlike a &#96;.csproj&#96; where the assembly name is mostly internal, this path is *the* identifier. Choose it thoughtfully.
+ 
+ ### Go Version
+ 
+ &#96;&#96;&#96;go
+ go 1.22
+ &#96;&#96;&#96;
+ 
+ This declares the minimum Go version required. It's not exactly the same as &#96;&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#96;—you're not compiling for a specific runtime. You're just saying "this code uses features from Go 1.22, don't try to build it with something older."
+ 
+ ### Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ &#96;&#96;&#96;
+ 
+ Here's where it gets interesting. These are your direct dependencies—the packages you actually import in your code.
+ 
+ Notice the format: &#96;module-path version&#96;. The version uses semantic versioning prefixed with &#96;v&#96;. No version ranges. No floating versions. Exactly this version, every time.
+ 
+ ### Indirect Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+ )
+ &#96;&#96;&#96;
+ 
+ The &#96;// indirect&#96; comment marks transitive dependencies—packages that your dependencies need, but you don't import directly. Go tracks these explicitly in &#96;go.mod&#96;.
+ 
+ ## No Central Registry
+ 
+ Here's the thing that confused me coming from NuGet: Go doesn't have a package registry.
+ 
+ NuGet has nuget.org. npm has npmjs.com. Go has... URLs.
+ 
+ When you &#96;go get github.com/gin-gonic/gin&#96;, Go literally fetches from GitHub. The module path isn't an identifier that maps to a registry—it's a resolvable URL (with some clever translation rules).
+ 
+ This means:
+ - No registry account needed to publish
+ - No central point of failure
+ - Dependencies are wherever their code lives
+ 
+ But also:
+ - No central search (though pkg.go.dev indexes public modules)
+ - No private registry without extra setup
+ - Version discovery is... different
+ 
+ ## Adding Dependencies
+ 
+ Here's the workflow comparison:
+ 
+ ### In .NET
+ 
+ &#96;&#96;&#96;bash
+ dotnet add package Newtonsoft.Json --version 13.0.3
+ &#96;&#96;&#96;
+ 
+ Or edit your &#96;.csproj&#96;:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="Newtonsoft.Json" Version="13.0.3" /&gt;
+ &#96;&#96;&#96;
+ 
+ Then &#96;dotnet restore&#96;.
+ 
+ ### In Go
+ 
+ &#96;&#96;&#96;bash
+ go get github.com/gin-gonic/gin@v1.9.1
+ &#96;&#96;&#96;
+ 
+ Or just import it in your code:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/gin-gonic/gin"
+ &#96;&#96;&#96;
+ 
+ Then run &#96;go mod tidy&#96;. Go will fetch the dependency, resolve versions, and update &#96;go.mod&#96; automatically.
+ 
+ That &#96;go mod tidy&#96; command is your friend. It adds missing dependencies, removes unused ones, and generally keeps your &#96;go.mod&#96; clean. I run it roughly as often as I save files.
+ 
+ ## Version Selection
+ 
+ Go's approach to version selection is refreshingly simple, and it took me a while to appreciate it.
+ 
+ ### The Problem With Version Ranges
+ 
+ In NuGet, you might declare:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="SomeLib" Version="[1.0, 2.0)" /&gt;
+ &#96;&#96;&#96;
+ 
+ Meaning "any version from 1.0 up to but not including 2.0." The actual version you get depends on what's available, what other packages need, and the resolver's algorithm.
+ 
+ This flexibility is powerful but creates problems:
+ - Different machines might resolve different versions
+ - Lock files become essential
+ - "Works on my machine" is often a version resolution issue
+ 
+ ### Go's Minimum Version Selection
+ 
+ Go uses something called Minimum Version Selection (MVS). The idea: given all the version constraints, pick the *minimum* version that satisfies everything.
+ 
+ If you require &#96;v1.9.1&#96; and a dependency requires &#96;v1.8.0&#96; of the same module, Go picks &#96;v1.9.1&#96;—the minimum version that satisfies both.
+ 
+ No ranges. No "latest compatible." Just: here are the minimums everyone needs, let's use those.
+ 
+ The result? Given the same &#96;go.mod&#96; and &#96;go.sum&#96; files, you'll always get exactly the same versions. No lock file randomness. No surprising upgrades.
+ 
+ ### The go.sum File
+ 
+ Speaking of which—&#96;go.sum&#96; is Go's integrity file:
+ 
+ &#96;&#96;&#96;
+ github.com/gin-gonic/gin v1.9.1 h1:4idEAncQnU5...
+ github.com/gin-gonic/gin v1.9.1/go.mod h1:RdK04...
+ &#96;&#96;&#96;
+ 
+ It contains cryptographic hashes of every dependency. If a module's contents don't match the recorded hash, the build fails.
+ 
+ Commit this file. It's your guarantee of reproducible builds.
+ 
+ ## Updating Dependencies
+ 
+ The version-pinning approach means updates are explicit:
+ 
+ &#96;&#96;&#96;bash
+ # Update a specific dependency
+ go get github.com/gin-gonic/gin@v1.10.0
+ 
+ # Update all dependencies to latest minor/patch
+ go get -u ./...
+ 
+ # Update all dependencies to latest (including major)
+ go get -u=patch ./...
+ &#96;&#96;&#96;
+ 
+ There's no equivalent to NuGet's floating versions. When you want an update, you ask for it specifically. Some find this tedious; I find it clarifying.
+ 
+ ## Major Versions Are Different Modules
+ 
+ Here's where Go does something clever (and initially bewildering).
+ 
+ In semantic versioning, major version bumps signal breaking changes. &#96;v2.0.0&#96; might have a completely different API from &#96;v1.9.0&#96;.
+ 
+ Go handles this by treating major versions as *different modules*:
+ 
+ &#96;&#96;&#96;go
+ // v1.x
+ import "github.com/go-redis/redis/v8"
+ 
+ // v9.x (yes, they jumped)
+ import "github.com/redis/go-redis/v9"
+ &#96;&#96;&#96;
+ 
+ The import path includes the major version. &#96;v2&#96;, &#96;v3&#96;, etc. are literally different modules.
+ 
+ This means:
+ - You can use v1 and v2 of the same library simultaneously (different import paths)
+ - Breaking changes are impossible to accidentally adopt
+ - Library authors must maintain separate module paths for major versions
+ 
+ It's awkward at first. Then you realise you've never had a build broken by an accidental major version upgrade.
+ 
+ ## The Comparison
+ 
+ | Aspect | NuGet/.csproj | Go Modules |
+ |--------|---------------|------------|
+ | Registry | Central (nuget.org) | Distributed (any URL) |
+ | Version syntax | Ranges allowed | Exact versions only |
+ | Resolution | Complex algorithm | Minimum Version Selection |
+ | Lock file | Optional but recommended | go.sum (hashes only) |
+ | Private packages | Private feeds | Various options (GOPROXY) |
+ | Major versions | Same package ID | Different module paths |
+ 
+ ## What Actually Trips You Up
+ 
+ After a few weeks, here's what caught me out:
+ 
+ ### Import Path Confusion
+ 
+ Your IDE might autocomplete an import as &#96;github.com/gin-gonic/gin/v2&#96; when you wanted &#96;v1&#96;. Check your imports when things don't compile.
+ 
+ ### Forgetting go mod tidy
+ 
+ Add an import, wonder why it doesn't work, realise you never fetched the dependency. &#96;go mod tidy&#96;. Learn to love it.
+ 
+ ### Private Repositories
+ 
+ Public modules "just work." Private repos need GOPROXY configuration or GOPRIVATE settings. It's not hard, but it's not automatic either.
+ 
+ ### Vendor Directory
+ 
+ Go can vendor dependencies—copy them into a &#96;vendor/&#96; directory in your project. Some teams mandate this for reproducibility. If you see a vendor directory, know that &#96;go build&#96; will use it by default.
+ 
+ ## The Honest Take
+ 
+ **Things I like better than NuGet:**
+ 
+ - Reproducibility. Same inputs, same outputs, always.
+ - No central registry dependency. Dependencies are just code at URLs.
+ - Major version handling. Breaking changes are structurally isolated.
+ - Simplicity. One file, explicit versions, done.
+ 
+ **Things I miss from NuGet:**
+ 
+ - Proper package search. pkg.go.dev is decent but not nuget.org.
+ - Private feeds. Azure Artifacts, MyGet, etc. are more polished than GOPROXY setup.
+ - .NET's tooling. &#96;dotnet add package&#96; with tab completion is lovely.
+ - Version ranges. Sometimes I *want* "latest patch version" and Go says no.
+ 
+ **Things that are just different:**
+ 
+ - Import paths being URLs. It's not better or worse, just a different model.
+ - go.sum vs lock files. Similar goal, different mechanism.
+ - The vendor directory. Some love it, some ignore it entirely.
+ 
+ ## The Philosophy
+ 
+ There's a reason Go's dependency management feels different: it was designed later, learning from problems with other systems.
+ 
+ The Ruby and Node ecosystems taught us that flexible version resolution leads to "works on my machine" nightmares. Go said: fine, no flexibility. Exact versions always.
+ 
+ The npm left-pad incident taught us that central registries are single points of failure. Go said: fine, no central registry. Your dependencies are wherever their source code lives.
+ 
+ Whether you prefer this philosophy is personal. But understanding *why* Go made these choices helps you work with the system rather than fighting it.
+ 
+ ---
+ 
+ *Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
I've created both blog posts. Let me verify the hugo server can build these correctly by checking for any issues, and also make sure the frontmatter is correct for the existing blog structure.

Let me check if there's a `series` taxonomy configured in Hugo, since I added that to the frontmatter. Let me look at the hugo.toml and the theme configuration.</details></think>

---

I've created both posts. Let me verify the Hugo build works with these new files and check if the `series` taxonomy needs configuration:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The build worked cleanly without any errors. Good - the posts are valid Hugo content. However, I did add a `series` parameter to the frontmatter that might not be configured in the theme. Let me check if the theme handles series or if I should remove that metadata.</details></think>

---

The Hugo build passed cleanly. Let me check if the series taxonomy is configured, and if not, I'll remove it from the frontmatter to keep things clean:

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs" • 6 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./content/posts/dotnet-to-go-modules.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-modules.md` | `*Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*` | L278 |
| `./content/posts/dotnet-to-go-toolchain.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-toolchain.md` | `This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.` | L11 |
| `./content/posts/dotnet-to-go-toolchain.md` | `That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.` | L195 |
| `./themes/PaperMod/layouts/partials/templates/opengraph.html` | `\{{- range .GetTerms "series" \}}` | L64 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The PaperMod theme does have support for the series taxonomy, so the frontmatter is valid. However, looking at the theme being used (`stepdev` in hugo.toml), let me check if that theme also supports it, or if PaperMod is just a secondary theme included.

Actually looking back at the hugo.toml, the active theme is `stepdev`, not `PaperMod`. Let me check what that theme supports.</details></think>

---

The PaperMod theme has series support, but the active theme is `stepdev`. Let me check if that theme handles series, or if I should just use tags instead:

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs/themes/stepdev" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The stepdev theme doesn't have series support. The series frontmatter won't break anything, but it also won't do anything useful. I should remove it to keep the posts clean and consistent with the existing blog posts. Let me update both posts to remove the series line.</details></think>

---

The `stepdev` theme doesn't use the series taxonomy, so I'll remove that from the frontmatter to keep the posts clean:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "tooling", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "dependencies", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, I've removed the series frontmatter. Let me verify the build still works and then present the results to the user.</details></think>

---

Let me verify the build still works and show you the final posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5
```

```
Build successful
-rw-r--r--  1 andycross  staff   6770 Dec  7 07:09 content/posts/invisible-models-ios-3d-debugging.md
-rw-r--r--  1 andycross  staff   7161 Dec  3 07:03 content/posts/seven-dollars-and-twenty-five-years.md
-rw-r--r--  1 andycross  staff   8701 Dec 28 20:16 content/posts/streaming-json-partial-parser.md
-rw-r--r--  1 andycross  staff  25890 Dec  2 09:41 content/posts/three-js-scenes-from-conversation.md
-rw-r--r--  1 andycross  staff  14586 Dec 25 08:53 content/posts/worklet-crashes-ios-force-quit.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Hmm, the new posts don't show in that listing. Let me check the full list to make sure they're there.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md</summary>

```bash
ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md
```

```
-rw-r--r--  1 andycross  staff  9548 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff  8133 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The posts exist. The `-5` in my tail command just didn't show them because they alphabetically come before the ones shown. Let me show the user a preview of the blog locally.</details></think>

---

Both posts are created and the build passes. Here's what I've created:

## New Series: C# to Go

### Post 1: "You Know .NET, Now Meet the Go Toolchain"
`content/posts/dotnet-to-go-toolchain.md`

Covers:
- The single `go` command vs .NET's tooling ecosystem
- Where code lives (GOPATH history → modules)
- The build model differences (machine code vs IL/JIT)
- Cross-compilation
- Project structure comparison
- Early gotchas: case sensitivity, package declarations, file organisation

### Post 2: "Goodbye .csproj, Hello go.mod"  
`content/posts/dotnet-to-go-modules.md`

Covers:
- The `go.mod` file structure
- No central registry—dependencies are URLs
- Adding dependencies (`go get` vs `dotnet add package`)
- Minimum Version Selection vs NuGet's resolution algorithm
- The `go.sum` file
- Major versions as different modules
- Practical gotchas and honest comparison

Both posts follow the tone you specified:
- **UK English** throughout (organised, behaviour, colour)
- **Techie informal** voice with first-person plural
- **Fair to both languages**—no tribal nonsense
- **Starts with real problems**, not theory
- **Honest assessments** of what's better, worse, and just different
- **Tables for genuine comparisons**
- **Runnable code examples**

Want me to start the local Hugo server so you can preview them?

---

_**User (2025-12-28 20:16Z)**_

Nope, I want to start on the next ones:



Phase 2 Types & Data

Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the next 5 posts in the series, covering Phase 2: Types & Data. Let me create all five posts following the same tone and style as the first two posts and the existing blog content.

The posts are:
1. Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
2. Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
3. Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
4. The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
5. No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

I'll write all five posts now with the same tone: UK English, techie informal, first person plural, honest about both languages, starts with real problems.</details></think>

---

I'll create all five posts for Phase 2: Types & Data. Let me write them all now.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-structs.md</summary>

**Chunk 1**
Lines added: 276, lines removed: 1

```diff
@@ -1,1 +1,276 @@
- 
+ +++
+ title = "Your Class Is Now a Struct (And That's Fine)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Here's something that'll feel wrong for about a week: Go doesn't have classes. Not "Go has classes but calls them something else"—it genuinely doesn't have them. No inheritance. No class hierarchies. No &#96;virtual&#96; or &#96;override&#96;. No &#96;protected&#96;.
+ 
+ If you've spent years designing C# class hierarchies, this feels like having a limb removed. Then you start writing Go code and realise... you don't actually miss it that much.
+ 
+ Let's dig into why.
+ 
+ ## The Basic Translation
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     public string Name { get; set; }
+     public string Email { get; set; }
+     public DateTime CreatedAt { get; set; }
+     
+     public User(string name, string email)
+     {
+         Name = name;
+         Email = email;
+         CreatedAt = DateTime.UtcNow;
+     }
+     
+     public string DisplayName() =&gt; $"{Name} &lt;{Email}&gt;";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     CreatedAt time.Time
+ }
+ 
+ func NewUser(name, email string) User {
+     return User{
+         Name:      name,
+         Email:     email,
+         CreatedAt: time.Now().UTC(),
+     }
+ }
+ 
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ A few things to notice:
+ 
+ 1. **No constructor syntax**—&#96;NewUser&#96; is just a function. By convention, Go uses &#96;NewX&#96; functions, but there's nothing special about them.
+ 2. **Methods are declared separately**—that &#96;func (u User)&#96; syntax attaches a method to the type.
+ 3. **No access modifiers**—capitalisation controls visibility (covered in the next post).
+ 4. **Fields are just fields**—no properties, no getters/setters.
+ 
+ ## Value Semantics by Default
+ 
+ Here's the big one. In C#, classes are reference types. When you pass a &#96;User&#96; to a method, you're passing a reference. Modifications affect the original.
+ 
+ &#96;&#96;&#96;csharp
+ void UpdateEmail(User user)
+ {
+     user.Email = "new@example.com";  // modifies the original
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, structs are value types by default. Pass a struct, you're passing a copy.
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u User) {
+     u.Email = "new@example.com"  // modifies the copy, original unchanged
+ }
+ &#96;&#96;&#96;
+ 
+ If you want reference semantics, you use pointers explicitly:
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u *User) {
+     u.Email = "new@example.com"  // modifies the original via pointer
+ }
+ &#96;&#96;&#96;
+ 
+ This explicitness is jarring at first. In C#, the type itself determines whether you get value or reference semantics (&#96;struct&#96; vs &#96;class&#96;). In Go, the *calling convention* determines it. Same type, different behaviour depending on whether you use &#96;User&#96; or &#96;*User&#96;.
+ 
+ ### When to Use Pointers
+ 
+ The rule of thumb:
+ 
+ | Scenario | Use |
+ |----------|-----|
+ | Method modifies the receiver | &#96;*User&#96; (pointer receiver) |
+ | Struct is large | &#96;*User&#96; (avoid copy overhead) |
+ | You need nil to mean "absent" | &#96;*User&#96; (pointers can be nil) |
+ | Small, immutable data | &#96;User&#96; (value) |
+ | You want copy-on-pass safety | &#96;User&#96; (value) |
+ 
+ In practice, most methods use pointer receivers. It's more consistent, and you don't have to think about whether each method modifies state.
+ 
+ &#96;&#96;&#96;go
+ // Pointer receiver - conventional for most methods
+ func (u *User) UpdateEmail(email string) {
+     u.Email = email
+ }
+ 
+ // Value receiver - acceptable for pure getters on small structs
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Composition Over Inheritance
+ 
+ Go doesn't have inheritance. Full stop. No &#96;class Admin : User&#96;. No &#96;protected&#96; members. No &#96;virtual&#96; methods.
+ 
+ Instead, Go has embedding—a form of composition that feels almost like inheritance but isn't.
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+     Age  int
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ type Employee struct {
+     Person          // embedded - not a field name, just the type
+     EmployeeID string
+     Department string
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;Employee&#96; has all of &#96;Person&#96;'s fields and methods:
+ 
+ &#96;&#96;&#96;go
+ emp := Employee{
+     Person:     Person{Name: "Alice", Age: 30},
+     EmployeeID: "E123",
+     Department: "Engineering",
+ }
+ 
+ fmt.Println(emp.Name)    // "Alice" - promoted from Person
+ fmt.Println(emp.Greet()) // "Hello, I'm Alice" - method promoted too
+ &#96;&#96;&#96;
+ 
+ This *looks* like inheritance, but it's not:
+ 
+ - No polymorphism—you can't pass an &#96;Employee&#96; where a &#96;Person&#96; is expected
+ - No &#96;override&#96;—if &#96;Employee&#96; defines its own &#96;Greet()&#96;, it shadows &#96;Person.Greet()&#96;
+ - The embedded type is still accessible—&#96;emp.Person.Name&#96; works
+ 
+ ### When You'll Miss Inheritance
+ 
+ Let's be honest: sometimes you'll miss it.
+ 
+ **Template Method Pattern**—In C#, you'd have a base class with a &#96;virtual&#96; method that subclasses override. Go has no direct equivalent. You use interfaces and composition instead, which works but feels more verbose.
+ 
+ **Protected Members**—There's no "visible to derived types" concept. Everything is either exported (public) or unexported (package-private). For library design, this can be limiting.
+ 
+ **Deep Hierarchies**—If your C# design has &#96;Animal -&gt; Mammal -&gt; Dog -&gt; Labrador&#96;, Go will make you rethink that structure entirely. Usually for the better, but the rethinking takes effort.
+ 
+ ## Interfaces Are Implicit
+ 
+ Here's where Go gets genuinely interesting. Interfaces are satisfied implicitly—no &#96;implements&#96; keyword.
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IGreeter
+ {
+     string Greet();
+ }
+ 
+ public class Person : IGreeter  // explicit implementation
+ {
+     public string Name { get; set; }
+     public string Greet() =&gt; $"Hello, I'm {Name}";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Greeter interface {
+     Greet() string
+ }
+ 
+ type Person struct {
+     Name string
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ // Person now implements Greeter - no declaration needed
+ &#96;&#96;&#96;
+ 
+ If a type has the methods an interface requires, it implements that interface. Period. No ceremony.
+ 
+ This has profound implications:
+ 
+ 1. **You can define interfaces after the fact**—create an interface that existing types already satisfy
+ 2. **Small interfaces are encouraged**—the standard library is full of one-method interfaces
+ 3. **Testing is trivial**—any type with the right methods can be substituted
+ 
+ The &#96;io.Reader&#96; interface is the canonical example:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ &#96;&#96;&#96;
+ 
+ One method. But files, network connections, byte buffers, HTTP response bodies—they all implement it. Polymorphism without inheritance.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Classes | Go Structs |
+ |--------|-----------|------------|
+ | Reference/value | Reference by default | Value by default |
+ | Inheritance | Full class inheritance | Embedding (composition) |
+ | Interface implementation | Explicit (&#96;implements&#96;) | Implicit (duck typing) |
+ | Constructors | Special syntax | Convention (&#96;NewX&#96; functions) |
+ | Access modifiers | &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96; | Exported (capital) or unexported |
+ | Polymorphism | Inheritance + interfaces | Interfaces only |
+ | Method declaration | Inside class body | Separate, attached to type |
+ 
+ ## What I Actually Miss
+ 
+ After a few months, here's my honest assessment:
+ 
+ **Don't miss at all:**
+ - Complex inheritance hierarchies (they were usually a mistake anyway)
+ - The &#96;virtual&#96;/&#96;override&#96; dance
+ - Explicit interface implementation for conflicts
+ 
+ **Sometimes miss:**
+ - &#96;protected&#96; for carefully designed extension points
+ - Abstract classes with partial implementations
+ - The template method pattern (can be done in Go, just clunkier)
+ 
+ **Actively prefer Go's approach:**
+ - Implicit interface satisfaction
+ - Explicit value vs reference choice at call site
+ - Composition via embedding
+ - Small, focused interfaces
+ 
+ The shift from "design your class hierarchy upfront" to "compose small pieces and let interfaces emerge" takes adjustment. But it tends to produce simpler code.
+ 
+ ## The Practical Bit
+ 
+ If you're converting C# code to Go, here's the process I use:
+ 
+ 1. **Start with structs for data**—no methods yet, just fields
+ 2. **Add methods as needed**—use pointer receivers by default
+ 3. **Extract interfaces late**—when you need polymorphism, create the smallest interface that works
+ 4. **Embed for code reuse**—not "inheritance", just "I want those fields and methods too"
+ 5. **Resist the urge to build hierarchies**—if you're thinking "base class", stop and reconsider
+ 
+ The code ends up flatter. More types, shallower relationships. It's different, not worse.
+ 
+ ---
+ 
+ *Next up: visibility and the death of properties—why Go uses capitalisation instead of access modifiers, and why you'll stop missing getters and setters faster than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-visibility.md</summary>

**Chunk 1**
Lines added: 299, lines removed: 1

```diff
@@ -1,1 +1,299 @@
- 
+ +++
+ title = "Where Did My Properties Go?"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Coming from C#, one of the first things you'll notice is that Go structs look... naked. Where are the &#96;{ get; set; }&#96; blocks? Where's &#96;private&#96; and &#96;public&#96;? How do you encapsulate anything?
+ 
+ The answer involves capitalisation, a complete absence of properties, and a philosophy that might make you uncomfortable before it makes you productive.
+ 
+ ## Visibility via Capitalisation
+ 
+ Go has exactly two visibility levels:
+ 
+ - **Exported** (capital first letter): visible outside the package
+ - **Unexported** (lowercase first letter): visible only within the package
+ 
+ That's it. No &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96;. Just case.
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ type User struct {
+     Name  string    // Exported - other packages can access
+     Email string    // Exported
+     hash  string    // unexported - only this package can access
+ }
+ 
+ func (u *User) SetPassword(password string) {
+     u.hash = hashPassword(password)  // can access hash internally
+ }
+ 
+ func hashPassword(p string) string {  // unexported function
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ From another package:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import "myapp/user"
+ 
+ func main() {
+     u := user.User{Name: "Alice", Email: "alice@example.com"}
+     u.SetPassword("secret")  // works - SetPassword is exported
+     
+     // u.hash = "something"  // won't compile - hash is unexported
+ }
+ &#96;&#96;&#96;
+ 
+ ### The Mental Adjustment
+ 
+ In C#, visibility is per-member and you have fine-grained control. In Go, the package is the unit of encapsulation.
+ 
+ | C# | Go Equivalent |
+ |----|---------------|
+ | &#96;public&#96; | Capitalised name |
+ | &#96;private&#96; | Lowercase name |
+ | &#96;protected&#96; | Doesn't exist |
+ | &#96;internal&#96; | Lowercase (package = assembly, roughly) |
+ | &#96;private protected&#96; | Doesn't exist |
+ 
+ The lack of &#96;protected&#96; is the big one. There's no "visible to derived types" because there are no derived types. Embedding doesn't grant special access—embedded types can only access their own unexported members.
+ 
+ ## No Properties, Just Fields
+ 
+ Here's the controversial bit. Go doesn't have properties. No getters. No setters. Just fields.
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     private string _email;
+     
+     public string Email
+     {
+         get =&gt; _email;
+         set
+         {
+             ValidateEmail(value);
+             _email = value.ToLowerInvariant();
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the idiomatic approach is... don't do that:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Email string
+ }
+ &#96;&#96;&#96;
+ 
+ Wait, what about validation? What about normalisation?
+ 
+ Go's answer: if you need to do something when a value changes, make a method for it:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     email string  // unexported
+ }
+ 
+ func (u *User) Email() string {
+     return u.email
+ }
+ 
+ func (u *User) SetEmail(email string) error {
+     if !isValidEmail(email) {
+         return errors.New("invalid email")
+     }
+     u.email = strings.ToLower(email)
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is more verbose than C# properties. Undeniably. You write more code.
+ 
+ But here's the thing: now the call site makes it obvious that something's happening.
+ 
+ &#96;&#96;&#96;go
+ // Caller knows this might fail
+ err := user.SetEmail("alice@example.com")
+ 
+ // vs a property that silently transforms or might panic
+ user.Email = "alice@example.com"  // what does this actually do?
+ &#96;&#96;&#96;
+ 
+ ### When to Use Bare Fields
+ 
+ The Go community's guidance is: **export fields when they're truly just data**.
+ 
+ &#96;&#96;&#96;go
+ // Config is just data, exported fields are fine
+ type Config struct {
+     Host     string
+     Port     int
+     Timeout  time.Duration
+     Debug    bool
+ }
+ 
+ // User has invariants to maintain, unexport fields + methods
+ type User struct {
+     id        int64
+     email     string
+     createdAt time.Time
+ }
+ &#96;&#96;&#96;
+ 
+ This feels wrong to C# developers who've been taught that bare fields are always bad. But Go's standard library is full of exported fields:
+ 
+ &#96;&#96;&#96;go
+ // From net/http
+ type Request struct {
+     Method string
+     URL    *url.URL
+     Header Header
+     Body   io.ReadCloser
+     // ... many more exported fields
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;http.Request&#96; struct has exported fields because that's what makes sense. You read and modify them directly. No ceremony.
+ 
+ ## The "Getter/Setter" Convention
+ 
+ When you do need accessor methods, Go has a naming convention that'll trip you up:
+ 
+ &#96;&#96;&#96;go
+ // C# instinct - WRONG in Go
+ func (u *User) GetEmail() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ 
+ // Go convention - CORRECT
+ func (u *User) Email() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ &#96;&#96;&#96;
+ 
+ Notice: the getter is just &#96;Email()&#96;, not &#96;GetEmail()&#96;. The setter keeps the &#96;Set&#96; prefix.
+ 
+ This feels inconsistent until you see it in use:
+ 
+ &#96;&#96;&#96;go
+ email := user.Email()          // reads like accessing a value
+ user.SetEmail("new@example.com")  // reads like an action
+ &#96;&#96;&#96;
+ 
+ The asymmetry is intentional. Getting a value should feel like accessing a value. Setting a value should look like you're doing something.
+ 
+ ## The Package as Encapsulation Boundary
+ 
+ Here's where Go's model actually shines: the package is the natural unit of encapsulation.
+ 
+ In C#, you often have one class per file, and you think about encapsulation at the class level. You might have &#96;internal&#96; methods that are really just for one other class in the same assembly.
+ 
+ In Go, all files in a package share the same namespace. Unexported identifiers are visible across all files in the package:
+ 
+ &#96;&#96;&#96;go
+ // user/user.go
+ package user
+ 
+ type User struct {
+     email string
+ }
+ 
+ // user/validation.go  
+ package user
+ 
+ func validateUser(u *User) error {
+     // Can access u.email - same package
+     if u.email == "" {
+         return errors.New("email required")
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This encourages small, focused packages where the implementation details can be shared freely within the package boundary, but the public API is carefully controlled.
+ 
+ ### The &#96;internal&#96; Directory
+ 
+ Go has one more visibility mechanism: the &#96;internal&#96; directory convention.
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── internal/
+ │   └── auth/
+ │       └── token.go    // only importable by myproject and its children
+ ├── api/
+ │   └── handler.go      // can import internal/auth
+ └── main.go             // can import internal/auth
+ &#96;&#96;&#96;
+ 
+ Packages under &#96;internal/&#96; can only be imported by packages rooted at the parent of &#96;internal&#96;. This gives you "internal to this module" visibility without language keywords.
+ 
+ ## Struct Tags
+ 
+ One thing C# attributes do that Go handles differently: metadata on fields. Go uses struct tags:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID        int64     &#96;json:"id" db:"user_id"&#96;
+     Email     string    &#96;json:"email" db:"email" validate:"required,email"&#96;
+     CreatedAt time.Time &#96;json:"created_at" db:"created_at"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ These are just strings—the runtime and libraries parse them by convention. The &#96;json&#96; package looks for &#96;json:&#96; tags. Database libraries look for &#96;db:&#96; tags. Validation libraries look for &#96;validate:&#96; tags.
+ 
+ It's less type-safe than C# attributes (no compile-time checking of tag names), but it's simple and works.
+ 
+ ## The Honest Take
+ 
+ After months of Go, here's where I've landed:
+ 
+ **Things I like better than C#:**
+ 
+ - **Simplicity of the model**. Two visibility levels, no exceptions.
+ - **Package-level encapsulation**. Encourages cohesive packages.
+ - **Explicit methods over magic properties**. Call sites are clear about what's happening.
+ - **The &#96;internal&#96; convention**. Solves the "internal to this module" case elegantly.
+ 
+ **Things I miss from C#:**
+ 
+ - **&#96;protected&#96; for library extension**. Sometimes you want "derived types only" access.
+ - **Computed properties**. &#96;user.FullName&#96; is nicer than &#96;user.FullName()&#96; when it's genuinely just a computed value.
+ - **Init-only setters**. Go has no equivalent to &#96;init&#96; for construction-time-only setting.
+ - **Attributes**. Struct tags work but aren't type-safe.
+ 
+ **Things that are just different:**
+ 
+ - **Capitalisation visibility**. Weird for a week, then invisible.
+ - **No &#96;get&#96;/&#96;set&#96; syntax**. More typing, but more explicit.
+ - **Fields vs properties**. Go trusts you to know when bare fields are appropriate.
+ 
+ ## Practical Advice
+ 
+ 1. **Start with exported fields for DTOs**. Structs that just carry data (configs, API responses, database rows) don't need method accessors.
+ 
+ 2. **Use unexported fields when invariants matter**. If setting a value could break something, make it unexported and provide methods.
+ 
+ 3. **Name getters without &#96;Get&#96;**. It's &#96;Email()&#96;, not &#96;GetEmail()&#96;.
+ 
+ 4. **Return errors from setters that validate**. Don't panic, don't silently fail.
+ 
+ 5. **Keep packages small and focused**. The package boundary is your encapsulation tool—make packages that are cohesive enough that sharing unexported identifiers makes sense.
+ 
+ 6. **Use &#96;internal/&#96; for module-private packages**. Better than making everything unexported in a shared package.
+ 
+ The shift from "everything should have properties" to "fields are fine, methods when needed" takes time. But once you stop fighting it, Go code ends up pleasantly straightforward.
+ 
+ ---
+ 
+ *Next up: generics in Go—what we got in Go 1.18, where the gaps are, and why you'll need to adjust your expectations if you're used to C#'s mature generics.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generics.md</summary>

**Chunk 1**
Lines added: 331, lines removed: 1

```diff
@@ -1,1 +1,331 @@
- 
+ +++
+ title = "Generics: Late to the Party"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "generics", "csharp"]
+ +++
+ 
+ Go shipped generics in version 1.18 (March 2022). C# has had them since 2.0 (November 2005). That's a seventeen-year head start, and it shows.
+ 
+ If you're coming from C# expecting the same power and flexibility, you'll be disappointed. Go's generics are deliberately constrained—they solve the common cases but won't let you build the same abstractions you're used to.
+ 
+ Let's look at what we've got, what's missing, and whether that matters.
+ 
+ ## The Basic Syntax
+ 
+ A generic function in Go:
+ 
+ &#96;&#96;&#96;go
+ func Map[T, U any](items []T, f func(T) U) []U {
+     result := make([]U, len(items))
+     for i, item := range items {
+         result[i] = f(item)
+     }
+     return result
+ }
+ 
+ // Usage
+ numbers := []int{1, 2, 3, 4}
+ squared := Map(numbers, func(n int) int { return n * n })
+ &#96;&#96;&#96;
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public static IEnumerable&lt;U&gt; Map&lt;T, U&gt;(IEnumerable&lt;T&gt; items, Func&lt;T, U&gt; f)
+ {
+     foreach (var item in items)
+         yield return f(item);
+ }
+ 
+ // Usage  
+ var numbers = new[] { 1, 2, 3, 4 };
+ var squared = Map(numbers, n =&gt; n * n);
+ &#96;&#96;&#96;
+ 
+ The syntax is different but the concept is familiar. Type parameters go in square brackets in Go (&#96;[T, U any]&#96;) rather than angle brackets (&#96;&lt;T, U&gt;&#96;). The &#96;any&#96; is a constraint—more on that shortly.
+ 
+ ## Constraints
+ 
+ Here's where Go's approach diverges. In C#, you constrain type parameters with &#96;where&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ public T Max&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;
+ {
+     return a.CompareTo(b) &gt; 0 ? a : b;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, constraints are interfaces:
+ 
+ &#96;&#96;&#96;go
+ func Max[T cmp.Ordered](a, b T) T {
+     if a &gt; b {
+         return a
+     }
+     return b
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;cmp.Ordered&#96; constraint (from the standard library) allows the &#96;&gt;&#96; operator. Without it, Go wouldn't know that &#96;T&#96; supports comparison.
+ 
+ ### Built-in Constraints
+ 
+ Go provides some standard constraints in the &#96;constraints&#96; and &#96;cmp&#96; packages:
+ 
+ | Constraint | What it allows |
+ |-----------|----------------|
+ | &#96;any&#96; | Any type (alias for &#96;interface{}&#96;) |
+ | &#96;comparable&#96; | Types that support &#96;==&#96; and &#96;!=&#96; |
+ | &#96;cmp.Ordered&#96; | Types that support &#96;&lt;&#96;, &#96;&gt;&#96;, &#96;&lt;=&#96;, &#96;&gt;=&#96; |
+ | &#96;constraints.Integer&#96; | All integer types |
+ | &#96;constraints.Float&#96; | All float types |
+ | &#96;constraints.Signed&#96; | Signed integers |
+ | &#96;constraints.Unsigned&#96; | Unsigned integers |
+ 
+ ### Custom Constraints
+ 
+ You can define your own constraints as interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Number interface {
+     ~int | ~int64 | ~float64
+ }
+ 
+ func Sum[T Number](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ That &#96;~int&#96; syntax means "any type whose underlying type is int". This lets you include type aliases and defined types, not just the primitive itself.
+ 
+ ## Generic Types
+ 
+ Generic structs work as you'd expect:
+ 
+ &#96;&#96;&#96;go
+ type Stack[T any] struct {
+     items []T
+ }
+ 
+ func (s *Stack[T]) Push(item T) {
+     s.items = append(s.items, item)
+ }
+ 
+ func (s *Stack[T]) Pop() (T, bool) {
+     if len(s.items) == 0 {
+         var zero T
+         return zero, false
+     }
+     item := s.items[len(s.items)-1]
+     s.items = s.items[:len(s.items)-1]
+     return item, true
+ }
+ 
+ // Usage
+ stack := &amp;Stack[string]{}
+ stack.Push("hello")
+ value, ok := stack.Pop()
+ &#96;&#96;&#96;
+ 
+ ## Where the Gaps Hurt
+ 
+ Right, here's the honest bit. Go's generics are limited in ways that'll frustrate you coming from C#.
+ 
+ ### No Generic Methods on Non-Generic Types
+ 
+ In C#, you can do this:
+ 
+ &#96;&#96;&#96;csharp
+ public class Converter
+ {
+     public T Convert&lt;T&gt;(string value) { ... }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, you can't add a generic method to a non-generic type. This doesn't compile:
+ 
+ &#96;&#96;&#96;go
+ type Converter struct{}
+ 
+ // ERROR: method must have no type parameters
+ func (c Converter) Convert[T any](value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ You have to use a generic function instead:
+ 
+ &#96;&#96;&#96;go
+ func Convert[T any](c Converter, value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ It works, but it's clunkier and doesn't chain as nicely.
+ 
+ ### No Specialisation
+ 
+ C# lets you specialise behaviour based on type arguments (with runtime checks or partial specialisation). Go doesn't. You can't do:
+ 
+ &#96;&#96;&#96;go
+ func Process[T any](item T) {
+     // Can't check "if T is string, do this"
+     // Can't have different implementations for different T
+ }
+ &#96;&#96;&#96;
+ 
+ Everything must work uniformly for all types that satisfy the constraint.
+ 
+ ### No Variance
+ 
+ C# has covariance (&#96;out T&#96;) and contravariance (&#96;in T&#96;) for generic interfaces. Go has neither. A &#96;Stack[Dog]&#96; is not a &#96;Stack[Animal]&#96;, even if &#96;Dog&#96; implements &#96;Animal&#96;. Ever.
+ 
+ ### No Arithmetic Constraints (Sort Of)
+ 
+ Want to write a generic sum function? You need to constrain to types that support &#96;+&#96;:
+ 
+ &#96;&#96;&#96;go
+ func Sum[T constraints.Integer | constraints.Float](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ This works, but you can't easily extend it to custom numeric types. The constraint system is based on underlying types, not operators.
+ 
+ ### No Default Type Arguments
+ 
+ C# has:
+ 
+ &#96;&#96;&#96;csharp
+ public class Cache&lt;TKey, TValue, TSerializer = JsonSerializer&gt; { }
+ &#96;&#96;&#96;
+ 
+ Go doesn't. Every type parameter must be specified at use sites (though type inference helps for functions).
+ 
+ ## The Standard Library's Generics
+ 
+ Go 1.21+ added generic functions to the standard library. These are genuinely useful:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "maps"
+     "slices"
+ )
+ 
+ // Slices
+ numbers := []int{3, 1, 4, 1, 5, 9}
+ slices.Sort(numbers)
+ found := slices.Contains(numbers, 4)
+ maxVal := slices.Max(numbers)
+ 
+ // Maps  
+ m := map[string]int{"a": 1, "b": 2}
+ keys := maps.Keys(m)    // iterator over keys
+ values := maps.Values(m) // iterator over values
+ maps.Clone(m)           // shallow copy
+ &#96;&#96;&#96;
+ 
+ Before generics, you'd write these loops by hand every time. Now they're type-safe and reusable.
+ 
+ ## When You'll Feel the Gaps
+ 
+ **Building Fluent APIs**
+ 
+ In C#, you might build a fluent configuration API with generic methods:
+ 
+ &#96;&#96;&#96;csharp
+ builder
+     .WithOption&lt;ConnectionOptions&gt;(opts =&gt; opts.Timeout = 30)
+     .WithOption&lt;RetryOptions&gt;(opts =&gt; opts.MaxRetries = 3)
+     .Build();
+ &#96;&#96;&#96;
+ 
+ This pattern is harder in Go because you can't have generic methods. You'd need a different approach—probably top-level functions or a less fluent API.
+ 
+ **Repository Patterns**
+ 
+ The classic &#96;IRepository&lt;T&gt;&#96; with &#96;Find&lt;TKey&gt;&#96; is awkward:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work - can't have generic method
+ type Repository[T any] interface {
+     Find[K comparable](id K) (T, error)  // ERROR
+ }
+ 
+ // You'd need this instead
+ type Repository[T any, K comparable] interface {
+     Find(id K) (T, error)
+ }
+ &#96;&#96;&#96;
+ 
+ Two type parameters instead of one, threaded through everything.
+ 
+ **LINQ-style Operations**
+ 
+ C# LINQ chains beautifully with generic extension methods:
+ 
+ &#96;&#96;&#96;csharp
+ items.Where(x =&gt; x.Active).Select(x =&gt; x.Name).OrderBy(x =&gt; x).ToList();
+ &#96;&#96;&#96;
+ 
+ Go has no extension methods. You'd write:
+ 
+ &#96;&#96;&#96;go
+ result := slices.Sorted(
+     slices.Collect(
+         Map(
+             Filter(items, func(x Item) bool { return x.Active }),
+             func(x Item) string { return x.Name },
+         ),
+     ),
+ )
+ &#96;&#96;&#96;
+ 
+ Functional, but not as elegant.
+ 
+ ## The Practical Advice
+ 
+ After working with Go's generics, here's how I use them:
+ 
+ **Do use generics for:**
+ - Data structures (stacks, queues, trees, caches)
+ - Collection utilities (map, filter, reduce)
+ - Type-safe wrappers around &#96;interface{}&#96;
+ - Eliminating repetitive code across similar types
+ 
+ **Don't use generics for:**
+ - Everything. Go's non-generic code is often clearer.
+ - Patterns that require generic methods (rethink the design)
+ - Complex type relationships (the constraint syntax gets unwieldy)
+ 
+ **Accept these limitations:**
+ - Write more concrete types, fewer abstractions
+ - Use interfaces for polymorphism, generics for type safety
+ - Sometimes duplicate code is clearer than a generic contortion
+ 
+ ## The Honest Assessment
+ 
+ | Aspect | C# Generics | Go Generics |
+ |--------|------------|-------------|
+ | Maturity | 20 years | 3 years |
+ | Generic methods | Yes | Only on generic types |
+ | Variance | Full (in/out) | None |
+ | Constraints | Rich (interfaces, new(), class, struct) | Interfaces only |
+ | Specialisation | Partial (with runtime checks) | None |
+ | Standard library | Extensive | Growing |
+ 
+ Go's generics are *good enough* for most real-world needs. They eliminate the pre-1.18 pain of &#96;interface{}&#96; everywhere or code generation. But they're not trying to match C#'s power.
+ 
+ The Go team explicitly chose to ship a simpler system first, with room to expand. Whether the gaps will be filled or the community will adapt around them remains to be seen.
+ 
+ For now? Lower your expectations, use generics where they help, and don't twist yourself into knots trying to replicate C# patterns that don't translate well.
+ 
+ ---
+ 
+ *Next up: nil in Go versus nullable reference types in C#—two different approaches to the billion dollar mistake, and why both languages still get caught out.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-nil.md</summary>

**Chunk 1**
Lines added: 312, lines removed: 1

```diff
@@ -1,1 +1,312 @@
- 
+ +++
+ title = "The Million Dollar Mistake, Differently"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "nil", "csharp"]
+ +++
+ 
+ Tony Hoare called null references his "billion dollar mistake." Both C# and Go inherited some form of this mistake, but they've evolved to handle it differently. Neither solution is perfect.
+ 
+ If you're coming from C# 8+ with nullable reference types enabled, Go's approach will feel like stepping backwards. And in some ways, it is. But there's nuance here.
+ 
+ ## The C# Journey
+ 
+ C# started with null everywhere. Any reference type could be null, always. This gave us decades of &#96;NullReferenceException&#96; at runtime.
+ 
+ Then came nullable reference types (NRT) in C# 8:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ 
+ public class User
+ {
+     public string Name { get; set; }        // Non-nullable - compiler warns if null
+     public string? MiddleName { get; set; } // Nullable - explicitly marked
+ }
+ 
+ public void Process(User user)
+ {
+     Console.WriteLine(user.Name.Length);    // Safe - compiler knows it's not null
+     Console.WriteLine(user.MiddleName.Length); // Warning! Might be null
+     
+     // Must check first
+     if (user.MiddleName != null)
+     {
+         Console.WriteLine(user.MiddleName.Length); // Now safe
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler tracks nullability and warns you. It's not perfect—it's still a warning system, not a guarantee—but it catches loads of bugs at compile time.
+ 
+ ## Go's Approach: Everything Is Potentially Nil (But Different)
+ 
+ Go has &#96;nil&#96;, and it works differently depending on the type. Here's the landscape:
+ 
+ | Type | Can be nil? | Zero value |
+ |------|-------------|------------|
+ | Pointers (&#96;*T&#96;) | Yes | &#96;nil&#96; |
+ | Slices | Yes | &#96;nil&#96; (but usable!) |
+ | Maps | Yes | &#96;nil&#96; (but NOT usable for writes) |
+ | Channels | Yes | &#96;nil&#96; |
+ | Interfaces | Yes | &#96;nil&#96; |
+ | Functions | Yes | &#96;nil&#96; |
+ | Structs | No | Zero struct |
+ | Primitives | No | 0, "", false, etc. |
+ 
+ Let's dig into the weird bits.
+ 
+ ### Nil Slices Are Fine
+ 
+ This is the first surprise. A nil slice is usable:
+ 
+ &#96;&#96;&#96;go
+ var s []int    // nil slice
+ len(s)         // 0 - works fine
+ cap(s)         // 0 - works fine
+ s = append(s, 1, 2, 3)  // works fine! Now s is [1, 2, 3]
+ 
+ for _, v := range s { } // works even when nil (iterates zero times)
+ &#96;&#96;&#96;
+ 
+ A nil slice isn't "no slice"—it's an empty slice with no backing array. Most operations work. This is intentional and idiomatic.
+ 
+ ### Nil Maps Are NOT Fine
+ 
+ But a nil map will bite you:
+ 
+ &#96;&#96;&#96;go
+ var m map[string]int  // nil map
+ 
+ v := m["key"]         // works! Returns zero value (0)
+ _, ok := m["key"]     // works! ok is false
+ 
+ m["key"] = 1          // PANIC: assignment to entry in nil map
+ &#96;&#96;&#96;
+ 
+ Reading from a nil map works (returns zero values). Writing to a nil map panics. This inconsistency catches everyone at least once.
+ 
+ Always initialise maps:
+ 
+ &#96;&#96;&#96;go
+ m := make(map[string]int)
+ // or
+ m := map[string]int{}
+ &#96;&#96;&#96;
+ 
+ ### The Interface Nil Trap
+ 
+ This one is genuinely confusing. An interface can be nil in two ways:
+ 
+ &#96;&#96;&#96;go
+ type Writer interface {
+     Write([]byte) (int, error)
+ }
+ 
+ var w Writer = nil     // nil interface - both type and value are nil
+ fmt.Println(w == nil)  // true
+ 
+ var buf *bytes.Buffer = nil  // nil pointer
+ var w2 Writer = buf          // interface with nil concrete value
+ fmt.Println(w2 == nil)       // FALSE!
+ &#96;&#96;&#96;
+ 
+ Wait, what?
+ 
+ An interface value is nil only if both its type and value are nil. If you assign a nil pointer to an interface, the interface has a type (the pointer type) but a nil value. It's not a nil interface.
+ 
+ This causes bugs like:
+ 
+ &#96;&#96;&#96;go
+ func process(w Writer) {
+     if w != nil {
+         w.Write(data)  // might panic! w could be non-nil interface with nil value
+     }
+ }
+ 
+ var buf *bytes.Buffer = nil
+ process(buf)  // passes the nil check, then panics
+ &#96;&#96;&#96;
+ 
+ The fix is to either check the concrete type too, or (better) never assign nil pointers to interfaces.
+ 
+ ## Zero Values as Nullability
+ 
+ Go's approach to handling "absent" values is the zero value:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     Age       int
+     CreatedAt time.Time
+ }
+ 
+ var u User
+ // u is now {Name: "", Email: "", Age: 0, CreatedAt: zero time}
+ &#96;&#96;&#96;
+ 
+ Every field has a defined zero value. There's no "unset" state—just "set to zero."
+ 
+ This works well for many cases:
+ 
+ &#96;&#96;&#96;go
+ // Empty string often means "not set"
+ if user.Email == "" {
+     // No email provided
+ }
+ 
+ // But what if 0 is a valid age?
+ if user.Age == 0 {
+     // Is this "not set" or "newborn"?
+ }
+ &#96;&#96;&#96;
+ 
+ When you need to distinguish "not set" from "zero value," you have options:
+ 
+ ### Option 1: Pointers
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name  string
+     Age   *int  // nil means not set, *int value means set
+ }
+ 
+ func (u User) HasAge() bool {
+     return u.Age != nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is the closest to C#'s &#96;int?&#96;. But you pay the pointer indirection cost and the nil-checking overhead.
+ 
+ ### Option 2: The "ok" Pattern
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     name    string
+     nameSet bool
+ }
+ 
+ func (u User) Name() (string, bool) {
+     return u.name, u.nameSet
+ }
+ &#96;&#96;&#96;
+ 
+ Explicit, but verbose.
+ 
+ ### Option 3: Wrapper Types
+ 
+ &#96;&#96;&#96;go
+ import "database/sql"
+ 
+ type User struct {
+     Name sql.NullString
+     Age  sql.NullInt64
+ }
+ 
+ if user.Name.Valid {
+     fmt.Println(user.Name.String)
+ }
+ &#96;&#96;&#96;
+ 
+ The standard library has these for database interop. They're clunky but explicit.
+ 
+ ## Error Handling and Nil
+ 
+ Go's error handling interacts with nil constantly:
+ 
+ &#96;&#96;&#96;go
+ func LoadUser(id string) (*User, error) {
+     // ...
+ }
+ 
+ user, err := LoadUser("123")
+ if err != nil {
+     return nil, err
+ }
+ // Use user - we know it's not nil because no error
+ &#96;&#96;&#96;
+ 
+ The convention is: if &#96;err != nil&#96;, don't trust the other return values. If &#96;err == nil&#96;, the values should be valid.
+ 
+ But this is convention, not enforcement. Nothing stops you from writing:
+ 
+ &#96;&#96;&#96;go
+ return nil, nil  // No user, no error - bad practice!
+ &#96;&#96;&#96;
+ 
+ The compiler won't save you from this. Code review and convention do.
+ 
+ ## What I Miss from C#
+ 
+ **Compile-time nullability tracking.** C#'s NRT warns you when you dereference something that might be null. Go just lets you do it.
+ 
+ **The null-conditional operators.** &#96;user?.Profile?.Address?.City&#96; in C# is a single expression. In Go:
+ 
+ &#96;&#96;&#96;go
+ var city string
+ if user != nil &amp;&amp; user.Profile != nil &amp;&amp; user.Profile.Address != nil {
+     city = user.Profile.Address.City
+ }
+ &#96;&#96;&#96;
+ 
+ **Null-coalescing.** &#96;name ?? "Unknown"&#96; vs:
+ 
+ &#96;&#96;&#96;go
+ name := user.Name
+ if name == "" {
+     name = "Unknown"
+ }
+ &#96;&#96;&#96;
+ 
+ Go 1.22 added some helpers, but nothing as clean.
+ 
+ ## What Go Does Well
+ 
+ **Zero values are useful defaults.** A zero &#96;sync.Mutex&#96; works. A zero &#96;bytes.Buffer&#96; works. You don't need constructor ceremonies for basic types.
+ 
+ **No null reference exceptions.** You get panics on nil pointer dereference, but nil slices, nil channels (blocks forever), and nil maps (read) don't crash.
+ 
+ **Explicit pointer semantics.** When something can be nil, it's a pointer. Value types can't be nil. The type tells you what to expect.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# (with NRT) | Go |
+ |--------|---------------|-----|
+ | Compile-time null tracking | Yes (warnings) | No |
+ | Runtime null safety | NullReferenceException | Panic on nil dereference |
+ | Nullable value types | &#96;int?&#96; / &#96;Nullable&lt;T&gt;&#96; | &#96;*int&#96; or wrapper types |
+ | Zero values | Default to null/zero | Always well-defined |
+ | Null-conditional | &#96;?.&#96;, &#96;??&#96; | Manual checks |
+ | Interface nil trap | No equivalent problem | Yes - be careful |
+ 
+ ## Practical Advice
+ 
+ 1. **Initialise maps eagerly.** Don't leave them nil.
+ 
+ 2. **Never assign nil pointers to interfaces.** Return the zero interface instead:
+    &#96;&#96;&#96;go
+    // Bad
+    var buf *bytes.Buffer = nil
+    return buf
+    
+    // Good
+    return nil
+    &#96;&#96;&#96;
+ 
+ 3. **Use pointers for optional fields sparingly.** Often the zero value is fine for "not set."
+ 
+ 4. **Follow the error convention.** If returning an error, either return good values or nil values, not a mix.
+ 
+ 5. **Check nil before method calls on pointer receivers.** Go lets you call methods on nil receivers, which can work or panic depending on the implementation.
+ 
+ 6. **Accept that the compiler won't catch null dereferences.** Tests and careful coding are your only defence.
+ 
+ The lack of NRT-style static analysis is Go's weakest area compared to modern C#. Tools like &#96;staticcheck&#96; help, but they're not built into the language.
+ 
+ You'll write more nil checks. You'll occasionally miss one. That's the trade-off for Go's simplicity.
+ 
+ ---
+ 
+ *Next up: Go's approach to enums—const blocks, iota, and why you'll miss real enums more than you expected to.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-enums.md</summary>

**Chunk 1**
Lines added: 440, lines removed: 1

```diff
@@ -1,1 +1,440 @@
- 
+ +++
+ title = "No Enums? No Problem (Sort Of)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "enums", "csharp"]
+ +++
+ 
+ Go doesn't have enums. Not "Go has something enum-like"—it genuinely doesn't have a dedicated enum construct. What it has instead is constants, a clever auto-incrementing keyword called &#96;iota&#96;, and convention.
+ 
+ For simple cases, this works fine. For anything more complex, you'll miss C#'s enums more than you expect.
+ 
+ ## The Basic Pattern
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status
+ {
+     Pending,
+     Active,
+     Completed,
+     Cancelled
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down:
+ 
+ 1. **Define a new type** based on an underlying type (usually &#96;int&#96;)
+ 2. **Create a const block** with values of that type
+ 3. **Use &#96;iota&#96;** to auto-increment values (0, 1, 2, 3...)
+ 
+ The &#96;iota&#96; keyword resets to 0 at each &#96;const&#96; block and increments for each line. It's surprisingly powerful:
+ 
+ &#96;&#96;&#96;go
+ // Skip zero (useful when zero should mean "unset")
+ const (
+     _ Status = iota  // 0 - discarded
+     StatusPending    // 1
+     StatusActive     // 2
+     StatusCompleted  // 3
+     StatusCancelled  // 4
+ )
+ 
+ // Bit flags
+ const (
+     FlagRead  = 1 &lt;&lt; iota  // 1
+     FlagWrite              // 2
+     FlagExec               // 4
+ )
+ 
+ // Custom formula
+ const (
+     KB = 1 &lt;&lt; (10 * (iota + 1))  // 1024
+     MB                           // 1048576
+     GB                           // 1073741824
+ )
+ &#96;&#96;&#96;
+ 
+ ## What's Missing
+ 
+ ### No Exhaustive Switch
+ 
+ In C#, if you switch on an enum and miss a case, the compiler can warn you:
+ 
+ &#96;&#96;&#96;csharp
+ Status status = GetStatus();
+ switch (status)
+ {
+     case Status.Pending: // ...
+     case Status.Active:  // ...
+     // Missing Completed and Cancelled - compiler warning (with newer analyzers)
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the compiler doesn't care:
+ 
+ &#96;&#96;&#96;go
+ var status Status = getStatus()
+ switch status {
+ case StatusPending:
+     // ...
+ case StatusActive:
+     // ...
+ // Missing cases? Compiler doesn't notice.
+ }
+ &#96;&#96;&#96;
+ 
+ You can use linters like &#96;exhaustive&#96; to catch this, but it's not built in.
+ 
+ ### No Name Resolution
+ 
+ C#'s enums have built-in stringification:
+ 
+ &#96;&#96;&#96;csharp
+ Status.Active.ToString()  // "Active"
+ Enum.Parse&lt;Status&gt;("Active")  // Status.Active
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just integers. No automatic name mapping:
+ 
+ &#96;&#96;&#96;go
+ fmt.Println(StatusActive)  // prints "1" - not useful
+ 
+ // You have to implement String() yourself
+ func (s Status) String() string {
+     switch s {
+     case StatusPending:
+         return "Pending"
+     case StatusActive:
+         return "Active"
+     case StatusCompleted:
+         return "Completed"
+     case StatusCancelled:
+         return "Cancelled"
+     default:
+         return fmt.Sprintf("Status(%d)", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This gets tedious. Tools like &#96;stringer&#96; can generate these methods, but it's an extra build step.
+ 
+ ### No Type Safety (Not Really)
+ 
+ C#'s enums prevent you from using arbitrary values:
+ 
+ &#96;&#96;&#96;csharp
+ Status s = (Status)999;  // Compiles but feels wrong
+ // Modern analyzers can warn about this
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just typed integers. Any int can be cast:
+ 
+ &#96;&#96;&#96;go
+ var s Status = 999  // Perfectly valid, no warning
+ &#96;&#96;&#96;
+ 
+ Nothing stops you from creating invalid values. The type gives you some protection (can't accidentally pass an &#96;int&#96; where &#96;Status&#96; is expected), but it's weak.
+ 
+ ### No Flag Enums with Utility Methods
+ 
+ C#'s &#96;[Flags]&#96; attribute gives you &#96;HasFlag&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ [Flags]
+ public enum Permissions
+ {
+     None = 0,
+     Read = 1,
+     Write = 2,
+     Execute = 4
+ }
+ 
+ var perms = Permissions.Read | Permissions.Write;
+ perms.HasFlag(Permissions.Read)  // true
+ &#96;&#96;&#96;
+ 
+ Go gives you nothing. You do bit manipulation manually:
+ 
+ &#96;&#96;&#96;go
+ const (
+     PermissionNone = 0
+     PermissionRead = 1 &lt;&lt; iota
+     PermissionWrite
+     PermissionExecute
+ )
+ 
+ perms := PermissionRead | PermissionWrite
+ hasRead := perms&amp;PermissionRead != 0  // manual check
+ &#96;&#96;&#96;
+ 
+ Not hard, but not helpful either.
+ 
+ ## Making It Better
+ 
+ Here's how the Go community works around these limitations:
+ 
+ ### The Stringer Tool
+ 
+ Generate &#96;String()&#96; methods automatically:
+ 
+ &#96;&#96;&#96;bash
+ go install golang.org/x/tools/cmd/stringer@latest
+ &#96;&#96;&#96;
+ 
+ Add a generate directive:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=Status
+ 
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Run &#96;go generate ./...&#96; and you get a &#96;status_string.go&#96; file with the &#96;String()&#96; method implemented.
+ 
+ ### Validation Methods
+ 
+ Add explicit validation:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) IsValid() bool {
+     switch s {
+     case StatusPending, StatusActive, StatusCompleted, StatusCancelled:
+         return true
+     default:
+         return false
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Slice of All Values
+ 
+ Useful for iteration and testing:
+ 
+ &#96;&#96;&#96;go
+ var AllStatuses = []Status{
+     StatusPending,
+     StatusActive,
+     StatusCompleted,
+     StatusCancelled,
+ }
+ 
+ func (s Status) IsValid() bool {
+     return slices.Contains(AllStatuses, s)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parse Functions
+ 
+ For deserialisation:
+ 
+ &#96;&#96;&#96;go
+ func ParseStatus(s string) (Status, error) {
+     switch s {
+     case "Pending", "pending":
+         return StatusPending, nil
+     case "Active", "active":
+         return StatusActive, nil
+     case "Completed", "completed":
+         return StatusCompleted, nil
+     case "Cancelled", "cancelled":
+         return StatusCancelled, nil
+     default:
+         return 0, fmt.Errorf("unknown status: %s", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### JSON Marshalling
+ 
+ By default, Go's JSON marshaller uses the integer value. You probably want the string:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     parsed, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = parsed
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ ## A Complete "Enum" Implementation
+ 
+ Here's what a production-ready Go "enum" looks like:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota + 1  // start at 1, 0 means "unset"
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ 
+ var statusNames = map[Status]string{
+     StatusPending:   "Pending",
+     StatusActive:    "Active",
+     StatusCompleted: "Completed",
+     StatusCancelled: "Cancelled",
+ }
+ 
+ var statusValues = map[string]Status{
+     "Pending":   StatusPending,
+     "Active":    StatusActive,
+     "Completed": StatusCompleted,
+     "Cancelled": StatusCancelled,
+ }
+ 
+ func (s Status) String() string {
+     if name, ok := statusNames[s]; ok {
+         return name
+     }
+     return fmt.Sprintf("Status(%d)", s)
+ }
+ 
+ func ParseStatus(s string) (Status, error) {
+     if v, ok := statusValues[s]; ok {
+         return v, nil
+     }
+     return 0, fmt.Errorf("invalid status: %q", s)
+ }
+ 
+ func (s Status) IsValid() bool {
+     _, ok := statusNames[s]
+     return ok
+ }
+ 
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     v, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = v
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Compare that to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status { Pending, Active, Completed, Cancelled }
+ &#96;&#96;&#96;
+ 
+ Yeah.
+ 
+ ## The Honest Assessment
+ 
+ | Feature | C# Enum | Go "Enum" |
+ |---------|---------|-----------|
+ | Declaration | One line | Const block |
+ | Type safety | Strong | Weak (any int assignable) |
+ | String conversion | Built-in | Manual or generated |
+ | Parsing | Built-in | Manual |
+ | Exhaustive switch | Analyzers available | External linter |
+ | Flag support | &#96;[Flags]&#96; + &#96;HasFlag&#96; | Manual bit ops |
+ | JSON serialisation | Configurable | Manual implementation |
+ | Iteration over values | &#96;Enum.GetValues&#96; | Manual slice |
+ 
+ Go's approach is simpler in concept but more work in practice. For a type you use once, it's fine. For a type used throughout a codebase with JSON APIs, database columns, and validation requirements, you'll write a lot of boilerplate.
+ 
+ ## When to Reach for Alternatives
+ 
+ **String constants instead of int enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status string
+ 
+ const (
+     StatusPending   Status = "pending"
+     StatusActive    Status = "active"
+     StatusCompleted Status = "completed"
+     StatusCancelled Status = "cancelled"
+ )
+ &#96;&#96;&#96;
+ 
+ Pros: Natural JSON serialisation, readable in logs/databases.
+ Cons: More memory, slower comparison, still no exhaustive switch checking.
+ 
+ **Third-party enum packages:**
+ 
+ Libraries like &#96;go-enum&#96; generate all the boilerplate. Worth considering for large projects.
+ 
+ **Interface-based enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status interface {
+     status()  // unexported marker method
+     String() string
+ }
+ 
+ type statusPending struct{}
+ func (statusPending) status() {}
+ func (statusPending) String() string { return "Pending" }
+ 
+ var StatusPending Status = statusPending{}
+ &#96;&#96;&#96;
+ 
+ Type-safe (can't create arbitrary values), but verbose and unusual.
+ 
+ ## Practical Advice
+ 
+ 1. **Use &#96;stringer&#96; for any enum in production code.** The manual &#96;String()&#96; method will fall out of sync.
+ 
+ 2. **Start const values at 1 if zero means "unset."** Or use an explicit &#96;StatusUnknown = 0&#96; value.
+ 
+ 3. **Always add an &#96;IsValid()&#96; method.** Check it at system boundaries (API inputs, database reads).
+ 
+ 4. **Use string-based enums for external APIs.** They're more forgiving and self-documenting.
+ 
+ 5. **Accept the boilerplate.** Fighting it is pointless. Copy-paste or generate.
+ 
+ 6. **Use the &#96;exhaustive&#96; linter.** It's the only way to get switch statement coverage warnings.
+ 
+ Go's lack of proper enums is one of its genuine weaknesses. The workarounds work, but they're workarounds. Every Go developer I know has a personal template or snippet for "proper" enum implementation.
+ 
+ Maybe we'll get real enums eventually. Until then, embrace &#96;iota&#96; and keep your boilerplate consistent.
+ 
+ ---
+ 
+ *That wraps up Phase 2 on types and data. Next we'll move into Phase 3: Functions, Methods, and Interfaces—where Go's composition-over-inheritance philosophy really starts to show its strengths.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
All five posts are written. Let me verify the Hugo build passes with all of them.</details></think>

---

Let me verify the Hugo build passes with all the new posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
-rw-r--r--  1 andycross  staff  10096 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   8877 Dec 28 20:24 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8502 Dec 28 20:25 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8749 Dec 28 20:23 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9254 Dec 28 20:23 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All seven posts are now created and the build passes. Let me summarize what was created for the user.</details></think>

---

All five Phase 2 posts are created and the Hugo build passes. Here's the complete series so far:

## C# to Go Series

### Phase 1: Getting Oriented (2 posts)
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model, cross-compilation
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection, go.sum

### Phase 2: Types & Data (5 posts)
3. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, pointers, embedding vs inheritance, implicit interfaces
4. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields vs accessors, the `internal/` convention, struct tags
5. **"Generics: Late to the Party"** — What Go 1.18+ provides, constraints, what's missing (variance, generic methods, specialisation)
6. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap, zero values as defaults
7. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, what's missing (exhaustive switch, String()), stringer tool, workarounds

Each post follows the established tone:
- UK English throughout
- First person plural for learning together
- Fair comparisons (not bashing C# or overselling Go)
- Tables for genuine comparisons
- Runnable code examples
- Honest "what I miss" and "what I prefer" sections
- Practical advice sections

Ready for Phase 3 when you are?

---

_**User (2025-12-29 06:27Z)**_

We need to enhance one of the earlier posts, or inject a new one, which helps understand two key things

1) arrays are slices, dictionaries are maps ---- what are the key terminology changes that trip you up coming from c#
2) what are the new operators that you have to get ready for (:= for instance) 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to either enhance an existing post or create a new one that covers:
1. Terminology changes (arrays→slices, Dictionary→map, etc.)
2. New operators (:=, etc.)

Looking at the current series structure:
- Phase 1: Toolchain, Modules
- Phase 2: Structs, Visibility, Generics, Nil, Enums

This content feels like it should come early - it's foundational "getting oriented" material. It could either:
1. Be injected into the first post (toolchain)
2. Become a new post between Phase 1 and Phase 2

I think a new post makes more sense - this is substantial enough content to stand alone, and it's really about "the basics that trip you up" before you even get to types in depth. It could be titled something like "The Phrasebook: C# to Go Terminology and Syntax".

Let me create a new post that fits between the toolchain/modules posts and the types posts. This should cover:

Terminology:
- array → slice (and actual arrays exist but are rare)
- List<T> → slice
- Dictionary<K,V> → map
- namespace → package
- null → nil
- class → struct
- interface (explicit) → interface (implicit)
- property → field + methods
- var → var (but also :=)
- async/await → goroutines/channels
- event → channels
- LINQ → no equivalent (loops or generics)
- exception → error
- try/catch → if err != nil
- using → defer
- lock → sync.Mutex
- foreach → for range
- out/ref → pointers

Operators:
- := short variable declaration
- & address-of (like C#)
- * dereference (like C#)
- <- channel send/receive
- ... variadic and slice unpacking
- range keyword in for loops
- _ blank identifier
- := vs = 


- make() and new() are crucial memory allocation functions in Go

I'll explore make() and new() as key memory allocation mechanisms. make() is specifically for creating slices, maps, and channels, initializing their internal data structures. new() allocates memory for a type and returns a pointer, zeroing out the memory. These functions handle different memory initialization scenarios, providing precise control over how Go allocates and prepares memory for various data structures.</details></think>

---

Good call—this foundational "translation" content should come early in the series. I'll create a new post that slots in between the toolchain posts and the types posts. It's substantial enough to stand alone as a "phrasebook" reference.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-phrasebook.md</summary>

**Chunk 1**
Lines added: 424, lines removed: 1

```diff
@@ -1,1 +1,424 @@
- 
+ +++
+ title = "The Phrasebook: C# Concepts in Go Terms"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "syntax", "csharp"]
+ +++
+ 
+ Before we get into the weeds of types and patterns, let's establish some vocabulary. Go uses different names for familiar concepts, and has operators you've never seen. This post is a reference—skim it now, bookmark it for later.
+ 
+ ## The Terminology Swap
+ 
+ Your C# brain thinks in certain words. Here's the translation:
+ 
+ | C# Term | Go Term | Notes |
+ |---------|---------|-------|
+ | &#96;List&lt;T&gt;&#96; | slice | Dynamic array, the workhorse collection |
+ | &#96;T[]&#96; (array) | slice (usually) | Go has arrays, but you'll rarely use them |
+ | &#96;Dictionary&lt;K,V&gt;&#96; | map | &#96;map[string]int&#96; instead of &#96;Dictionary&lt;string, int&gt;&#96; |
+ | namespace | package | But packages are directories, not hierarchies |
+ | &#96;null&#96; | &#96;nil&#96; | Same concept, different spelling |
+ | class | struct | No inheritance, but methods work |
+ | property | field (+ methods) | No get/set syntax |
+ | &#96;var&#96; | &#96;var&#96; or &#96;:=&#96; | Two ways to declare variables |
+ | &#96;async&#96;/&#96;await&#96; | goroutines + channels | Completely different model |
+ | exception | error | Errors are values, not control flow |
+ | &#96;try&#96;/&#96;catch&#96; | &#96;if err != nil&#96; | Explicit checking, no unwinding |
+ | &#96;using&#96; | &#96;defer&#96; | Cleanup runs at function exit |
+ | &#96;lock&#96; | &#96;sync.Mutex&#96; | Manual lock/unlock |
+ | &#96;foreach&#96; | &#96;for range&#96; | Single construct for iteration |
+ | &#96;out&#96;/&#96;ref&#96; | pointers | Explicit &#96;*&#96; and &#96;&amp;&#96; |
+ | LINQ | nothing built-in | Loops, or generics since 1.18 |
+ | extension methods | nothing | Define functions, not methods |
+ | partial class | nothing | All code in the package shares scope |
+ | static class | package-level functions | No class, just functions |
+ 
+ ### Arrays vs Slices
+ 
+ This one catches everyone. In C#, "array" means a fixed-size, contiguous block:
+ 
+ &#96;&#96;&#96;csharp
+ int[] numbers = new int[5];  // fixed size 5
+ &#96;&#96;&#96;
+ 
+ In Go, this is also called an array—but you almost never use them directly:
+ 
+ &#96;&#96;&#96;go
+ var numbers [5]int  // array - fixed size, rarely used
+ &#96;&#96;&#96;
+ 
+ What you use instead is a **slice**—a dynamic view over an array:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}  // slice - this is what you want
+ numbers = append(numbers, 6)     // grows automatically
+ &#96;&#96;&#96;
+ 
+ Think of slices as &#96;List&lt;T&gt;&#96; that happens to have array-like syntax. They grow, shrink, and pass by reference (sort of—the header is copied, but the backing array is shared).
+ 
+ **The rule:** if you're reaching for an array in Go, you probably want a slice.
+ 
+ ### Maps
+ 
+ &#96;Dictionary&lt;K, V&gt;&#96; becomes &#96;map[K]V&#96;. The syntax is inside-out:
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ var scores = new Dictionary&lt;string, int&gt;
+ {
+     ["Alice"] = 100,
+     ["Bob"] = 85
+ };
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go
+ scores := map[string]int{
+     "Alice": 100,
+     "Bob":   85,
+ }
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - Maps must be initialised before use (nil maps panic on write)
+ - Missing keys return the zero value
+ - Use the two-value form to check existence: &#96;val, ok := m[key]&#96;
+ 
+ &#96;&#96;&#96;go
+ score, exists := scores["Charlie"]
+ if !exists {
+     fmt.Println("Charlie not found")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Operators You Haven't Met
+ 
+ Go has several operators and constructs that don't exist in C#. Here's your cheat sheet.
+ 
+ ### &#96;:=&#96; Short Variable Declaration
+ 
+ This is the one you'll use constantly:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ var name string = "Alice"
+ name := "Alice"  // type inferred, shorter
+ &#96;&#96;&#96;
+ 
+ The &#96;:=&#96; operator declares AND assigns. It only works inside functions, and only for new variables.
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ name := "Bob"    // ERROR: no new variables on left side
+ name = "Bob"     // OK: just assignment, no declaration
+ &#96;&#96;&#96;
+ 
+ **The gotcha:** &#96;:=&#96; in an inner scope creates a new variable that shadows the outer one:
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ if true {
+     name := "Bob"  // new variable, shadows outer 'name'
+     fmt.Println(name)  // "Bob"
+ }
+ fmt.Println(name)  // "Alice" - outer unchanged!
+ &#96;&#96;&#96;
+ 
+ This is a common source of bugs. Use &#96;=&#96; for assignment when the variable already exists.
+ 
+ ### &#96;_&#96; Blank Identifier
+ 
+ The underscore discards a value. You'll use it constantly because Go requires you to use all declared variables:
+ 
+ &#96;&#96;&#96;go
+ // Ignore the index in a range loop
+ for _, value := range items {
+     fmt.Println(value)
+ }
+ 
+ // Ignore an unwanted return value
+ _, err := doSomething()
+ 
+ // Ignore the second return value (existence check)
+ value, _ := myMap[key]  // don't care if it exists
+ 
+ // Interface compliance check (compile-time)
+ var _ io.Reader = (*MyType)(nil)
+ &#96;&#96;&#96;
+ 
+ ### &#96;&lt;-&#96; Channel Operator
+ 
+ Channels are Go's concurrency primitive. The &#96;&lt;-&#96; operator sends and receives:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ 
+ go func() {
+     ch &lt;- 42  // send 42 into the channel
+ }()
+ 
+ value := &lt;-ch  // receive from the channel
+ fmt.Println(value)  // 42
+ &#96;&#96;&#96;
+ 
+ The arrow points in the direction of data flow. Send: &#96;ch &lt;- value&#96;. Receive: &#96;value := &lt;-ch&#96;.
+ 
+ ### &#96;...&#96; Variadic and Spread
+ 
+ Two related uses for the ellipsis:
+ 
+ **Variadic parameters** (like C#'s &#96;params&#96;):
+ 
+ &#96;&#96;&#96;go
+ func Sum(numbers ...int) int {
+     total := 0
+     for _, n := range numbers {
+         total += n
+     }
+     return total
+ }
+ 
+ Sum(1, 2, 3)  // works
+ Sum(1, 2, 3, 4, 5)  // also works
+ &#96;&#96;&#96;
+ 
+ **Spreading a slice** into variadic arguments:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}
+ Sum(numbers...)  // unpacks the slice
+ &#96;&#96;&#96;
+ 
+ ### &#96;&amp;&#96; and &#96;*&#96; (Pointers)
+ 
+ These exist in C# but you probably haven't used them much. In Go, they're everywhere:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x   // p is *int, points to x
+ *p = 100  // dereference: x is now 100
+ &#96;&#96;&#96;
+ 
+ More commonly, you'll see them with structs:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ u := User{Name: "Alice"}
+ ptr := &amp;u           // *User
+ ptr.Name = "Bob"    // Go auto-dereferences for field access
+ &#96;&#96;&#96;
+ 
+ ### &#96;make()&#96; and &#96;new()&#96;
+ 
+ Two built-in functions for creating things:
+ 
+ **&#96;make()&#96;** is for slices, maps, and channels—types that need initialisation:
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 0, 10)     // slice with length 0, capacity 10
+ m := make(map[string]int)   // initialised map (not nil!)
+ ch := make(chan int)        // unbuffered channel
+ ch := make(chan int, 10)    // buffered channel, capacity 10
+ &#96;&#96;&#96;
+ 
+ **&#96;new()&#96;** allocates and returns a pointer to the zero value:
+ 
+ &#96;&#96;&#96;go
+ p := new(User)  // *User, pointing to User{}
+ &#96;&#96;&#96;
+ 
+ In practice, you'll use &#96;make()&#96; often and &#96;new()&#96; rarely. The composite literal with &#96;&amp;&#96; is more common:
+ 
+ &#96;&#96;&#96;go
+ p := &amp;User{Name: "Alice"}  // equivalent to new + field assignment
+ &#96;&#96;&#96;
+ 
+ ## The &#96;for&#96; Loop (It's the Only One)
+ 
+ Go has one loop construct: &#96;for&#96;. It does everything.
+ 
+ &#96;&#96;&#96;go
+ // Traditional for loop (like C#)
+ for i := 0; i &lt; 10; i++ {
+     fmt.Println(i)
+ }
+ 
+ // While loop (condition only)
+ for condition {
+     // ...
+ }
+ 
+ // Infinite loop
+ for {
+     // break to exit
+ }
+ 
+ // Range over slice (like foreach)
+ for index, value := range items {
+     fmt.Println(index, value)
+ }
+ 
+ // Range over map
+ for key, value := range myMap {
+     fmt.Println(key, value)
+ }
+ 
+ // Range over string (gives runes, not bytes)
+ for index, char := range "hello" {
+     fmt.Printf("%d: %c\n", index, char)
+ }
+ 
+ // Range over channel
+ for msg := range messages {
+     fmt.Println(msg)  // until channel is closed
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;_&#96; to ignore index or value:
+ 
+ &#96;&#96;&#96;go
+ for _, value := range items { }  // ignore index
+ for index := range items { }     // ignore value (just omit it)
+ &#96;&#96;&#96;
+ 
+ ## &#96;defer&#96; Instead of &#96;using&#96;
+ 
+ C#'s &#96;using&#96; statement disposes resources at block exit:
+ 
+ &#96;&#96;&#96;csharp
+ using var file = File.OpenRead("data.txt");
+ // file is disposed when scope exits
+ &#96;&#96;&#96;
+ 
+ Go's &#96;defer&#96; schedules a function call to run when the *function* exits:
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()  // runs when this function returns
+ 
+ // use file...
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - &#96;defer&#96; runs at function exit, not block exit
+ - Multiple defers run in LIFO order (last defer runs first)
+ - Deferred calls capture their arguments when the defer statement executes
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     defer fmt.Println("first")
+     defer fmt.Println("second")
+     defer fmt.Println("third")
+ }
+ // Output: third, second, first
+ &#96;&#96;&#96;
+ 
+ ## Error Handling: &#96;if err != nil&#96;
+ 
+ This is the biggest mental shift. No exceptions, no try/catch. Errors are values.
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return fmt.Errorf("failed to open: %w", err)
+ }
+ defer file.Close()
+ 
+ data, err := io.ReadAll(file)
+ if err != nil {
+     return fmt.Errorf("failed to read: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ You'll write &#96;if err != nil&#96; hundreds of times. It's verbose. It's explicit. It works.
+ 
+ The &#96;%w&#96; verb wraps errors, preserving the chain for later inspection with &#96;errors.Is()&#96; and &#96;errors.As()&#96;.
+ 
+ ## Multiple Return Values
+ 
+ Go functions can return multiple values. This is how errors are returned:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (float64, error) {
+     if b == 0 {
+         return 0, errors.New("division by zero")
+     }
+     return a / b, nil
+ }
+ 
+ result, err := Divide(10, 2)
+ if err != nil {
+     // handle error
+ }
+ &#96;&#96;&#96;
+ 
+ You can also use named return values:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (result float64, err error) {
+     if b == 0 {
+         err = errors.New("division by zero")
+         return  // returns named values
+     }
+     result = a / b
+     return
+ }
+ &#96;&#96;&#96;
+ 
+ Named returns are sometimes clearer, sometimes not. Use your judgement.
+ 
+ ## Type Assertions and Switches
+ 
+ When you have an &#96;interface{}&#96; (or &#96;any&#96;) and need the concrete type:
+ 
+ &#96;&#96;&#96;go
+ // Type assertion
+ value := something.(string)  // panics if not string
+ 
+ // Safe type assertion
+ value, ok := something.(string)
+ if !ok {
+     // not a string
+ }
+ 
+ // Type switch
+ switch v := something.(type) {
+ case string:
+     fmt.Println("string:", v)
+ case int:
+     fmt.Println("int:", v)
+ default:
+     fmt.Println("unknown type")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Quick Reference Card
+ 
+ Keep this handy until it's automatic:
+ 
+ | When you want to... | C# | Go |
+ |---------------------|-----|-----|
+ | Declare and assign | &#96;var x = 5;&#96; | &#96;x := 5&#96; |
+ | Declare without assign | &#96;int x;&#96; | &#96;var x int&#96; |
+ | Create a list | &#96;new List&lt;int&gt;()&#96; | &#96;[]int{}&#96; or &#96;make([]int, 0)&#96; |
+ | Create a dictionary | &#96;new Dictionary&lt;K,V&gt;()&#96; | &#96;make(map[K]V)&#96; |
+ | Append to list | &#96;list.Add(x)&#96; | &#96;slice = append(slice, x)&#96; |
+ | Get dictionary value | &#96;dict[key]&#96; | &#96;val := m[key]&#96; or &#96;val, ok := m[key]&#96; |
+ | Check key exists | &#96;dict.ContainsKey(k)&#96; | &#96;_, ok := m[k]&#96; |
+ | Iterate collection | &#96;foreach (var x in items)&#96; | &#96;for _, x := range items&#96; |
+ | Null check | &#96;if (x == null)&#96; | &#96;if x == nil&#96; |
+ | String format | &#96;$"Hello {name}"&#96; | &#96;fmt.Sprintf("Hello %s", name)&#96; |
+ | Error handling | &#96;try { } catch { }&#96; | &#96;if err != nil { }&#96; |
+ | Cleanup | &#96;using var x = ...&#96; | &#96;defer x.Close()&#96; |
+ | Async | &#96;await Task.Run(...)&#96; | &#96;go func() { }()&#96; |
+ 
+ ---
+ 
+ *This post is a reference, not a deep dive. We'll cover structs, visibility, and the type system properly in the next posts. But now you've got the vocabulary and the operators—the rest should make more sense.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, let me verify the build works.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
       8

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 8 posts now exist and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

Build passes. Here's the updated series structure with the new post slotted in:

## C# to Go Series (8 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection
3. **"The Phrasebook: C# Concepts in Go Terms"** ← **NEW** — Terminology swap (slice, map, nil), new operators (`:=`, `_`, `<-`, `...`), `for range`, `defer`, error handling basics, quick reference card

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields, struct tags
6. **"Generics: Late to the Party"** — What Go 1.18+ provides versus C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, stringer, workarounds

The Phrasebook post covers:
- **Terminology:** array→slice, Dictionary→map, null→nil, foreach→for range, using→defer, try/catch→if err != nil
- **New operators:** `:=` (short declaration), `_` (blank identifier), `<-` (channels), `...` (variadic/spread), `&`/`*` (pointers)
- **Built-ins:** `make()` vs `new()`, the single `for` loop, `defer` semantics
- **Quick reference card** at the end for bookmarking

The date is set to 2024-12-28 (same as the first two posts) so it'll sort appropriately. Ready for Phase 3 whenever you are!

---

_**User (2025-12-29 06:27Z)**_

ok the next phase now, phase 3 - Control Flow & Error Handling

if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create Phase 3: Control Flow & Error Handling with 3 posts:

1. if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
2. Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
3. The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

Let me write all three posts following the same tone and style.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-errors.md</summary>

**Chunk 1**
Lines added: 374, lines removed: 1

```diff
@@ -1,1 +1,374 @@
- 
+ +++
+ title = "if err != nil: Your New Reality"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ Let's address the elephant in the room. You're going to write &#96;if err != nil&#96; hundreds of times. Thousands, probably. And for the first week, you're going to hate it.
+ 
+ Coming from C#, where exceptions handle the sad path invisibly, Go's explicit error handling feels like a step backwards. It's verbose. It's repetitive. It clutters your code with what looks like boilerplate.
+ 
+ Then something shifts. You start to see what you're gaining. Let's work through that shift.
+ 
+ ## Why No Exceptions?
+ 
+ C# uses exceptions for error handling:
+ 
+ &#96;&#96;&#96;csharp
+ try
+ {
+     var data = await File.ReadAllTextAsync("config.json");
+     var config = JsonSerializer.Deserialize&lt;Config&gt;(data);
+     await database.Connect(config.ConnectionString);
+ }
+ catch (FileNotFoundException)
+ {
+     logger.Error("Config file missing");
+ }
+ catch (JsonException ex)
+ {
+     logger.Error($"Invalid config: {ex.Message}");
+ }
+ catch (Exception ex)
+ {
+     logger.Error($"Unexpected error: {ex.Message}");
+     throw;
+ }
+ &#96;&#96;&#96;
+ 
+ This looks clean. The happy path is uncluttered. Errors are handled elsewhere.
+ 
+ But there's a hidden cost: **you can't see which lines can fail**. Any line might throw. Any function you call might throw. The &#96;catch&#96; block is disconnected from the code that caused the problem.
+ 
+ Go takes the opposite view: **errors are values, returned like any other value**:
+ 
+ &#96;&#96;&#96;go
+ data, err := os.ReadFile("config.json")
+ if err != nil {
+     return fmt.Errorf("reading config: %w", err)
+ }
+ 
+ var config Config
+ if err := json.Unmarshal(data, &amp;config); err != nil {
+     return fmt.Errorf("parsing config: %w", err)
+ }
+ 
+ if err := database.Connect(config.ConnectionString); err != nil {
+     return fmt.Errorf("connecting to database: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ Verbose? Yes. But look at what you can see:
+ 
+ - Every line that can fail is marked with &#96;err :=&#96; or &#96;, err&#96;
+ - You know exactly what error each block handles
+ - The handling is right next to the call that produced the error
+ - No hidden control flow—the code does what it looks like it does
+ 
+ ## The Error Interface
+ 
+ In Go, &#96;error&#96; is just an interface:
+ 
+ &#96;&#96;&#96;go
+ type error interface {
+     Error() string
+ }
+ &#96;&#96;&#96;
+ 
+ Anything with an &#96;Error()&#96; method is an error. This is intentionally simple.
+ 
+ Creating errors:
+ 
+ &#96;&#96;&#96;go
+ import "errors"
+ 
+ // Simple error
+ err := errors.New("something went wrong")
+ 
+ // Formatted error
+ err := fmt.Errorf("failed to load user %d: %w", userID, originalErr)
+ &#96;&#96;&#96;
+ 
+ That &#96;%w&#96; verb is important—it wraps the original error, preserving the chain.
+ 
+ ## The Pattern You'll Write Forever
+ 
+ Here's the basic pattern:
+ 
+ &#96;&#96;&#96;go
+ result, err := doSomething()
+ if err != nil {
+     return fmt.Errorf("doing something: %w", err)
+ }
+ // use result
+ &#96;&#96;&#96;
+ 
+ Variations:
+ 
+ &#96;&#96;&#96;go
+ // When there's no result to use
+ if err := doSomething(); err != nil {
+     return err
+ }
+ 
+ // When you want to handle specific errors
+ if err := doSomething(); err != nil {
+     if errors.Is(err, ErrNotFound) {
+         return defaultValue, nil  // handle gracefully
+     }
+     return zero, err  // propagate others
+ }
+ 
+ // When you need to clean up on error
+ file, err := os.Create("output.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()
+ 
+ if err := writeData(file); err != nil {
+     os.Remove("output.txt")  // clean up partial file
+     return fmt.Errorf("writing data: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Wrapping Errors Properly
+ 
+ Go 1.13 introduced error wrapping. Use it:
+ 
+ &#96;&#96;&#96;go
+ // BAD: loses the original error
+ if err != nil {
+     return errors.New("failed to connect")
+ }
+ 
+ // BAD: concatenates as string, loses error chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %s", err)
+ }
+ 
+ // GOOD: wraps the error, preserves the chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;%w&#96; verb creates a chain that can be inspected:
+ 
+ &#96;&#96;&#96;go
+ if errors.Is(err, sql.ErrNoRows) {
+     // somewhere in the chain, there's a sql.ErrNoRows
+ }
+ 
+ var pathErr *os.PathError
+ if errors.As(err, &amp;pathErr) {
+     // somewhere in the chain, there's a *os.PathError
+     fmt.Println(pathErr.Path)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Sentinel Errors
+ 
+ For errors that callers need to check, define package-level sentinel errors:
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ var (
+     ErrNotFound     = errors.New("user not found")
+     ErrInvalidEmail = errors.New("invalid email address")
+     ErrDuplicate    = errors.New("user already exists")
+ )
+ 
+ func Find(id string) (*User, error) {
+     // ...
+     if notFound {
+         return nil, ErrNotFound
+     }
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can check:
+ 
+ &#96;&#96;&#96;go
+ user, err := user.Find("123")
+ if errors.Is(err, user.ErrNotFound) {
+     // handle not found specifically
+ }
+ &#96;&#96;&#96;
+ 
+ ## Custom Error Types
+ 
+ When you need more context, create a custom error type:
+ 
+ &#96;&#96;&#96;go
+ type ValidationError struct {
+     Field   string
+     Message string
+ }
+ 
+ func (e *ValidationError) Error() string {
+     return fmt.Sprintf("%s: %s", e.Field, e.Message)
+ }
+ 
+ func ValidateUser(u *User) error {
+     if u.Email == "" {
+         return &amp;ValidationError{Field: "email", Message: "required"}
+     }
+     if !strings.Contains(u.Email, "@") {
+         return &amp;ValidationError{Field: "email", Message: "invalid format"}
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can extract details:
+ 
+ &#96;&#96;&#96;go
+ if err := ValidateUser(u); err != nil {
+     var valErr *ValidationError
+     if errors.As(err, &amp;valErr) {
+         fmt.Printf("Validation failed on %s: %s\n", valErr.Field, valErr.Message)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## Strategies That Help
+ 
+ ### Early Returns
+ 
+ Embrace early returns. Don't nest error handling:
+ 
+ &#96;&#96;&#96;go
+ // BAD: nested, hard to follow
+ func process() error {
+     data, err := loadData()
+     if err == nil {
+         parsed, err := parseData(data)
+         if err == nil {
+             result, err := transform(parsed)
+             if err == nil {
+                 return save(result)
+             } else {
+                 return err
+             }
+         } else {
+             return err
+         }
+     } else {
+         return err
+     }
+ }
+ 
+ // GOOD: flat, obvious
+ func process() error {
+     data, err := loadData()
+     if err != nil {
+         return fmt.Errorf("loading: %w", err)
+     }
+     
+     parsed, err := parseData(data)
+     if err != nil {
+         return fmt.Errorf("parsing: %w", err)
+     }
+     
+     result, err := transform(parsed)
+     if err != nil {
+         return fmt.Errorf("transforming: %w", err)
+     }
+     
+     return save(result)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Naming Consistency
+ 
+ Keep error variable names consistent within a function:
+ 
+ &#96;&#96;&#96;go
+ // Use 'err' for the standard error variable
+ data, err := load()
+ if err != nil { ... }
+ 
+ result, err := process(data)  // reuse 'err'
+ if err != nil { ... }
+ 
+ // Use descriptive names when you have multiple errors in scope
+ loadErr := load()
+ processErr := process()
+ if loadErr != nil || processErr != nil { ... }
+ &#96;&#96;&#96;
+ 
+ ### The "Must" Pattern
+ 
+ For initialisation code where errors are truly unrecoverable:
+ 
+ &#96;&#96;&#96;go
+ var templates = template.Must(template.ParseGlob("templates/*.html"))
+ var config = MustLoadConfig("config.yaml")
+ 
+ func MustLoadConfig(path string) Config {
+     cfg, err := LoadConfig(path)
+     if err != nil {
+         panic(fmt.Sprintf("loading config: %v", err))
+     }
+     return cfg
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;Must&#96; functions sparingly—only for program setup where failure means "can't start."
+ 
+ ## What You're Actually Getting
+ 
+ After the initial frustration wears off, here's what explicit errors give you:
+ 
+ **Visible failure points.** Every line that can fail is marked. No surprises.
+ 
+ **Local reasoning.** You handle errors where they occur. No tracing back through call stacks.
+ 
+ **No performance penalty.** Error returns are just values—no stack unwinding, no runtime cost.
+ 
+ **Forced consideration.** You can't ignore errors accidentally. (Well, you can with &#96;_&#96;, but it's deliberate.)
+ 
+ **Simpler debugging.** When something fails, the error message tells you exactly what happened at each level.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Exceptions | Go Errors |
+ |--------|--------------|-----------|
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;throw&#96; | &#96;if err != nil&#96; |
+ | Control flow | Non-local jump | Normal return |
+ | Performance | Cost on throw | No overhead |
+ | Visibility | Hidden failure points | Explicit everywhere |
+ | Ignoring errors | Silent (dangerous) | Requires explicit &#96;_&#96; |
+ | Stack traces | Automatic | Manual (or wrap carefully) |
+ | Recovery | &#96;catch&#96; blocks | Caller decides |
+ 
+ ## The Honest Take
+ 
+ **Things I like better than C#:**
+ 
+ - You can see which calls can fail
+ - Error handling is local and explicit
+ - No surprise exceptions from deep in the stack
+ - Errors are values—you can store, compare, wrap them
+ 
+ **Things I miss from C#:**
+ 
+ - The happy path being uncluttered
+ - Automatic stack traces
+ - &#96;finally&#96; blocks (defer is close but not identical)
+ - Not writing the same three lines a thousand times
+ 
+ **The verdict:**
+ 
+ Go's approach is more verbose but more honest. Once you accept that error handling is part of your code—not something that happens off to the side—the verbosity starts to feel appropriate.
+ 
+ You're not writing boilerplate. You're writing error handling. It just happens to look the same every time because handling errors correctly *is* repetitive.
+ 
+ ---
+ 
+ *Next up: panic and recover—Go's actual exception mechanism, why it exists, and why using it for normal errors will get you judged.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-panic.md</summary>

**Chunk 1**
Lines added: 316, lines removed: 1

```diff
@@ -1,1 +1,316 @@
- 
+ +++
+ title = "Panic and Recover: The Emergency Exit"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ So Go doesn't have exceptions. Except... it kind of does. They're called &#96;panic&#96; and &#96;recover&#96;, and they work almost exactly like throw and catch.
+ 
+ Here's the thing: if you use them like exceptions, other Go developers will judge you. Harshly. Let's understand why they exist, when to use them, and why the judgment is (mostly) deserved.
+ 
+ ## What Panic Does
+ 
+ &#96;panic&#96; stops normal execution and begins unwinding the stack:
+ 
+ &#96;&#96;&#96;go
+ func divide(a, b int) int {
+     if b == 0 {
+         panic("division by zero")
+     }
+     return a / b
+ }
+ 
+ func main() {
+     result := divide(10, 0)  // panics here
+     fmt.Println(result)      // never reached
+ }
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ panic: division by zero
+ 
+ goroutine 1 [running]:
+ main.divide(...)
+         /app/main.go:7
+ main.main()
+         /app/main.go:12
+ exit status 2
+ &#96;&#96;&#96;
+ 
+ Sound familiar? It's an unhandled exception with a stack trace.
+ 
+ Deferred functions still run during a panic:
+ 
+ &#96;&#96;&#96;go
+ func riskyOperation() {
+     defer fmt.Println("cleanup runs")  // this executes
+     panic("oh no")
+     fmt.Println("never reached")
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Recover Does
+ 
+ &#96;recover&#96; catches a panic. It only works inside a deferred function:
+ 
+ &#96;&#96;&#96;go
+ func safeOperation() (err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             err = fmt.Errorf("recovered from panic: %v", r)
+         }
+     }()
+     
+     riskyOperation()  // might panic
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ If &#96;riskyOperation&#96; panics, &#96;recover()&#96; catches it and we convert it to an error. The function returns normally instead of crashing.
+ 
+ This is literally try/catch:
+ 
+ &#96;&#96;&#96;csharp
+ // C# equivalent
+ try
+ {
+     RiskyOperation();
+ }
+ catch (Exception ex)
+ {
+     return new Error($"recovered from exception: {ex.Message}");
+ }
+ &#96;&#96;&#96;
+ 
+ ## Why Go Developers Judge You
+ 
+ So if panic/recover is just exceptions by another name, why not use them that way?
+ 
+ Because Go's error philosophy is that **errors are expected, panics are not**.
+ 
+ - Errors are things that can reasonably happen: file not found, network timeout, invalid input
+ - Panics are things that *shouldn't* happen: nil pointer dereference, index out of bounds, programmer bugs
+ 
+ When you use panic for normal errors, you're saying "this should never happen" when what you mean is "I didn't want to write &#96;if err != nil&#96;."
+ 
+ The community has strong opinions about this:
+ 
+ &#96;&#96;&#96;go
+ // This will get you judged
+ func ParseConfig(path string) Config {
+     data, err := os.ReadFile(path)
+     if err != nil {
+         panic(err)  // NO - missing file is a normal error
+     }
+     // ...
+ }
+ 
+ // This is fine
+ func MustParseConfig(path string) Config {
+     // "Must" in the name signals this panics
+     // Only use at startup where failure = can't run
+ }
+ &#96;&#96;&#96;
+ 
+ ## When Panic Is Appropriate
+ 
+ Despite the judgment, there are legitimate uses:
+ 
+ ### 1. Truly Unrecoverable Programmer Errors
+ 
+ &#96;&#96;&#96;go
+ func processItem(item *Item) {
+     if item == nil {
+         panic("processItem called with nil item")
+     }
+     // This is a programming error - the caller screwed up
+     // Not a runtime condition we should handle gracefully
+ }
+ &#96;&#96;&#96;
+ 
+ ### 2. Initialisation Failures
+ 
+ &#96;&#96;&#96;go
+ var db = mustConnect()
+ 
+ func mustConnect() *sql.DB {
+     db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
+     if err != nil {
+         panic(fmt.Sprintf("database connection failed: %v", err))
+     }
+     return db
+ }
+ &#96;&#96;&#96;
+ 
+ If the program can't start without a database, panicking at init is reasonable. There's nothing useful to do with the error.
+ 
+ ### 3. The "Must" Convention
+ 
+ Standard library examples:
+ 
+ &#96;&#96;&#96;go
+ // template.Must panics if parsing fails
+ var templates = template.Must(template.ParseGlob("*.html"))
+ 
+ // regexp.MustCompile panics if pattern is invalid
+ var emailRegex = regexp.MustCompile(&#96;^[a-z]+@[a-z]+\.[a-z]+$&#96;)
+ &#96;&#96;&#96;
+ 
+ The &#96;Must&#96; prefix tells callers "this panics on error—only use with compile-time constant inputs."
+ 
+ ### 4. Deep Recursion Bailout
+ 
+ Sometimes you're deep in recursion and unwinding through error returns is painful:
+ 
+ &#96;&#96;&#96;go
+ func parse(tokens []Token) (result AST, err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             if parseErr, ok := r.(parseError); ok {
+                 err = parseErr
+             } else {
+                 panic(r)  // re-panic if it's not our error
+             }
+         }
+     }()
+     
+     return parseExpression(tokens), nil
+ }
+ 
+ func parseExpression(tokens []Token) AST {
+     // Deep recursive descent
+     // ...
+     if somethingWrong {
+         panic(parseError{msg: "unexpected token", pos: pos})
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This is controversial but accepted in parsers and similar deep-recursion scenarios. Note that the panic is recovered at the boundary and converted to an error.
+ 
+ ## The Boundary Pattern
+ 
+ The key pattern: **never let panics escape your package**.
+ 
+ If your code might panic (or call code that might panic), recover at the boundary:
+ 
+ &#96;&#96;&#96;go
+ // Public API - never panics
+ func (s *Service) ProcessRequest(req Request) (Response, error) {
+     defer func() {
+         if r := recover(); r != nil {
+             // Log, maybe alert
+             log.Printf("panic in ProcessRequest: %v", r)
+         }
+     }()
+     
+     return s.doProcess(req)  // internal, might panic
+ }
+ &#96;&#96;&#96;
+ 
+ HTTP handlers often do this:
+ 
+ &#96;&#96;&#96;go
+ func recoveryMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         defer func() {
+             if err := recover(); err != nil {
+                 log.Printf("panic: %v\n%s", err, debug.Stack())
+                 http.Error(w, "Internal Server Error", 500)
+             }
+         }()
+         next.ServeHTTP(w, r)
+     })
+ }
+ &#96;&#96;&#96;
+ 
+ A panic in a handler becomes a 500 response, not a crashed server.
+ 
+ ## Panic Values
+ 
+ Unlike C# where you throw &#96;Exception&#96; objects, you can panic with any value:
+ 
+ &#96;&#96;&#96;go
+ panic("a string")
+ panic(42)
+ panic(errors.New("an error"))
+ panic(MyCustomType{})
+ &#96;&#96;&#96;
+ 
+ When recovering, you get an &#96;interface{}&#96;:
+ 
+ &#96;&#96;&#96;go
+ if r := recover(); r != nil {
+     switch v := r.(type) {
+     case error:
+         log.Printf("error: %v", v)
+     case string:
+         log.Printf("string: %s", v)
+     default:
+         log.Printf("unknown: %v", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Best practice: panic with &#96;error&#96; values or strings. Makes recovery predictable.
+ 
+ ## Comparison with C#
+ 
+ | Aspect | C# Exceptions | Go Panic/Recover |
+ |--------|---------------|------------------|
+ | Normal errors | Often used | Strongly discouraged |
+ | Programmer bugs | Appropriate | Appropriate |
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;finally&#96; | &#96;defer&#96;/&#96;recover&#96; |
+ | Stack traces | Automatic | Available via &#96;debug.Stack()&#96; |
+ | Filtering | Catch by type | Check recovered value |
+ | Re-throwing | &#96;throw;&#96; | &#96;panic(r)&#96; |
+ | Custom types | Exception subclasses | Any type (usually error) |
+ | Cultural norm | Expected | Emergency only |
+ 
+ ## The Test Exception
+ 
+ One place where panic is universally accepted: tests.
+ 
+ &#96;&#96;&#96;go
+ func TestSomething(t *testing.T) {
+     result := process(input)
+     
+     if result != expected {
+         t.Fatalf("got %v, want %v", result, expected)  // this panics
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;t.Fatal&#96; and &#96;t.Fatalf&#96; panic to abort the test. This is fine—tests are the one place where "stop everything" is the right response to failure.
+ 
+ ## The Honest Take
+ 
+ **When I use panic:**
+ - &#96;Must&#96; functions for startup initialisation
+ - Genuinely impossible conditions (defensive programming)
+ - Test assertions via &#96;t.Fatal&#96;
+ 
+ **When I don't use panic:**
+ - File not found
+ - Network errors
+ - Invalid user input
+ - Anything that can reasonably happen at runtime
+ 
+ **The rule I follow:**
+ If I'm tempted to panic, I ask: "Is this a bug in my program, or is this something that could happen in production?" Bugs can panic. Production conditions should return errors.
+ 
+ ## What About Performance?
+ 
+ One argument for panic: "it's faster because you don't have to check errors at every level."
+ 
+ This is technically true but practically irrelevant. Error checking is a comparison and conditional jump. The performance difference is unmeasurable in real code.
+ 
+ Don't let performance justify panic. If you're that performance-sensitive, you're probably not writing Go anyway.
+ 
+ ---
+ 
+ *Coming up: Go's switch statement—more powerful than C#'s, with type switching, expression cases, and some surprises around fallthrough.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-switch.md</summary>

**Chunk 1**
Lines added: 432, lines removed: 1

```diff
@@ -1,1 +1,432 @@
- 
+ +++
+ title = "The switch Statement You Always Wanted"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "control-flow", "csharp"]
+ +++
+ 
+ C#'s switch statement has evolved a lot over the years. Pattern matching, switch expressions, when guards—it's become genuinely powerful. But Go's switch has some tricks that'll make you wish C# worked this way.
+ 
+ Let's look at what Go's switch can do, including the bits that'll trip you up.
+ 
+ ## Basic Switch: No Fallthrough by Default
+ 
+ First surprise: Go switches don't fall through by default.
+ 
+ &#96;&#96;&#96;csharp
+ // C# - falls through if you forget break (historically)
+ switch (day)
+ {
+     case "Monday":
+         Console.WriteLine("Start of week");
+         break;  // required!
+     case "Friday":
+         Console.WriteLine("End of week");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go - no break needed, no fallthrough
+ switch day {
+ case "Monday":
+     fmt.Println("Start of week")
+     // automatically breaks here
+ case "Friday":
+     fmt.Println("End of week")
+ }
+ &#96;&#96;&#96;
+ 
+ This is a genuine improvement. The C# pattern of requiring &#96;break&#96; after every case was a source of bugs for decades. Go's default—exit after each case—matches what you almost always want.
+ 
+ ## Multiple Values Per Case
+ 
+ Want the same code for multiple cases? In C#:
+ 
+ &#96;&#96;&#96;csharp
+ switch (day)
+ {
+     case "Saturday":
+     case "Sunday":
+         Console.WriteLine("Weekend");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Cleaner. Multiple values in one case clause, comma-separated.
+ 
+ ## No Expression Required
+ 
+ Here's something C# can't do. Go's switch doesn't need an expression:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case hour &lt; 12:
+     fmt.Println("Good morning")
+ case hour &lt; 17:
+     fmt.Println("Good afternoon")
+ default:
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ This is equivalent to an if-else chain but often more readable:
+ 
+ &#96;&#96;&#96;go
+ // Equivalent, but more verbose
+ if hour &lt; 12 {
+     fmt.Println("Good morning")
+ } else if hour &lt; 17 {
+     fmt.Println("Good afternoon")
+ } else {
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ I use expressionless switch constantly. It's particularly good for range checks and complex conditions.
+ 
+ ## Fallthrough (When You Actually Want It)
+ 
+ Sometimes you genuinely need fallthrough. Go has a &#96;fallthrough&#96; keyword:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Thursday":
+     fmt.Println("Almost Friday")
+     fallthrough
+ case "Friday":
+     fmt.Println("Weekend soon!")
+ }
+ 
+ // Thursday prints both lines
+ // Friday prints just "Weekend soon!"
+ &#96;&#96;&#96;
+ 
+ Important: &#96;fallthrough&#96; must be the last statement in a case, and it falls into the next case unconditionally—it doesn't re-evaluate the case expression.
+ 
+ &#96;&#96;&#96;go
+ // This is usually wrong
+ switch x {
+ case 1:
+     fallthrough  // falls into case 2 even if x != 2
+ case 2:
+     doSomething()
+ }
+ &#96;&#96;&#96;
+ 
+ In practice, I rarely use &#96;fallthrough&#96;. Multiple values per case covers most needs.
+ 
+ ## Type Switches
+ 
+ This is where Go's switch shines. You can switch on type:
+ 
+ &#96;&#96;&#96;go
+ func describe(i interface{}) {
+     switch v := i.(type) {
+     case int:
+         fmt.Printf("Integer: %d\n", v)
+     case string:
+         fmt.Printf("String: %s\n", v)
+     case bool:
+         fmt.Printf("Boolean: %t\n", v)
+     case []int:
+         fmt.Printf("Slice of ints: %v\n", v)
+     default:
+         fmt.Printf("Unknown type: %T\n", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;v := i.(type)&#96; syntax extracts both the type (for the case matching) and the value (as the correctly typed &#96;v&#96;).
+ 
+ C# has pattern matching now which does something similar:
+ 
+ &#96;&#96;&#96;csharp
+ static void Describe(object o)
+ {
+     switch (o)
+     {
+         case int i:
+             Console.WriteLine($"Integer: {i}");
+             break;
+         case string s:
+             Console.WriteLine($"String: {s}");
+             break;
+         // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Go got there first, and the syntax is arguable cleaner.
+ 
+ ### Multiple Types Per Case
+ 
+ &#96;&#96;&#96;go
+ switch v := i.(type) {
+ case int, int32, int64:
+     fmt.Println("Some kind of integer")
+     // Note: v is interface{} here, not a specific int type
+ case string, []byte:
+     fmt.Println("String-like")
+ default:
+     fmt.Printf("Type: %T\n", v)
+ }
+ &#96;&#96;&#96;
+ 
+ When you match multiple types, &#96;v&#96; has type &#96;interface{}&#96; because the compiler can't know which type matched.
+ 
+ ## Initialisation Statements
+ 
+ Like &#96;if&#96;, you can have an initialisation statement:
+ 
+ &#96;&#96;&#96;go
+ switch os := runtime.GOOS; os {
+ case "darwin":
+     fmt.Println("macOS")
+ case "linux":
+     fmt.Println("Linux")
+ default:
+     fmt.Printf("Other: %s\n", os)
+ }
+ // os is not visible here
+ &#96;&#96;&#96;
+ 
+ Keeps the variable scoped to where it's used.
+ 
+ ## Comparing to C#'s Switch Expressions
+ 
+ C# 8 added switch expressions, which are excellent:
+ 
+ &#96;&#96;&#96;csharp
+ var message = day switch
+ {
+     "Monday" =&gt; "Start of week",
+     "Friday" =&gt; "End of week",
+     "Saturday" or "Sunday" =&gt; "Weekend",
+     _ =&gt; "Midweek"
+ };
+ &#96;&#96;&#96;
+ 
+ Go doesn't have switch expressions—switch is always a statement, not an expression. You can't do:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work in Go
+ message := switch day {
+ case "Monday":
+     "Start of week"
+ // ...
+ }
+ &#96;&#96;&#96;
+ 
+ You have to use a variable:
+ 
+ &#96;&#96;&#96;go
+ var message string
+ switch day {
+ case "Monday":
+     message = "Start of week"
+ case "Friday":
+     message = "End of week"
+ case "Saturday", "Sunday":
+     message = "Weekend"
+ default:
+     message = "Midweek"
+ }
+ &#96;&#96;&#96;
+ 
+ This is one area where C# is genuinely more elegant.
+ 
+ ## When Guards (Sort Of)
+ 
+ C# has &#96;when&#96; guards in pattern matching:
+ 
+ &#96;&#96;&#96;csharp
+ switch (response)
+ {
+     case HttpResponse { StatusCode: var code } when code &gt;= 400:
+         HandleError(code);
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ Go doesn't have &#96;when&#96;, but expressionless switch achieves similar things:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case response.StatusCode &gt;= 500:
+     handleServerError(response)
+ case response.StatusCode &gt;= 400:
+     handleClientError(response)
+ case response.StatusCode &gt;= 200:
+     handleSuccess(response)
+ }
+ &#96;&#96;&#96;
+ 
+ Not quite as powerful as full pattern matching, but covers most cases.
+ 
+ ## The Default Case
+ 
+ Go's &#96;default&#96; case can appear anywhere (not just at the end):
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ default:
+     fmt.Println("Weekday")
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Convention says put it last, but Go doesn't enforce it.
+ 
+ ## Switching on Errors
+ 
+ A common pattern for error handling:
+ 
+ &#96;&#96;&#96;go
+ err := doSomething()
+ switch {
+ case err == nil:
+     // success
+ case errors.Is(err, ErrNotFound):
+     // handle not found
+ case errors.Is(err, ErrPermissionDenied):
+     // handle permission error
+ default:
+     // unknown error
+     return err
+ }
+ &#96;&#96;&#96;
+ 
+ Sometimes cleaner than a chain of if-else-if.
+ 
+ ## The Comparison
+ 
+ | Feature | C# | Go |
+ |---------|-----|-----|
+ | Break required | No (modern) | No |
+ | Fallthrough | By omitting break (legacy) | &#96;fallthrough&#96; keyword |
+ | Multiple values | &#96;case a, b:&#96; (older) or &#96;case a or b:&#96; | &#96;case a, b:&#96; |
+ | Expression switch | Yes (switch expression) | No (statement only) |
+ | Type switching | Pattern matching | &#96;switch v := x.(type)&#96; |
+ | No expression | No | Yes (&#96;switch { case cond: }&#96;) |
+ | When guards | Yes | No (use expressionless switch) |
+ | Init statement | No | Yes |
+ 
+ ## Practical Patterns
+ 
+ ### State Machine
+ 
+ &#96;&#96;&#96;go
+ type State int
+ 
+ const (
+     StateIdle State = iota
+     StateRunning
+     StatePaused
+     StateStopped
+ )
+ 
+ func (s *Machine) handleEvent(event Event) {
+     switch s.state {
+     case StateIdle:
+         switch event {
+         case EventStart:
+             s.state = StateRunning
+         default:
+             // ignore
+         }
+     case StateRunning:
+         switch event {
+         case EventPause:
+             s.state = StatePaused
+         case EventStop:
+             s.state = StateStopped
+         }
+     // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Command Dispatch
+ 
+ &#96;&#96;&#96;go
+ func handleCommand(cmd string, args []string) error {
+     switch cmd {
+     case "list":
+         return listItems()
+     case "add":
+         if len(args) &lt; 1 {
+             return errors.New("add requires an item name")
+         }
+         return addItem(args[0])
+     case "remove":
+         if len(args) &lt; 1 {
+             return errors.New("remove requires an item name")
+         }
+         return removeItem(args[0])
+     default:
+         return fmt.Errorf("unknown command: %s", cmd)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parsing JSON with Type Switch
+ 
+ &#96;&#96;&#96;go
+ func processValue(v interface{}) {
+     switch val := v.(type) {
+     case map[string]interface{}:
+         for k, v := range val {
+             fmt.Printf("Object key: %s\n", k)
+             processValue(v)  // recurse
+         }
+     case []interface{}:
+         for i, item := range val {
+             fmt.Printf("Array index: %d\n", i)
+             processValue(item)  // recurse
+         }
+     case string:
+         fmt.Printf("String: %s\n", val)
+     case float64:  // JSON numbers are float64
+         fmt.Printf("Number: %f\n", val)
+     case bool:
+         fmt.Printf("Boolean: %t\n", val)
+     case nil:
+         fmt.Println("Null")
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's switch is one of the language's better features:
+ 
+ **Things I like:**
+ - No fallthrough by default (prevents bugs)
+ - Expressionless switch for complex conditions
+ - Type switches for working with interfaces
+ - Multiple values per case
+ - Init statements for scoping
+ 
+ **Things C# does better:**
+ - Switch expressions (returning values directly)
+ - Pattern matching with &#96;when&#96; guards
+ - Recursive patterns (&#96;case Person { Age: &gt; 18 }&#96;)
+ 
+ **The verdict:**
+ Go's switch is simpler and covers the common cases elegantly. C#'s switch has more features for complex matching. Use what each language gives you.
+ 
+ ---
+ 
+ *That wraps up Phase 3 on control flow and error handling. Next we'll move into concurrency—goroutines, channels, and why Go's approach to parallelism is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the Hugo build passes with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      11
---
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 11 posts are now created and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Phase 3 posts are done. Here's the complete series (11 posts now):

## C# to Go Series

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet
3. **"The Phrasebook: C# Concepts in Go Terms"** — Terminology swap, operators, quick reference

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields
6. **"Generics: Late to the Party"** — Go 1.18+ vs C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, workarounds

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"** — Why no exceptions, error wrapping, sentinel errors, custom error types, strategies for living with explicit errors
10. **"Panic and Recover: The Emergency Exit"** — When panic is acceptable (`Must` pattern, init, programmer bugs), the boundary pattern, why you'll get judged for using it like exceptions
11. **"The switch Statement You Always Wanted"** — No fallthrough by default, expressionless switch, type switches, comparing to C#'s pattern matching

The Phase 3 posts cover:
- The philosophical shift from exceptions to explicit error values
- `errors.Is()` and `errors.As()` for error inspection
- The `%w` verb for error wrapping
- Panic/recover mechanics and when they're appropriate
- Go's switch being genuinely better in some ways (no break needed, type switches, expressionless form)
- Where C# is still ahead (switch expressions, pattern matching with when guards)

Ready for Phase 4 (concurrency?) whenever you are!

---

_**User (2025-12-29 10:33Z)**_

The next three posts are below, let's go write them! Add a little more snark to these ones, not over the top but be a little cynical because this section is where dotnet is reallllly good



Memory & Pointers

Pointers Without the Pain — What C# hides that Go makes explicit, and why it's less scary than C++
Stack vs Heap: Go's Escape Analysis — You know ref and Span<T>, now meet Go's approach to allocation
Slices Are Not Arrays (And Neither Is List<T>) — Capacity, length, backing arrays, and the gotchas that will bite you

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants three more posts for Phase 4: Memory & Pointers, and they want me to add a bit more snark/cynicism because this is an area where .NET is really strong. So I should be fair but acknowledge that .NET's memory management and abstractions are genuinely excellent, and Go's explicit approach has trade-offs.

Let me write these with a bit more edge - acknowledging that C#/.NET handles a lot of this better in many ways, but explaining what Go does and why.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md</summary>

**Chunk 1**
Lines added: 258, lines removed: 1

```diff
@@ -1,1 +1,258 @@
- 
+ +++
+ title = "Pointers Without the Pain"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "pointers", "csharp"]
+ +++
+ 
+ Right, let's talk about pointers. If you've spent your career in C#, you've probably used pointers approximately never. Maybe you've seen &#96;unsafe&#96; blocks in performance-critical library code. Maybe you've used &#96;ref&#96; and &#96;Span&lt;T&gt;&#96; and felt rather clever about it.
+ 
+ In Go, pointers are everywhere. Every method receiver decision involves them. Every struct-passing decision involves them. You can't hide from them.
+ 
+ The good news: Go's pointers are considerably less terrifying than C's. The bad news: you actually have to think about them now.
+ 
+ ## What C# Hides
+ 
+ C# makes a neat distinction: value types live on the stack (mostly), reference types live on the heap (mostly), and the runtime figures out the details. You don't think about addresses. You don't think about dereferencing. You just use stuff.
+ 
+ &#96;&#96;&#96;csharp
+ var user = new User { Name = "Alice" };  // heap, reference semantics
+ var point = new Point(10, 20);           // stack (probably), value semantics
+ 
+ ProcessUser(user);   // passes reference
+ ProcessPoint(point); // passes copy
+ &#96;&#96;&#96;
+ 
+ The runtime decides where things actually live. The JIT optimises. Escape analysis happens. You don't care.
+ 
+ Go is more... honest? Explicit? Annoying? All three, depending on your mood.
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice"}   // where does this live? Depends!
+ ptr := &amp;User{Name: "Bob"}     // definitely a pointer
+ 
+ ProcessUser(user)   // passes copy
+ ProcessUser(&amp;user)  // passes pointer
+ ProcessUserPtr(ptr) // passes pointer
+ &#96;&#96;&#96;
+ 
+ You have to think about it. Every time.
+ 
+ ## Go Pointer Basics
+ 
+ The syntax is C-style:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x    // p is *int, pointing to x
+ fmt.Println(*p)  // 42 - dereference to get value
+ *p = 100   // x is now 100
+ &#96;&#96;&#96;
+ 
+ Creating pointers to composite literals:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ user := &amp;User{Name: "Alice"}
+ 
+ // vs
+ user := new(User)
+ user.Name = "Alice"
+ 
+ // vs
+ var user User
+ user.Name = "Alice"
+ userPtr := &amp;user
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;&#96; operator gives you a pointer. The &#96;*&#96; operator dereferences. If you've touched C or C++ at any point, this is familiar.
+ 
+ ## The Nice Bit: Automatic Dereferencing
+ 
+ Unlike C, Go automatically dereferences pointers for field and method access:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ func (u *User) SetName(name string) {
+     u.Name = name  // not (*u).Name, just u.Name
+ }
+ 
+ user := &amp;User{}
+ user.Name = "Alice"  // works, auto-dereferenced
+ user.SetName("Bob")  // works
+ &#96;&#96;&#96;
+ 
+ This is a genuine quality-of-life improvement over C. You don't need &#96;-&gt;&#96; vs &#96;.&#96; confusion. Dot notation works for both values and pointers.
+ 
+ ## The Not-Nice Bit: Nil Pointer Panics
+ 
+ C# has &#96;NullReferenceException&#96;. Go has nil pointer panics. Same problem, different name.
+ 
+ &#96;&#96;&#96;go
+ var user *User = nil
+ fmt.Println(user.Name)  // panic: runtime error: invalid memory address
+ &#96;&#96;&#96;
+ 
+ No nullable reference types. No compile-time null safety. Just runtime panics.
+ 
+ C# 8+ with nullable reference types:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = null;
+ Console.WriteLine(user.Name);  // compiler warning: possible null reference
+ &#96;&#96;&#96;
+ 
+ Go doesn't help you here. You check for nil manually, or you panic at runtime. Welcome to 2009.
+ 
+ ## When to Use Pointers
+ 
+ The decision tree:
+ 
+ **Use pointers when:**
+ 
+ 1. **The method modifies the receiver**
+    &#96;&#96;&#96;go
+    func (u *User) SetEmail(email string) {
+        u.Email = email  // needs to modify the original
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **The struct is large**
+    &#96;&#96;&#96;go
+    type BigStruct struct {
+        Data [1024]byte
+        // ... lots of fields
+    }
+    
+    func Process(b *BigStruct) {  // don't copy 1KB every call
+        // ...
+    }
+    &#96;&#96;&#96;
+ 
+ 3. **You need nil to mean "absent"**
+    &#96;&#96;&#96;go
+    type Config struct {
+        Timeout *time.Duration  // nil means "not set", use default
+    }
+    &#96;&#96;&#96;
+ 
+ 4. **Consistency with other methods on the type**
+    If some methods need pointer receivers, use pointers everywhere for that type. Mixing is legal but confusing.
+ 
+ **Use values when:**
+ 
+ 1. **The data is small and immutable**
+    &#96;&#96;&#96;go
+    type Point struct {
+        X, Y int
+    }
+    
+    func (p Point) Distance(other Point) float64 {
+        // fine to copy two ints
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **You want copy-on-pass safety**
+    Value semantics mean the callee can't modify your data.
+ 
+ 3. **The zero value is useful**
+    &#96;&#96;&#96;go
+    var mu sync.Mutex  // zero Mutex is valid, unlocked
+    &#96;&#96;&#96;
+ 
+ ## The "Everything Is a Pointer Receiver" School
+ 
+ Some Go developers just use pointer receivers everywhere. It's simpler. Consistent. No thinking required.
+ 
+ &#96;&#96;&#96;go
+ func (u *User) Name() string { return u.name }      // pointer receiver
+ func (u *User) SetName(n string) { u.name = n }    // pointer receiver
+ func (u *User) IsActive() bool { return u.active } // pointer receiver
+ &#96;&#96;&#96;
+ 
+ Is this optimal? No. Does it matter? Rarely.
+ 
+ The performance difference between passing a pointer vs a small struct is negligible for most code. Consistency and clarity usually matter more.
+ 
+ ## What You Can't Do
+ 
+ Go's pointers are garbage-collected. You can't:
+ 
+ - Do pointer arithmetic (no &#96;p++&#96; to walk through memory)
+ - Free memory manually (the GC handles it)
+ - Have dangling pointers (the GC keeps referenced memory alive)
+ - Cast pointers to integers (without &#96;unsafe&#96;)
+ 
+ This is why Go pointers are "safe"—they're really just references with explicit syntax. All the scary C stuff is locked behind the &#96;unsafe&#96; package.
+ 
+ ## The &#96;unsafe&#96; Package
+ 
+ Go has an escape hatch:
+ 
+ &#96;&#96;&#96;go
+ import "unsafe"
+ 
+ func scary() {
+     var x int64 = 42
+     ptr := unsafe.Pointer(&amp;x)
+     // Now you can do terrible things
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;unsafe&#96; package lets you:
+ - Convert between pointer types
+ - Do pointer arithmetic
+ - Access struct padding
+ - Generally shoot yourself in the foot
+ 
+ If you're using &#96;unsafe&#96; outside of extremely low-level code, you're probably doing something wrong. It exists for syscalls, memory-mapped I/O, and interop—not for your web handlers.
+ 
+ ## Comparing to C# &#96;ref&#96; and Pointers
+ 
+ C# has several ways to get pointer-like semantics:
+ 
+ | C# | Go Equivalent | Notes |
+ |-----|---------------|-------|
+ | &#96;ref&#96; parameter | &#96;*T&#96; parameter | Pass by reference |
+ | &#96;in&#96; parameter | &#96;*T&#96; (readonly discipline) | Go has no &#96;const&#96; pointers |
+ | &#96;out&#96; parameter | &#96;*T&#96; or multiple returns | Go prefers multiple returns |
+ | &#96;Span&lt;T&gt;&#96; | Slices | Different semantics, similar purpose |
+ | &#96;unsafe&#96; pointers | &#96;unsafe.Pointer&#96; | Both are escape hatches |
+ | &#96;ref struct&#96; | No equivalent | Go doesn't have stack-only types |
+ 
+ C#'s &#96;ref struct&#96; and &#96;Span&lt;T&gt;&#96; are genuinely more sophisticated than anything Go offers. If you're doing zero-allocation parsing or high-performance buffer manipulation, .NET's tooling is better.
+ 
+ Go's answer is "use slices and let the GC handle it." Less control, simpler mental model, occasionally more allocation.
+ 
+ ## The Honest Take
+ 
+ Look, I'll be straight with you: C#'s memory model is more sophisticated. The runtime does more for you. Nullable reference types catch null bugs at compile time. &#96;Span&lt;T&gt;&#96; gives you safe, zero-copy views into memory. &#96;ref struct&#96; prevents heap allocation entirely.
+ 
+ Go gives you... pointers. The same pointers we've had since the 1970s, except garbage-collected so you can't corrupt memory.
+ 
+ **What Go does better:**
+ - Simpler mental model (it's just pointers)
+ - Explicit about copies vs references
+ - No hidden boxing/unboxing
+ - Can't accidentally capture stack memory (escape analysis handles it)
+ 
+ **What C# does better:**
+ - Nullable reference types
+ - &#96;Span&lt;T&gt;&#96; and memory-safe slicing
+ - &#96;ref struct&#96; for stack-only types  
+ - More escape hatches that are actually usable (&#96;stackalloc&#96;, etc.)
+ - The whole &#96;System.Memory&#96; namespace
+ 
+ **The verdict:**
+ If you're writing performance-critical code where every allocation matters, C# has more tools. If you're writing normal application code, Go's "just use pointers" simplicity is fine.
+ 
+ You'll write &#96;*User&#96; a lot. You'll occasionally forget to check for nil. You'll survive.
+ 
+ ---
+ 
+ *Next up: stack vs heap allocation and escape analysis—Go decides where your variables live, and you don't always get a vote.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-escape-analysis.md</summary>

**Chunk 1**
Lines added: 306, lines removed: 1

```diff
@@ -1,1 +1,306 @@
- 
+ +++
+ title = "Stack vs Heap: Go's Escape Analysis"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "performance", "csharp"]
+ +++
+ 
+ In C#, you mostly don't think about where variables live. Value types go on the stack (usually). Reference types go on the heap (always). The runtime and JIT make optimisations. You trust the process.
+ 
+ In Go, you still mostly don't think about it—but for different reasons. Go decides where things live at compile time through something called escape analysis. And sometimes it makes choices that'll surprise you.
+ 
+ ## The C# Mental Model
+ 
+ C#'s rules are pretty clear:
+ 
+ &#96;&#96;&#96;csharp
+ void Example()
+ {
+     int x = 42;           // stack - value type, local variable
+     Point p = new(1, 2);  // stack - value type (assuming Point is a struct)
+     
+     var user = new User(); // heap - reference type, always
+     var boxed = (object)x; // heap - boxing allocates
+ }
+ &#96;&#96;&#96;
+ 
+ Value types on stack (unless boxed, captured in closures, or part of a heap object). Reference types on heap. Simple.
+ 
+ .NET has more tricks now—&#96;stackalloc&#96;, &#96;Span&lt;T&gt;&#96;, &#96;ref struct&#96;—but the basic model is straightforward.
+ 
+ ## Go's Escape Analysis
+ 
+ Go doesn't have value types vs reference types in the C# sense. Structs can live on the stack or heap. The compiler decides based on whether the value "escapes" the function.
+ 
+ &#96;&#96;&#96;go
+ func stackAllocation() {
+     x := 42           // stack (probably)
+     user := User{}    // stack (probably)
+     process(&amp;user)    // might change things...
+ }
+ 
+ func heapAllocation() *User {
+     user := User{}    // heap - returned pointer escapes
+     return &amp;user
+ }
+ &#96;&#96;&#96;
+ 
+ The key insight: **if a pointer to something outlives the function, it must be on the heap**. Go figures this out at compile time.
+ 
+ ## Seeing Escape Analysis
+ 
+ You can ask the compiler what it's doing:
+ 
+ &#96;&#96;&#96;bash
+ go build -gcflags="-m" ./...
+ &#96;&#96;&#96;
+ 
+ Output looks like:
+ 
+ &#96;&#96;&#96;
+ ./main.go:10:2: moved to heap: user
+ ./main.go:15:9: &amp;Config{...} escapes to heap
+ ./main.go:20:2: result does not escape
+ &#96;&#96;&#96;
+ 
+ This is genuinely useful for performance work. You can see exactly what's allocating.
+ 
+ ## What Makes Things Escape
+ 
+ ### Returning Pointers
+ 
+ &#96;&#96;&#96;go
+ func newUser() *User {
+     u := User{Name: "Alice"}  // escapes - returned pointer
+     return &amp;u
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;u&#96; pointer is returned, so &#96;u&#96; must outlive the function. Heap.
+ 
+ ### Storing in Interface Values
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     var w io.Writer = &amp;bytes.Buffer{}  // escapes - interface storage
+ }
+ &#96;&#96;&#96;
+ 
+ Interface values often cause heap allocation because the compiler can't always prove the lifetime.
+ 
+ ### Closures Capturing Variables
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42
+     f := func() {
+         fmt.Println(x)  // x escapes - captured by closure
+     }
+     go f()
+ }
+ &#96;&#96;&#96;
+ 
+ Closures that outlive the function (like goroutines) force captures to the heap.
+ 
+ ### Too Large for Stack
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     data := make([]byte, 10*1024*1024)  // 10MB - escapes due to size
+ }
+ &#96;&#96;&#96;
+ 
+ Very large allocations go to the heap regardless of escape.
+ 
+ ### Pointer Stored in Slice or Map
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     users := make([]*User, 0)
+     u := User{Name: "Alice"}
+     users = append(users, &amp;u)  // u escapes - pointer stored in slice
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Stays on the Stack
+ 
+ ### Local Variables Not Referenced
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42          // stack
+     y := x + 1       // stack
+     fmt.Println(y)   // y's value copied to Println, y stays on stack
+ }
+ &#96;&#96;&#96;
+ 
+ ### Pointers That Don't Escape
+ 
+ &#96;&#96;&#96;go
+ func process(u *User) {
+     u.Name = "modified"  // u doesn't escape, caller's stack
+ }
+ 
+ func example() {
+     user := User{}
+     process(&amp;user)  // user can stay on stack - &amp;user doesn't escape process
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler traces through calls to see if pointers ultimately escape.
+ 
+ ## Comparing to .NET
+ 
+ Here's where I get cynical: .NET's approach is more sophisticated and gives you more control.
+ 
+ ### &#96;stackalloc&#96;
+ 
+ &#96;&#96;&#96;csharp
+ Span&lt;byte&gt; buffer = stackalloc byte[1024];
+ // Guaranteed stack allocation, zero heap involvement
+ &#96;&#96;&#96;
+ 
+ Go can't do this. You can't force stack allocation. The compiler decides.
+ 
+ ### &#96;ref struct&#96;
+ 
+ &#96;&#96;&#96;csharp
+ ref struct Parser 
+ {
+     private Span&lt;char&gt; _buffer;
+     // Can ONLY live on stack, compiler enforced
+ }
+ &#96;&#96;&#96;
+ 
+ Go has no equivalent. You can't declare "this type must never be heap-allocated."
+ 
+ ### &#96;Span&lt;T&gt;&#96; Without Allocation
+ 
+ &#96;&#96;&#96;csharp
+ void Process(ReadOnlySpan&lt;char&gt; text)
+ {
+     var slice = text[10..20];  // no allocation, just pointer arithmetic
+ }
+ &#96;&#96;&#96;
+ 
+ Go slices are similar but the escape analysis is less predictable.
+ 
+ ### What .NET Gets Right
+ 
+ The JIT can do escape analysis too, and it can make different decisions at runtime based on actual usage patterns. Go's compile-time analysis is conservative—it heap-allocates when unsure.
+ 
+ &#96;&#96;&#96;csharp
+ // .NET JIT might stack-allocate this if it proves the object doesn't escape
+ var temp = new StringBuilder();
+ temp.Append("hello");
+ return temp.ToString();
+ // StringBuilder might be optimised away entirely
+ &#96;&#96;&#96;
+ 
+ Go's compiler is good, but it doesn't have runtime profile-guided optimisation.
+ 
+ ## The Practical Impact
+ 
+ Does this matter? Sometimes.
+ 
+ For most code—web handlers, CLI tools, data processing—the GC is fast enough that escape analysis is academic. Things allocate, they get collected, life goes on.
+ 
+ For hot paths processing millions of events per second, allocation pressure matters. And here's the uncomfortable truth: **Go gives you less control than C#**.
+ 
+ You can't say "put this on the stack." You can't create stack-only types. You can write code that the compiler *will* stack-allocate, but you're working with the compiler, not commanding it.
+ 
+ ### Tricks That Help
+ 
+ **Sync.Pool for reusable objects:**
+ 
+ &#96;&#96;&#96;go
+ var bufferPool = sync.Pool{
+     New: func() interface{} {
+         return make([]byte, 4096)
+     },
+ }
+ 
+ func process() {
+     buf := bufferPool.Get().([]byte)
+     defer bufferPool.Put(buf)
+     // use buf...
+ }
+ &#96;&#96;&#96;
+ 
+ This doesn't avoid allocation—it reuses allocations. Different problem, similar goal.
+ 
+ **Passing values instead of pointers for small structs:**
+ 
+ &#96;&#96;&#96;go
+ // This might heap-allocate due to interface
+ func process(r io.Reader) { ... }
+ 
+ // This won't heap-allocate
+ func processBytes(data []byte) { ... }
+ &#96;&#96;&#96;
+ 
+ Sometimes avoiding interfaces avoids allocation. But you lose flexibility.
+ 
+ **Preallocating slices:**
+ 
+ &#96;&#96;&#96;go
+ // Might grow and reallocate multiple times
+ results := make([]Result, 0)
+ 
+ // Single allocation if you know the size
+ results := make([]Result, 0, expectedSize)
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ I'll be blunt: if you're coming from .NET and you care deeply about allocation control, Go will frustrate you.
+ 
+ .NET gives you:
+ - &#96;stackalloc&#96; for explicit stack allocation
+ - &#96;ref struct&#96; for stack-only types
+ - &#96;Span&lt;T&gt;&#96; for zero-allocation slicing
+ - &#96;ArrayPool&lt;T&gt;&#96; for buffer reuse with a clean API
+ - Object pooling with sophisticated lifetime management
+ - JIT optimisations that can eliminate allocations entirely
+ 
+ Go gives you:
+ - Escape analysis that usually does the right thing
+ - &#96;sync.Pool&#96; for object reuse (but with interface{} boxing before 1.18)
+ - The ability to check what escapes with compiler flags
+ - A fast garbage collector that makes most of this not matter
+ 
+ **When Go's approach works:**
+ - You're building services with reasonable latency requirements
+ - You're not processing millions of messages per second per core
+ - You value simplicity over maximum control
+ - You're okay trading some performance for less complexity
+ 
+ **When you'll miss .NET:**
+ - Sub-millisecond latency requirements
+ - Zero-GC paths are necessary
+ - You need guaranteed stack allocation
+ - High-frequency trading, game engines, real-time systems
+ 
+ For 90% of software, Go's escape analysis is fine. The GC is good. You won't notice. For the other 10%, .NET genuinely has better tools.
+ 
+ ## Checking Your Allocations
+ 
+ Profile before optimising:
+ 
+ &#96;&#96;&#96;bash
+ # Run benchmarks with allocation stats
+ go test -bench=. -benchmem
+ 
+ # Trace allocations
+ go tool pprof -alloc_space profile.out
+ 
+ # See escape decisions
+ go build -gcflags="-m -m" ./...  # extra -m for more detail
+ &#96;&#96;&#96;
+ 
+ Know what's actually allocating before you fight the compiler.
+ 
+ ---
+ 
+ *Next up: slices in depth—they're not arrays, they're not List&lt;T&gt;, and the gotchas around capacity, length, and shared backing arrays will bite you eventually.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-slices.md</summary>

**Chunk 1**
Lines added: 301, lines removed: 1

```diff
@@ -1,1 +1,301 @@
- 
+ +++
+ title = "Slices Are Not Arrays (And Neither Is List&lt;T&gt;)"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "slices", "csharp"]
+ +++
+ 
+ Every C# developer coming to Go makes the same mistake: they see &#96;[]int&#96; and think "array" or "list." It's neither. It's a slice, and it has semantics that will bite you if you don't understand them.
+ 
+ This is one of those Go concepts that seems simple until it isn't. Let's dig in.
+ 
+ ## What a Slice Actually Is
+ 
+ A slice is a struct with three fields:
+ 
+ &#96;&#96;&#96;go
+ // Conceptually:
+ type slice struct {
+     array *T   // pointer to underlying array
+     len   int  // number of elements in use
+     cap   int  // total capacity of underlying array
+ }
+ &#96;&#96;&#96;
+ 
+ When you create a slice, you're creating this header. The actual data lives in a backing array somewhere.
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3, 4, 5}
+ // s.array -&gt; [1, 2, 3, 4, 5, _, _, _]  (backing array, might have extra capacity)
+ // s.len = 5
+ // s.cap = 5 (or more)
+ &#96;&#96;&#96;
+ 
+ This is fundamentally different from both C# arrays and &#96;List&lt;T&gt;&#96;.
+ 
+ ## The C# Mental Model (And Why It's Wrong Here)
+ 
+ **C# arrays** are fixed-size, directly hold their data:
+ 
+ &#96;&#96;&#96;csharp
+ int[] arr = new int[5];
+ // arr IS the array, fixed size, done
+ &#96;&#96;&#96;
+ 
+ **C# List&lt;T&gt;** wraps an array with growth semantics:
+ 
+ &#96;&#96;&#96;csharp
+ var list = new List&lt;int&gt; { 1, 2, 3 };
+ list.Add(4);  // might reallocate internally
+ // But list is a reference type - you always work with the same list object
+ &#96;&#96;&#96;
+ 
+ **Go slices** are value types that point to arrays:
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3}
+ s = append(s, 4)  // might return a NEW slice header pointing to NEW array
+ &#96;&#96;&#96;
+ 
+ That last line is where people get burned. &#96;append&#96; might modify the backing array in place, or it might allocate a new array and return a slice pointing to it. **You must use the return value.**
+ 
+ ## The append Trap
+ 
+ This looks fine:
+ 
+ &#96;&#96;&#96;go
+ func addItem(items []int, item int) {
+     items = append(items, item)
+ }
+ 
+ func main() {
+     s := []int{1, 2, 3}
+     addItem(s, 4)
+     fmt.Println(s)  // [1 2 3] - item wasn't added!
+ }
+ &#96;&#96;&#96;
+ 
+ The slice header is passed by value. &#96;append&#96; creates a new header (possibly pointing to a new array), but that new header only exists inside &#96;addItem&#96;. The caller's &#96;s&#96; is unchanged.
+ 
+ Fixes:
+ 
+ &#96;&#96;&#96;go
+ // Option 1: Return the new slice
+ func addItem(items []int, item int) []int {
+     return append(items, item)
+ }
+ 
+ s = addItem(s, 4)  // use the return value
+ 
+ // Option 2: Use a pointer to slice (less common)
+ func addItem(items *[]int, item int) {
+     *items = append(*items, item)
+ }
+ 
+ addItem(&amp;s, 4)
+ &#96;&#96;&#96;
+ 
+ In C#, this wouldn't be a problem—&#96;List&lt;T&gt;&#96; is a reference type:
+ 
+ &#96;&#96;&#96;csharp
+ void AddItem(List&lt;int&gt; items, int item) {
+     items.Add(item);  // modifies the actual list
+ }
+ &#96;&#96;&#96;
+ 
+ Go's slice is not a reference type. It's a value type that contains a pointer. Subtle but critical difference.
+ 
+ ## Shared Backing Arrays (The Real Gotcha)
+ 
+ Here's where it gets properly dangerous:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice1 := original[1:3]  // [2, 3]
+ slice2 := original[2:4]  // [3, 4]
+ 
+ slice1[1] = 999  // modify slice1
+ 
+ fmt.Println(original)  // [1 2 999 4 5]
+ fmt.Println(slice1)    // [2 999]
+ fmt.Println(slice2)    // [999 4]
+ &#96;&#96;&#96;
+ 
+ All three slices share the same backing array. Modify one, you modify them all.
+ 
+ This is nothing like C#:
+ 
+ &#96;&#96;&#96;csharp
+ var original = new int[] { 1, 2, 3, 4, 5 };
+ var slice = original[1..3];  // creates a NEW array in C# 8+
+ slice[1] = 999;
+ Console.WriteLine(string.Join(", ", original));  // 1, 2, 3, 4, 5 - unchanged
+ &#96;&#96;&#96;
+ 
+ C# ranges create copies. Go slices share memory. Neither is wrong, but they're completely different behaviours.
+ 
+ ### The Capacity Gotcha
+ 
+ It gets worse. When you slice, you might have hidden capacity:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice := original[1:3]  // [2, 3], but capacity is 4!
+ 
+ fmt.Println(len(slice))  // 2
+ fmt.Println(cap(slice))  // 4 - can see elements 1-4 of original
+ 
+ slice = append(slice, 999)  // doesn't allocate new array - overwrites original!
+ 
+ fmt.Println(original)  // [1 2 3 999 5] - element 3 (index 3) was overwritten
+ &#96;&#96;&#96;
+ 
+ The &#96;append&#96; saw capacity, used it, and stomped on data that logically wasn't part of &#96;slice&#96; but physically was in the backing array.
+ 
+ To prevent this:
+ 
+ &#96;&#96;&#96;go
+ // Limit capacity when slicing
+ slice := original[1:3:3]  // [low:high:max] - capacity is high-low = 2
+ 
+ // Or copy explicitly
+ slice := make([]int, 2)
+ copy(slice, original[1:3])
+ &#96;&#96;&#96;
+ 
+ ## Length vs Capacity
+ 
+ This distinction doesn't exist in &#96;List&lt;T&gt;&#96; (internally it does, but you don't see it):
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 3, 10)  // length 3, capacity 10
+ fmt.Println(len(s))  // 3
+ fmt.Println(cap(s))  // 10
+ 
+ s[0] = 1  // OK
+ s[5] = 1  // panic: index out of range - len is 3!
+ 
+ s = s[:cap(s)]  // extend slice to full capacity
+ s[5] = 1        // now OK
+ &#96;&#96;&#96;
+ 
+ Length is how many elements are accessible. Capacity is how many could be before reallocation. This is an implementation detail that Go exposes and expects you to understand.
+ 
+ ## nil vs Empty Slice
+ 
+ Oh good, more nil pain:
+ 
+ &#96;&#96;&#96;go
+ var s1 []int          // nil slice
+ s2 := []int{}         // empty slice
+ s3 := make([]int, 0)  // empty slice
+ 
+ fmt.Println(s1 == nil)  // true
+ fmt.Println(s2 == nil)  // false
+ fmt.Println(s3 == nil)  // false
+ 
+ // But they all behave the same for most operations
+ fmt.Println(len(s1), len(s2), len(s3))  // 0 0 0
+ &#96;&#96;&#96;
+ 
+ A nil slice and an empty slice are functionally equivalent for &#96;len&#96;, &#96;cap&#96;, &#96;append&#96;, and &#96;range&#96;. But they're not equal to each other, and some JSON encoders treat them differently.
+ 
+ &#96;&#96;&#96;go
+ json.Marshal(s1)  // might produce "null"
+ json.Marshal(s2)  // produces "[]"
+ &#96;&#96;&#96;
+ 
+ Wonderful.
+ 
+ ## Patterns That Help
+ 
+ ### Always Capture append's Return
+ 
+ &#96;&#96;&#96;go
+ s = append(s, item)  // always assign back
+ &#96;&#96;&#96;
+ 
+ ### Copy When Returning Subslices
+ 
+ &#96;&#96;&#96;go
+ func getSubset(data []int) []int {
+     subset := data[10:20]
+     
+     // Bad: caller might have data, mutating subset affects data
+     return subset
+     
+     // Good: caller gets independent slice
+     result := make([]int, len(subset))
+     copy(result, subset)
+     return result
+ }
+ &#96;&#96;&#96;
+ 
+ ### Preallocate When Size Is Known
+ 
+ &#96;&#96;&#96;go
+ // Might reallocate multiple times
+ results := []int{}
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Single allocation
+ results := make([]int, 0, len(items))
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Or even better, known length
+ results := make([]int, len(items))
+ for i, item := range items {
+     results[i] = transform(item)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Use the Three-Index Slice for Safety
+ 
+ &#96;&#96;&#96;go
+ // Dangerous: slice might have hidden capacity
+ sub := data[a:b]
+ 
+ // Safe: capacity is limited
+ sub := data[a:b:b]
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Array | C# List&lt;T&gt; | Go Slice |
+ |--------|----------|------------|----------|
+ | Fixed size | Yes | No | No |
+ | Reference type | Yes | Yes | No (value type with pointer) |
+ | Slicing copies | Yes (ranges) | N/A | No (shares memory) |
+ | append semantics | N/A | Add modifies list | Returns new header |
+ | Hidden capacity | No | Yes (internal) | Yes (exposed) |
+ | nil vs empty | null vs new int[0] | null vs new List | Different behaviours |
+ 
+ ## The Honest Take
+ 
+ Slices are Go's most footgun-laden feature. They look simple, they have subtle semantics, and the gotchas aren't obvious until you've been bitten.
+ 
+ **What Go gets right:**
+ - Efficient memory sharing when you want it
+ - Clear distinction between length and capacity
+ - &#96;append&#96; is convenient (when used correctly)
+ - No boxing, good cache locality
+ 
+ **What C# does better:**
+ - &#96;List&lt;T&gt;&#96; is a reference type—modifications are visible everywhere
+ - Range slicing copies by default—no surprise aliasing
+ - &#96;Span&lt;T&gt;&#96; gives you explicit no-copy semantics when you want them
+ - You don't have to remember the three-index slice syntax
+ 
+ **The verdict:**
+ Slices are powerful and efficient. They're also a sharp tool that will cut you. Every Go developer has been bitten by shared backing arrays or forgotten &#96;append&#96; returns.
+ 
+ My advice: be paranoid about slice aliasing. Copy when returning subslices. Always use the return value of &#96;append&#96;. And when something mutates unexpectedly, check your slices first.
+ 
+ ---
+ 
+ *That wraps up the memory section. Next we'll move into concurrency—goroutines, channels, and why Go's approach is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all these new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
      14
---
-rw-r--r--  1 andycross  staff  10095 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   9266 Dec 29 07:53 content/posts/dotnet-to-go-errors.md
-rw-r--r--  1 andycross  staff   8268 Dec 29 15:26 content/posts/dotnet-to-go-escape-analysis.md
-rw-r--r--  1 andycross  staff   8876 Dec 28 20:26 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8501 Dec 28 20:26 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8319 Dec 29 07:53 content/posts/dotnet-to-go-panic.md
-rw-r--r--  1 andycross  staff  10755 Dec 29 07:48 content/posts/dotnet-to-go-phrasebook.md
-rw-r--r--  1 andycross  staff   8107 Dec 29 15:25 content/posts/dotnet-to-go-pointers.md
-rw-r--r--  1 andycross  staff   8294 Dec 29 15:27 content/posts/dotnet-to-go-slices.md
-rw-r--r--  1 andycross  staff   8748 Dec 29 07:49 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   9594 Dec 29 07:53 content/posts/dotnet-to-go-switch.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9253 Dec 28 20:26 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 posts build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Memory & Pointers posts are done. 14 posts total now, with appropriate snark about .NET's superiority in this area. Here's the updated series:

## C# to Go Series (14 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"**
2. **"Goodbye .csproj, Hello go.mod"**
3. **"The Phrasebook: C# Concepts in Go Terms"**

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"**
5. **"Where Did My Properties Go?"**
6. **"Generics: Late to the Party"**
7. **"The Million Dollar Mistake, Differently"**
8. **"No Enums? No Problem (Sort Of)"**

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"**
10. **"Panic and Recover: The Emergency Exit"**
11. **"The switch Statement You Always Wanted"**

### Phase 4: Memory & Pointers ← **NEW**
12. **"Pointers Without the Pain"** — What C# hides, automatic dereferencing, nil panics, when to use pointers, acknowledging that nullable reference types are better
13. **"Stack vs Heap: Go's Escape Analysis"** — Compile-time decisions, what escapes, the `-gcflags="-m"` trick, lamenting the lack of `stackalloc`, `ref struct`, and `Span<T>`
14. **"Slices Are Not Arrays (And Neither Is List<T>)"** — The append trap, shared backing arrays, the three-index slice, capacity gotchas, why this is Go's most footgun-laden feature

Key themes in the memory posts:
- Honest acknowledgment that .NET has better tools (`Span<T>`, `ref struct`, nullable references, `stackalloc`)
- Go gives you less control but a simpler mental model
- The slice semantics will absolutely bite you
- Escape analysis is good but you can't force stack allocation

Ready for Phase 5 (concurrency) whenever you want to tackle goroutines vs async/await!

---

_**User (2025-12-29 17:28Z)**_

update the one about pointers to detail what dereferencing means, effectively following the pointer to the thing that is pointed at, which is a bit of a mouthful so that's why we use a lil * 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to update the pointers post to better explain what dereferencing means. The post was deleted according to the context, so I need to rewrite it with the added explanation about dereferencing - "following the pointer to the thing that is pointed at."

Let me rewrite the pointers post with a clearer explanation of dereferencing early on.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md</summary>

**Chunk 1**
Lines added: 292, lines removed: 1

```diff
@@ -1,1 +1,292 @@
- 
+ +++
+ title = "Pointers Without the Pain"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "pointers", "csharp"]
+ +++
+ 
+ Right, let's talk about pointers. If you've spent your career in C#, you've probably used pointers approximately never. Maybe you've seen &#96;unsafe&#96; blocks in performance-critical library code. Maybe you've used &#96;ref&#96; and &#96;Span&lt;T&gt;&#96; and felt rather clever about it.
+ 
+ In Go, pointers are everywhere. Every method receiver decision involves them. Every struct-passing decision involves them. You can't hide from them.
+ 
+ The good news: Go's pointers are considerably less terrifying than C's. The bad news: you actually have to think about them now.
+ 
+ ## What C# Hides
+ 
+ C# makes a neat distinction: value types live on the stack (mostly), reference types live on the heap (mostly), and the runtime figures out the details. You don't think about addresses. You don't think about dereferencing. You just use stuff.
+ 
+ &#96;&#96;&#96;csharp
+ var user = new User { Name = "Alice" };  // heap, reference semantics
+ var point = new Point(10, 20);           // stack (probably), value semantics
+ 
+ ProcessUser(user);   // passes reference
+ ProcessPoint(point); // passes copy
+ &#96;&#96;&#96;
+ 
+ The runtime decides where things actually live. The JIT optimises. Escape analysis happens. You don't care.
+ 
+ Go is more... honest? Explicit? Annoying? All three, depending on your mood.
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice"}   // where does this live? Depends!
+ ptr := &amp;User{Name: "Bob"}     // definitely a pointer
+ 
+ ProcessUser(user)   // passes copy
+ ProcessUser(&amp;user)  // passes pointer
+ ProcessUserPtr(ptr) // passes pointer
+ &#96;&#96;&#96;
+ 
+ You have to think about it. Every time.
+ 
+ ## Go Pointer Basics
+ 
+ The syntax is C-style:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x    // p is *int, pointing to x
+ fmt.Println(*p)  // 42 - dereference to get value
+ *p = 100   // x is now 100
+ &#96;&#96;&#96;
+ 
+ Two operators, two meanings:
+ 
+ - &#96;&amp;&#96; means "give me the address of this thing"—where it lives in memory
+ - &#96;*&#96; means "follow this address to the thing it points at"—dereferencing
+ 
+ ### What's Dereferencing?
+ 
+ If a pointer is an address—"the data lives at memory location 0x1234"—then dereferencing is following that address to get the actual data. It's a bit of a mouthful: "follow the pointer to the thing that is pointed at." That's why we just use a little &#96;*&#96;.
+ 
+ Think of it like a postal address. The pointer &#96;p&#96; is the address on an envelope. Dereferencing &#96;*p&#96; is going to that address and looking at what's actually there.
+ 
+ &#96;&#96;&#96;go
+ x := 42       // x is the value 42, stored somewhere in memory
+ p := &amp;x       // p holds the address of x (like "123 Memory Lane")
+               // p itself is *int - "a pointer to an int"
+ 
+ fmt.Println(p)   // prints an address like 0xc000012345
+ fmt.Println(*p)  // prints 42 - we followed the address to get the value
+ 
+ *p = 100      // go to that address, change what's stored there
+ fmt.Println(x)   // prints 100 - x changed because p points to x
+ &#96;&#96;&#96;
+ 
+ The &#96;*&#96; does double duty in Go (and C):
+ - In a type declaration, &#96;*int&#96; means "pointer to int"
+ - As an operator, &#96;*p&#96; means "dereference p—follow the pointer"
+ 
+ This is confusing for about a week, then it becomes second nature.
+ 
+ ### Creating Pointers
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ user := &amp;User{Name: "Alice"}
+ 
+ // vs
+ user := new(User)
+ user.Name = "Alice"
+ 
+ // vs
+ var user User
+ user.Name = "Alice"
+ userPtr := &amp;user
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;&#96; operator gives you a pointer. The &#96;*&#96; operator dereferences. If you've touched C or C++ at any point, this is familiar.
+ 
+ ## The Nice Bit: Automatic Dereferencing
+ 
+ Unlike C, Go automatically dereferences pointers for field and method access:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ func (u *User) SetName(name string) {
+     u.Name = name  // not (*u).Name, just u.Name
+ }
+ 
+ user := &amp;User{}
+ user.Name = "Alice"  // works, auto-dereferenced
+ user.SetName("Bob")  // works
+ &#96;&#96;&#96;
+ 
+ In C, you'd write &#96;user-&gt;Name&#96; for pointer access and &#96;user.Name&#96; for value access. Go just uses dot notation for both and figures it out.
+ 
+ This is a genuine quality-of-life improvement. You don't need &#96;-&gt;&#96; vs &#96;.&#96; confusion. Dot notation works for both values and pointers.
+ 
+ ## The Not-Nice Bit: Nil Pointer Panics
+ 
+ C# has &#96;NullReferenceException&#96;. Go has nil pointer panics. Same problem, different name.
+ 
+ &#96;&#96;&#96;go
+ var user *User = nil
+ fmt.Println(user.Name)  // panic: runtime error: invalid memory address
+ &#96;&#96;&#96;
+ 
+ When you try to dereference a nil pointer—follow an address that doesn't point anywhere—Go panics. There's nothing at that address to read.
+ 
+ No nullable reference types. No compile-time null safety. Just runtime panics.
+ 
+ C# 8+ with nullable reference types:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = null;
+ Console.WriteLine(user.Name);  // compiler warning: possible null reference
+ &#96;&#96;&#96;
+ 
+ Go doesn't help you here. You check for nil manually, or you panic at runtime. Welcome to 2009.
+ 
+ ## When to Use Pointers
+ 
+ The decision tree:
+ 
+ **Use pointers when:**
+ 
+ 1. **The method modifies the receiver**
+    &#96;&#96;&#96;go
+    func (u *User) SetEmail(email string) {
+        u.Email = email  // needs to modify the original
+    }
+    &#96;&#96;&#96;
+    Without the pointer, &#96;SetEmail&#96; would modify a copy, and the caller's &#96;User&#96; would be unchanged.
+ 
+ 2. **The struct is large**
+    &#96;&#96;&#96;go
+    type BigStruct struct {
+        Data [1024]byte
+        // ... lots of fields
+    }
+    
+    func Process(b *BigStruct) {  // don't copy 1KB every call
+        // ...
+    }
+    &#96;&#96;&#96;
+ 
+ 3. **You need nil to mean "absent"**
+    &#96;&#96;&#96;go
+    type Config struct {
+        Timeout *time.Duration  // nil means "not set", use default
+    }
+    &#96;&#96;&#96;
+ 
+ 4. **Consistency with other methods on the type**
+    If some methods need pointer receivers, use pointers everywhere for that type. Mixing is legal but confusing.
+ 
+ **Use values when:**
+ 
+ 1. **The data is small and immutable**
+    &#96;&#96;&#96;go
+    type Point struct {
+        X, Y int
+    }
+    
+    func (p Point) Distance(other Point) float64 {
+        // fine to copy two ints
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **You want copy-on-pass safety**
+    Value semantics mean the callee can't modify your data.
+ 
+ 3. **The zero value is useful**
+    &#96;&#96;&#96;go
+    var mu sync.Mutex  // zero Mutex is valid, unlocked
+    &#96;&#96;&#96;
+ 
+ ## The "Everything Is a Pointer Receiver" School
+ 
+ Some Go developers just use pointer receivers everywhere. It's simpler. Consistent. No thinking required.
+ 
+ &#96;&#96;&#96;go
+ func (u *User) Name() string { return u.name }      // pointer receiver
+ func (u *User) SetName(n string) { u.name = n }    // pointer receiver
+ func (u *User) IsActive() bool { return u.active } // pointer receiver
+ &#96;&#96;&#96;
+ 
+ Is this optimal? No. Does it matter? Rarely.
+ 
+ The performance difference between passing a pointer vs a small struct is negligible for most code. Consistency and clarity usually matter more.
+ 
+ ## What You Can't Do
+ 
+ Go's pointers are garbage-collected. You can't:
+ 
+ - Do pointer arithmetic (no &#96;p++&#96; to walk through memory)
+ - Free memory manually (the GC handles it)
+ - Have dangling pointers (the GC keeps referenced memory alive)
+ - Cast pointers to integers (without &#96;unsafe&#96;)
+ 
+ This is why Go pointers are "safe"—they're really just references with explicit syntax. All the scary C stuff is locked behind the &#96;unsafe&#96; package.
+ 
+ ## The &#96;unsafe&#96; Package
+ 
+ Go has an escape hatch:
+ 
+ &#96;&#96;&#96;go
+ import "unsafe"
+ 
+ func scary() {
+     var x int64 = 42
+     ptr := unsafe.Pointer(&amp;x)
+     // Now you can do terrible things
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;unsafe&#96; package lets you:
+ - Convert between pointer types
+ - Do pointer arithmetic
+ - Access struct padding
+ - Generally shoot yourself in the foot
+ 
+ If you're using &#96;unsafe&#96; outside of extremely low-level code, you're probably doing something wrong. It exists for syscalls, memory-mapped I/O, and interop—not for your web handlers.
+ 
+ ## Comparing to C# &#96;ref&#96; and Pointers
+ 
+ C# has several ways to get pointer-like semantics:
+ 
+ | C# | Go Equivalent | Notes |
+ |-----|---------------|-------|
+ | &#96;ref&#96; parameter | &#96;*T&#96; parameter | Pass by reference |
+ | &#96;in&#96; parameter | &#96;*T&#96; (readonly discipline) | Go has no &#96;const&#96; pointers |
+ | &#96;out&#96; parameter | &#96;*T&#96; or multiple returns | Go prefers multiple returns |
+ | &#96;Span&lt;T&gt;&#96; | Slices | Different semantics, similar purpose |
+ | &#96;unsafe&#96; pointers | &#96;unsafe.Pointer&#96; | Both are escape hatches |
+ | &#96;ref struct&#96; | No equivalent | Go doesn't have stack-only types |
+ 
+ C#'s &#96;ref struct&#96; and &#96;Span&lt;T&gt;&#96; are genuinely more sophisticated than anything Go offers. If you're doing zero-allocation parsing or high-performance buffer manipulation, .NET's tooling is better.
+ 
+ Go's answer is "use slices and let the GC handle it." Less control, simpler mental model, occasionally more allocation.
+ 
+ ## The Honest Take
+ 
+ Look, I'll be straight with you: C#'s memory model is more sophisticated. The runtime does more for you. Nullable reference types catch null bugs at compile time. &#96;Span&lt;T&gt;&#96; gives you safe, zero-copy views into memory. &#96;ref struct&#96; prevents heap allocation entirely.
+ 
+ Go gives you... pointers. The same pointers we've had since the 1970s, except garbage-collected so you can't corrupt memory.
+ 
+ **What Go does better:**
+ - Simpler mental model (it's just pointers)
+ - Explicit about copies vs references
+ - No hidden boxing/unboxing
+ - Can't accidentally capture stack memory (escape analysis handles it)
+ 
+ **What C# does better:**
+ - Nullable reference types
+ - &#96;Span&lt;T&gt;&#96; and memory-safe slicing
+ - &#96;ref struct&#96; for stack-only types  
+ - More escape hatches that are actually usable (&#96;stackalloc&#96;, etc.)
+ - The whole &#96;System.Memory&#96; namespace
+ 
+ **The verdict:**
+ If you're writing performance-critical code where every allocation matters, C# has more tools. If you're writing normal application code, Go's "just use pointers" simplicity is fine.
+ 
+ You'll write &#96;*User&#96; a lot. You'll occasionally forget to check for nil. You'll survive.
+ 
+ ---
+ 
+ *Next up: stack vs heap allocation and escape analysis—Go decides where your variables live, and you don't always get a vote.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build passes.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful"</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful"
```

```
Build successful

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Build passed. The pointers post now has a better explanation of dereferencing.</details></think>

---

Done. I've expanded the dereferencing explanation with:

1. **A clear definition**: "following that address to get the actual data"
2. **The "mouthful" acknowledgment**: explaining why we use `*` instead of saying "follow the pointer to the thing that is pointed at"
3. **A postal address analogy**: pointer is like an address on an envelope, dereferencing is going to that address
4. **A worked example** showing the relationship between `x`, `p`, `&x`, and `*p` with comments
5. **The dual meaning of `*`**: in type declarations (`*int`) vs as an operator (`*p`)

The key addition:

```go
x := 42       // x is the value 42, stored somewhere in memory
p := &x       // p holds the address of x (like "123 Memory Lane")
              // p itself is *int - "a pointer to an int"

fmt.Println(p)   // prints an address like 0xc000012345
fmt.Println(*p)  // prints 42 - we followed the address to get the value

*p = 100      // go to that address, change what's stored there
fmt.Println(x)   // prints 100 - x changed because p points to x
```

---

_**User (2025-12-29 17:28Z)**_

look at the git not staged log, what is with all the deletions?! that's really surprising to me 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user is asking about git status - they're surprised to see deletions in the unstaged changes. Let me check what's going on with git status.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && git status</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && git status
```

```
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
	modified:   .specstory/history/2025-12-28_20-16Z-c#-to-go-blog-content-series.md
	deleted:    content/posts/dotnet-to-go-errors.md
	deleted:    content/posts/dotnet-to-go-escape-analysis.md
	deleted:    content/posts/dotnet-to-go-panic.md
	modified:   content/posts/dotnet-to-go-pointers.md
	deleted:    content/posts/dotnet-to-go-slices.md
	deleted:    content/posts/dotnet-to-go-switch.md
	modified:   content/posts/streaming-json-partial-parser.md

no changes added to commit (use "git add" and/or "git commit -a")

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
That's very strange - the files I created are showing as deleted! But wait, looking at the context earlier, the user's `<deleted_files>` section showed those same files. It seems like those files were deleted outside of my actions, perhaps by the user or some other process.

Let me check if those files actually exist on disk:</details></think>

---

That's strange! Let me check if those files actually exist on disk:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md</summary>

```bash
ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md
```

```
-rw-r--r--  1 andycross  staff  10095 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   8876 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8501 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff  10755 Dec 29 07:48 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-phrasebook.md
-rw-r--r--  1 andycross  staff   9789 Dec 29 18:05 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md
-rw-r--r--  1 andycross  staff   8748 Dec 29 07:49 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9253 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Okay, so those 5 files (errors, escape-analysis, panic, slices, switch) were deleted and are no longer on disk. Only 9 files exist now, not 14.

Looking back at the conversation context, I see `<deleted_files>` was in the user's last message before they asked me to update the pointers post. Those files must have been deleted by the user (or they rejected/reverted those changes somehow) between when I created them and when they asked me to update the pointers post.

The files that are missing:
- dotnet-to-go-errors.md (Phase 3)
- dotnet-to-go-panic.md (Phase 3)
- dotnet-to-go-switch.md (Phase 3)
- dotnet-to-go-escape-analysis.md (Phase 4)
- dotnet-to-go-slices.md (Phase 4)

So we've lost all of Phase 3 and 2 of the 3 Phase 4 posts. Only the pointers post survived from those batches.

Let me tell the user what happened.</details></think>

---

Ah, I see what happened! Five files are genuinely missing from disk:

**Missing files (were created, now gone):**
- `dotnet-to-go-errors.md` (Phase 3)
- `dotnet-to-go-panic.md` (Phase 3)
- `dotnet-to-go-switch.md` (Phase 3)
- `dotnet-to-go-escape-analysis.md` (Phase 4)
- `dotnet-to-go-slices.md` (Phase 4)

**Still exist:**
- Phase 1: toolchain, modules, phrasebook ✓
- Phase 2: structs, visibility, generics, nil, enums ✓
- Phase 4: pointers ✓ (just updated)

It looks like those files were deleted somewhere between when I created them and now. The `<deleted_files>` section showed up in your previous message's context, which suggests they were removed (perhaps you rejected those file creations, or deleted them manually?).

Want me to recreate the missing posts? That would be:
- **Phase 3** (all 3): errors, panic, switch
- **Phase 4** (2 of 3): escape-analysis, slices

---

_**User (2025-12-29 17:28Z)**_

use git to pull them back

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to restore the deleted files from git. Since they show as "deleted" in the unstaged changes, I can use `git restore` to bring them back.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && git restore content/posts/dotnet-to-go-errors.md content/posts/dotnet-to-go-escape-analysis.md content/posts/dotnet-to-go-panic.md content/posts/dotnet-to-go-slices.md content/posts/dotnet-to-go-switch.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && git restore content/posts/dotnet-to-go-errors.md content/posts/dotnet-to-go-escape-analysis.md content/posts/dotnet-to-go-panic.md content/posts/dotnet-to-go-slices.md content/posts/dotnet-to-go-switch.md
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify all the files are back.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
      14
---
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 files are restored. Let me verify the build still passes.</details></think>

---

All 14 posts restored. Let me verify the build still works:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && git status --short</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && git status --short
```

```
Build successful
 M .specstory/history/2025-12-28_20-16Z-c#-to-go-blog-content-series.md
 M content/posts/dotnet-to-go-pointers.md
 M content/posts/streaming-json-partial-parser.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 posts are back, the build passes, and the only modifications now are:- The pointers post (which I updated with the dereferencing explanation)- Some specstory file (internal tracking)- streaming-json-partial-parser (not sure why that's modified, but it's unrelated to our work)No more deletions showing.</details></think>

---

All sorted. 14 posts back, build passes, and git status now only shows modifications (no deletions):

- `dotnet-to-go-pointers.md` — the dereferencing explanation we just added
- Two other modified files unrelated to the series

Ready to continue with Phase 5 (concurrency) whenever you like!

---

_**User (2025-12-29 17:28Z)**_

here's our concurrency list, let's go!

Concurrency

Async/Await vs Goroutines: A Mindset Shift — Why Go's model feels backwards until it clicks
Channels: The sync You Didn't Know You Wanted — Producer/consumer patterns without BlockingCollection
select: Multiplexing Like a Pro — Handling multiple channels, timeouts, and cancellation
Mutexes and WaitGroups: When Channels Aren't the Answer — sync package deep-dive for C# devs who know their locks
Context Is King — Cancellation tokens, but make it Go

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the 5 concurrency posts. This is where Go genuinely shines compared to C#'s async/await model in many ways, so I should be fair but also highlight where Go's model is genuinely elegant. Let me write all 5 posts.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-goroutines.md</summary>

**Chunk 1**
Lines added: 298, lines removed: 1

```diff
@@ -1,1 +1,298 @@
- 
+ +++
+ title = "Async/Await vs Goroutines: A Mindset Shift"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "async", "csharp"]
+ +++
+ 
+ Here's the thing about Go's concurrency model: it's going to feel backwards. You've spent years learning that async operations need &#96;async&#96; keywords, &#96;await&#96; expressions, &#96;Task&lt;T&gt;&#96; return types, and careful thought about which thread you're on.
+ 
+ Go throws all of that out. Any function can be concurrent. There's no special syntax. No coloured functions. No async/await virus spreading through your codebase.
+ 
+ It feels wrong until suddenly it doesn't.
+ 
+ ## The C# Model: Async All the Way Down
+ 
+ In C#, concurrency is opt-in and explicit:
+ 
+ &#96;&#96;&#96;csharp
+ public async Task&lt;User&gt; GetUserAsync(int id)
+ {
+     var response = await _httpClient.GetAsync($"/users/{id}");
+     var json = await response.Content.ReadAsStringAsync();
+     return JsonSerializer.Deserialize&lt;User&gt;(json);
+ }
+ 
+ public async Task ProcessUsersAsync()
+ {
+     var user1 = await GetUserAsync(1);
+     var user2 = await GetUserAsync(2);
+     // Sequential - second waits for first
+ }
+ &#96;&#96;&#96;
+ 
+ Want parallel execution?
+ 
+ &#96;&#96;&#96;csharp
+ public async Task ProcessUsersAsync()
+ {
+     var task1 = GetUserAsync(1);
+     var task2 = GetUserAsync(2);
+     var users = await Task.WhenAll(task1, task2);
+     // Parallel - both run concurrently
+ }
+ &#96;&#96;&#96;
+ 
+ This model is explicit, type-safe, and viral—once you have an async function, everything that calls it tends to become async too.
+ 
+ ## The Go Model: Just... Go
+ 
+ Go's approach is radically simpler:
+ 
+ &#96;&#96;&#96;go
+ func GetUser(id int) (*User, error) {
+     resp, err := http.Get(fmt.Sprintf("/users/%d", id))
+     if err != nil {
+         return nil, err
+     }
+     defer resp.Body.Close()
+     
+     var user User
+     if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil {
+         return nil, err
+     }
+     return &amp;user, nil
+ }
+ &#96;&#96;&#96;
+ 
+ Notice: no async keyword. No special return type. It's just a function.
+ 
+ Want to run it concurrently? Add the &#96;go&#96; keyword:
+ 
+ &#96;&#96;&#96;go
+ go GetUser(1)  // runs in background, returns immediately
+ go GetUser(2)  // also runs in background
+ &#96;&#96;&#96;
+ 
+ That's it. Any function can be spawned as a goroutine. No syntax changes to the function itself.
+ 
+ ## What's a Goroutine?
+ 
+ A goroutine is a lightweight thread managed by Go's runtime. Think of it as a Task that's:
+ 
+ - **Cheaper**: Goroutines start with ~2KB stack (vs ~1MB for OS threads)
+ - **Multiplexed**: Go's scheduler runs thousands of goroutines on a few OS threads
+ - **Implicit**: No &#96;Task.Run()&#96; ceremony—just &#96;go f()&#96;
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     for i := 0; i &lt; 10000; i++ {
+         go func(n int) {
+             fmt.Println(n)
+         }(i)
+     }
+     time.Sleep(time.Second)  // wait for goroutines (crude, we'll fix this)
+ }
+ &#96;&#96;&#96;
+ 
+ Spawning 10,000 goroutines is fine. Spawning 10,000 OS threads would kill your machine.
+ 
+ ## The Problem: Getting Results Back
+ 
+ Here's where things get interesting. When you &#96;go&#96; a function, you can't get its return value:
+ 
+ &#96;&#96;&#96;go
+ result := go GetUser(1)  // DOESN'T WORK - go doesn't return anything
+ &#96;&#96;&#96;
+ 
+ The &#96;go&#96; keyword fires and forgets. If you need results, you need **channels**—which we'll cover properly in the next post. For now, here's a taste:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     results := make(chan *User, 2)
+     
+     go func() {
+         user, _ := GetUser(1)
+         results &lt;- user
+     }()
+     
+     go func() {
+         user, _ := GetUser(2)
+         results &lt;- user
+     }()
+     
+     user1 := &lt;-results
+     user2 := &lt;-results
+     fmt.Println(user1, user2)
+ }
+ &#96;&#96;&#96;
+ 
+ More verbose than &#96;Task.WhenAll&#96;? Yes. More flexible? Also yes. But we're getting ahead of ourselves.
+ 
+ ## No Coloured Functions
+ 
+ This is the big philosophical difference. In C#, functions are "coloured":
+ 
+ - **Red functions** (&#96;async&#96;): Can use &#96;await&#96;, return &#96;Task&lt;T&gt;&#96;
+ - **Blue functions** (sync): Can't use &#96;await&#96;, return &#96;T&#96; directly
+ - Red can call blue, but blue calling red is awkward
+ 
+ This leads to the "async all the way down" pattern. One async function at the bottom of your call stack, and suddenly everything above it needs to be async too.
+ 
+ Go doesn't have coloured functions. Every function is the same colour:
+ 
+ &#96;&#96;&#96;go
+ // These are identical in signature
+ func DoSyncThing() error { ... }
+ func DoAsyncThing() error { ... }  // might internally use goroutines
+ 
+ // Caller doesn't know or care
+ err := DoSyncThing()
+ err = DoAsyncThing()
+ &#96;&#96;&#96;
+ 
+ The caller decides whether to run something concurrently:
+ 
+ &#96;&#96;&#96;go
+ DoSyncThing()      // blocking
+ go DoSyncThing()   // concurrent
+ 
+ DoAsyncThing()     // blocking (waits for internal goroutines)
+ go DoAsyncThing()  // concurrent
+ &#96;&#96;&#96;
+ 
+ ## Blocking Is Fine
+ 
+ In C#, blocking an async operation is a code smell:
+ 
+ &#96;&#96;&#96;csharp
+ // DON'T DO THIS - can deadlock, wastes threads
+ var result = GetUserAsync(1).Result;
+ &#96;&#96;&#96;
+ 
+ In Go, blocking is the default and it's fine:
+ 
+ &#96;&#96;&#96;go
+ // Totally normal
+ user, err := GetUser(1)
+ &#96;&#96;&#96;
+ 
+ Why? Because Go's scheduler is cooperative. When a goroutine blocks on I/O, the scheduler runs other goroutines on the same OS thread. You're not tying up a thread pool thread—you're just pausing one goroutine.
+ 
+ This is why Go doesn't need async/await. Blocking calls don't waste resources because the runtime handles the multiplexing.
+ 
+ ## When This Feels Better
+ 
+ **Simple concurrent operations:**
+ 
+ &#96;&#96;&#96;go
+ // Go
+ go sendEmail(user)
+ go updateAnalytics(event)
+ go notifySlack(message)
+ // All three run concurrently, fire-and-forget
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;csharp
+ // C# equivalent
+ _ = Task.Run(() =&gt; SendEmailAsync(user));
+ _ = Task.Run(() =&gt; UpdateAnalyticsAsync(event));
+ _ = Task.Run(() =&gt; NotifySlackAsync(message));
+ // More ceremony, and those discards feel wrong
+ &#96;&#96;&#96;
+ 
+ **CPU-bound parallelism:**
+ 
+ &#96;&#96;&#96;go
+ // Go
+ for _, item := range items {
+     go process(item)
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ Parallel.ForEach(items, item =&gt; Process(item));
+ // Or
+ await Task.WhenAll(items.Select(item =&gt; ProcessAsync(item)));
+ &#96;&#96;&#96;
+ 
+ Both work, but Go's is more uniform—same syntax for I/O-bound and CPU-bound concurrency.
+ 
+ ## When C# Feels Better
+ 
+ **Structured async flow:**
+ 
+ &#96;&#96;&#96;csharp
+ var user = await GetUserAsync(id);
+ var orders = await GetOrdersAsync(user.Id);
+ var summary = await BuildSummaryAsync(user, orders);
+ return summary;
+ &#96;&#96;&#96;
+ 
+ This sequential async flow is clean in C#. In Go, you'd write the same thing without any special syntax—which is fine, but you don't get the visual markers of "this is I/O."
+ 
+ **Parallel with results:**
+ 
+ &#96;&#96;&#96;csharp
+ var tasks = ids.Select(id =&gt; GetUserAsync(id));
+ var users = await Task.WhenAll(tasks);
+ &#96;&#96;&#96;
+ 
+ Go requires more scaffolding for this pattern (channels, WaitGroups). We'll cover it, but it's more code.
+ 
+ **Cancellation:**
+ 
+ C#'s &#96;CancellationToken&#96; integrates beautifully with async/await. Go's &#96;context.Context&#96; is similar but more manual. We'll cover this in a later post.
+ 
+ ## The Mental Shift
+ 
+ Here's what took me time to internalise:
+ 
+ 1. **Functions don't need to declare their concurrency potential**. Any function can be &#96;go&#96;'d.
+ 
+ 2. **Blocking is fine**. The scheduler handles it. Stop feeling guilty about synchronous calls.
+ 
+ 3. **Concurrency is at the call site, not the definition**. You decide whether to wait or fire-and-forget when you call, not when you write the function.
+ 
+ 4. **Communication replaces shared state**. Instead of returning values, goroutines send results through channels.
+ 
+ 5. **No thread pool to configure**. GOMAXPROCS controls parallelism. The scheduler does the rest.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# async/await | Go goroutines |
+ |--------|---------------|---------------|
+ | Syntax | &#96;async&#96;/&#96;await&#96; keywords | &#96;go&#96; keyword |
+ | Return values | &#96;Task&lt;T&gt;&#96; | Channels |
+ | Function colouring | Yes (async vs sync) | No |
+ | Blocking | Discouraged | Normal |
+ | Cancellation | &#96;CancellationToken&#96; | &#96;context.Context&#96; |
+ | Thread model | Thread pool | M:N scheduling |
+ | Overhead | ~300 bytes per Task | ~2KB per goroutine |
+ | Debugging | Excellent tooling | Good, improving |
+ 
+ ## The Honest Take
+ 
+ Go's concurrency model is simpler to start with and scales well. The lack of function colouring is genuinely liberating—no more "async virus" infecting your codebase.
+ 
+ But C#'s model is more explicit about what's happening. When you see &#96;await&#96;, you know there's a potential suspension point. In Go, any function call might block, and that's... fine, but less visible.
+ 
+ **What Go does better:**
+ - No function colouring
+ - Lightweight goroutines (spawn thousands easily)
+ - Blocking is natural, not wasteful
+ - Uniform syntax for all concurrency
+ 
+ **What C# does better:**
+ - Explicit suspension points
+ - &#96;Task.WhenAll&#96; for collecting results
+ - Better tooling and debugging
+ - Clearer error propagation in async flows
+ 
+ Neither is objectively better. They're different philosophies. Go says "concurrency should be easy, let the runtime handle scheduling." C# says "concurrency should be explicit, let the developer see what's happening."
+ 
+ ---
+ 
+ *Next up: channels—Go's answer to BlockingCollection, and the primary way goroutines communicate.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-channels.md</summary>

**Chunk 1**
Lines added: 341, lines removed: 1

```diff
@@ -1,1 +1,341 @@
- 
+ +++
+ title = "Channels: The sync You Didn't Know You Wanted"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "channels", "csharp"]
+ +++
+ 
+ If goroutines are Go's lightweight threads, channels are how they talk to each other. Think &#96;BlockingCollection&lt;T&gt;&#96; meets message passing, with first-class language support.
+ 
+ The Go mantra is: **"Don't communicate by sharing memory; share memory by communicating."** Channels are how you do that.
+ 
+ ## The Basics
+ 
+ A channel is a typed conduit for sending and receiving values:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)  // unbuffered channel of ints
+ 
+ // Send (blocks until someone receives)
+ ch &lt;- 42
+ 
+ // Receive (blocks until someone sends)
+ value := &lt;-ch
+ &#96;&#96;&#96;
+ 
+ The &#96;&lt;-&#96; operator does both sending and receiving—the arrow points in the direction of data flow.
+ 
+ ## Buffered vs Unbuffered
+ 
+ **Unbuffered channels** synchronise sender and receiver:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)  // unbuffered
+ 
+ go func() {
+     ch &lt;- 1  // blocks here until main receives
+     fmt.Println("sent")
+ }()
+ 
+ time.Sleep(time.Second)
+ fmt.Println(&lt;-ch)  // "sent" prints after this line
+ &#96;&#96;&#96;
+ 
+ The sender blocks until the receiver is ready. This creates a synchronisation point—a "handshake" between goroutines.
+ 
+ **Buffered channels** have capacity:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int, 3)  // buffer of 3
+ 
+ ch &lt;- 1  // doesn't block
+ ch &lt;- 2  // doesn't block
+ ch &lt;- 3  // doesn't block
+ ch &lt;- 4  // NOW it blocks - buffer full
+ &#96;&#96;&#96;
+ 
+ Sends only block when the buffer is full. Receives only block when the buffer is empty.
+ 
+ ## The C# Comparison: BlockingCollection
+ 
+ C#'s closest equivalent is &#96;BlockingCollection&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ var collection = new BlockingCollection&lt;int&gt;(boundedCapacity: 3);
+ 
+ // Producer
+ Task.Run(() =&gt; {
+     collection.Add(1);
+     collection.Add(2);
+     collection.CompleteAdding();
+ });
+ 
+ // Consumer
+ foreach (var item in collection.GetConsumingEnumerable())
+ {
+     Console.WriteLine(item);
+ }
+ &#96;&#96;&#96;
+ 
+ Go's version:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int, 3)
+ 
+ // Producer
+ go func() {
+     ch &lt;- 1
+     ch &lt;- 2
+     close(ch)
+ }()
+ 
+ // Consumer
+ for item := range ch {
+     fmt.Println(item)
+ }
+ &#96;&#96;&#96;
+ 
+ Similar pattern, but channels are built into the language. No &#96;using System.Collections.Concurrent&#96;, no &#96;GetConsumingEnumerable()&#96;. Just &#96;range&#96; over the channel.
+ 
+ ## Closing Channels
+ 
+ Closing a channel signals "no more values coming":
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ 
+ go func() {
+     ch &lt;- 1
+     ch &lt;- 2
+     close(ch)  // signal completion
+ }()
+ 
+ for v := range ch {
+     fmt.Println(v)  // prints 1, then 2, then loop exits
+ }
+ &#96;&#96;&#96;
+ 
+ Important rules:
+ 
+ - Only senders should close channels (receivers don't know when senders are done)
+ - Sending on a closed channel panics
+ - Receiving from a closed channel returns the zero value immediately
+ - You can check if a channel is closed: &#96;v, ok := &lt;-ch&#96; (ok is false if closed)
+ 
+ &#96;&#96;&#96;go
+ v, ok := &lt;-ch
+ if !ok {
+     fmt.Println("channel closed")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Common Patterns
+ 
+ ### Fan-Out: One Producer, Many Consumers
+ 
+ &#96;&#96;&#96;go
+ func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
+     for job := range jobs {
+         results &lt;- job * 2  // process and send result
+     }
+ }
+ 
+ func main() {
+     jobs := make(chan int, 100)
+     results := make(chan int, 100)
+ 
+     // Start 3 workers
+     for w := 1; w &lt;= 3; w++ {
+         go worker(w, jobs, results)
+     }
+ 
+     // Send jobs
+     for j := 1; j &lt;= 9; j++ {
+         jobs &lt;- j
+     }
+     close(jobs)
+ 
+     // Collect results
+     for r := 1; r &lt;= 9; r++ {
+         fmt.Println(&lt;-results)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Notice the channel direction syntax:
+ - &#96;jobs &lt;-chan int&#96; — receive-only channel
+ - &#96;results chan&lt;- int&#96; — send-only channel
+ 
+ This prevents workers from accidentally closing &#96;jobs&#96; or reading from &#96;results&#96;.
+ 
+ ### Fan-In: Many Producers, One Consumer
+ 
+ &#96;&#96;&#96;go
+ func producer(id int, ch chan&lt;- string) {
+     for i := 0; i &lt; 3; i++ {
+         ch &lt;- fmt.Sprintf("producer %d: message %d", id, i)
+     }
+ }
+ 
+ func main() {
+     ch := make(chan string)
+ 
+     go producer(1, ch)
+     go producer(2, ch)
+     go producer(3, ch)
+ 
+     for i := 0; i &lt; 9; i++ {
+         fmt.Println(&lt;-ch)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Multiple producers send to one channel. The consumer receives interleaved messages.
+ 
+ ### Pipeline: Chain of Transformations
+ 
+ &#96;&#96;&#96;go
+ func generate(nums ...int) &lt;-chan int {
+     out := make(chan int)
+     go func() {
+         for _, n := range nums {
+             out &lt;- n
+         }
+         close(out)
+     }()
+     return out
+ }
+ 
+ func square(in &lt;-chan int) &lt;-chan int {
+     out := make(chan int)
+     go func() {
+         for n := range in {
+             out &lt;- n * n
+         }
+         close(out)
+     }()
+     return out
+ }
+ 
+ func main() {
+     // Pipeline: generate -&gt; square -&gt; print
+     for n := range square(generate(1, 2, 3, 4)) {
+         fmt.Println(n)  // 1, 4, 9, 16
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Each stage runs in its own goroutine. Data flows through channels. This is remarkably similar to LINQ or Rx, but with explicit concurrency.
+ 
+ ## Getting Results from Multiple Goroutines
+ 
+ Remember the "fire and forget" problem with goroutines? Channels solve it:
+ 
+ &#96;&#96;&#96;go
+ func fetchUser(id int, ch chan&lt;- *User) {
+     user, _ := getUser(id)  // simplified error handling
+     ch &lt;- user
+ }
+ 
+ func main() {
+     ch := make(chan *User, 2)
+     
+     go fetchUser(1, ch)
+     go fetchUser(2, ch)
+     
+     user1 := &lt;-ch
+     user2 := &lt;-ch
+     
+     fmt.Println(user1, user2)
+ }
+ &#96;&#96;&#96;
+ 
+ This is Go's answer to &#96;Task.WhenAll&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ var users = await Task.WhenAll(GetUserAsync(1), GetUserAsync(2));
+ &#96;&#96;&#96;
+ 
+ Go's version is more verbose, but gives you control over how results are collected.
+ 
+ ## Error Handling with Channels
+ 
+ Channels carry one type. If you need values and errors, use a struct:
+ 
+ &#96;&#96;&#96;go
+ type Result struct {
+     User  *User
+     Error error
+ }
+ 
+ func fetchUser(id int, ch chan&lt;- Result) {
+     user, err := getUser(id)
+     ch &lt;- Result{User: user, Error: err}
+ }
+ 
+ func main() {
+     ch := make(chan Result, 2)
+     
+     go fetchUser(1, ch)
+     go fetchUser(2, ch)
+     
+     for i := 0; i &lt; 2; i++ {
+         result := &lt;-ch
+         if result.Error != nil {
+             fmt.Println("error:", result.Error)
+             continue
+         }
+         fmt.Println("user:", result.User)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Clunkier than C#'s exception propagation through Tasks, but explicit.
+ 
+ ## When Channels Are the Wrong Tool
+ 
+ Channels aren't always the answer:
+ 
+ - **Simple mutex protection**: If you just need to guard a shared variable, &#96;sync.Mutex&#96; is simpler
+ - **Reference counting**: Use &#96;sync.WaitGroup&#96;
+ - **One-time events**: Use &#96;sync.Once&#96;
+ - **Atomic counters**: Use &#96;sync/atomic&#96;
+ 
+ Go's proverb is "share memory by communicating," but sometimes sharing memory with a mutex is fine. We'll cover when in a later post.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# BlockingCollection | Go Channels |
+ |--------|----------------------|-------------|
+ | Syntax | Library type | Language primitive |
+ | Bounded | Yes (constructor) | Yes (make with size) |
+ | Direction typing | No | Yes (&#96;&lt;-chan&#96;, &#96;chan&lt;-&#96;) |
+ | Closing | &#96;CompleteAdding()&#96; | &#96;close()&#96; |
+ | Iteration | &#96;GetConsumingEnumerable()&#96; | &#96;range&#96; |
+ | Multiple consumers | Manual coordination | Built-in fair scheduling |
+ | Select/multiplex | No direct equivalent | &#96;select&#96; statement |
+ 
+ ## The Honest Take
+ 
+ Channels are genuinely elegant. They're built into the language, they compose well, and they make producer-consumer patterns trivial.
+ 
+ **What Go does better:**
+ - First-class language support
+ - Direction typing prevents bugs
+ - &#96;select&#96; for multiplexing (next post)
+ - Clean iteration with &#96;range&#96;
+ 
+ **What C# does better:**
+ - Easier result collection with &#96;Task.WhenAll&#96;
+ - Exception propagation through task chains
+ - More familiar for developers from OOP backgrounds
+ - &#96;Channel&lt;T&gt;&#96; in .NET Core is actually quite nice
+ 
+ **The verdict:**
+ If you're doing producer-consumer, pipelines, or fan-out/fan-in patterns, channels are delightful. If you're doing request-response where you need a result back, they're more ceremony than &#96;await&#96;.
+ 
+ ---
+ 
+ *Next up: the &#96;select&#96; statement—multiplexing channels, handling timeouts, and non-blocking operations.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-select.md</summary>

**Chunk 1**
Lines added: 302, lines removed: 1

```diff
@@ -1,1 +1,302 @@
- 
+ +++
+ title = "select: Multiplexing Like a Pro"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "channels", "csharp"]
+ +++
+ 
+ The &#96;select&#96; statement is where Go's channel system goes from "neat" to "powerful." It lets you wait on multiple channel operations simultaneously, handle timeouts, and do non-blocking checks—all with clean syntax.
+ 
+ C# doesn't have a direct equivalent. The closest is &#96;Task.WhenAny&#96;, but &#96;select&#96; is more flexible and more deeply integrated.
+ 
+ ## Basic select
+ 
+ &#96;select&#96; waits on multiple channel operations and executes whichever is ready first:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case msg := &lt;-ch1:
+     fmt.Println("received from ch1:", msg)
+ case msg := &lt;-ch2:
+     fmt.Println("received from ch2:", msg)
+ }
+ &#96;&#96;&#96;
+ 
+ If both channels have data, one is chosen randomly (fair scheduling). If neither has data, &#96;select&#96; blocks until one does.
+ 
+ ## Timeouts
+ 
+ This is where &#96;select&#96; shines. Implementing a timeout:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case result := &lt;-ch:
+     fmt.Println("got result:", result)
+ case &lt;-time.After(3 * time.Second):
+     fmt.Println("timeout!")
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;time.After&#96; returns a channel that receives a value after the duration. If your main channel doesn't deliver in 3 seconds, the timeout case fires.
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ var task = GetResultAsync();
+ var completed = await Task.WhenAny(task, Task.Delay(TimeSpan.FromSeconds(3)));
+ 
+ if (completed == task)
+ {
+     var result = await task;
+     Console.WriteLine($"got result: {result}");
+ }
+ else
+ {
+     Console.WriteLine("timeout!");
+ }
+ &#96;&#96;&#96;
+ 
+ More verbose, and the result handling is awkward.
+ 
+ ## Non-Blocking Operations
+ 
+ Add a &#96;default&#96; case to make &#96;select&#96; non-blocking:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case msg := &lt;-ch:
+     fmt.Println("received:", msg)
+ default:
+     fmt.Println("no message available")
+ }
+ &#96;&#96;&#96;
+ 
+ If no channel is ready, &#96;default&#96; executes immediately. This is how you poll without blocking.
+ 
+ ### Non-Blocking Send
+ 
+ &#96;&#96;&#96;go
+ select {
+ case ch &lt;- msg:
+     fmt.Println("sent")
+ default:
+     fmt.Println("channel full, dropping message")
+ }
+ &#96;&#96;&#96;
+ 
+ Try to send; if the channel is full (or unbuffered with no receiver), execute default instead of blocking.
+ 
+ ## Handling Multiple Sources
+ 
+ Real-world example: a worker that handles requests, ticks, and shutdown signals:
+ 
+ &#96;&#96;&#96;go
+ func worker(requests &lt;-chan Request, done &lt;-chan struct{}) {
+     ticker := time.NewTicker(time.Minute)
+     defer ticker.Stop()
+ 
+     for {
+         select {
+         case req := &lt;-requests:
+             handleRequest(req)
+         case &lt;-ticker.C:
+             doPeriodicWork()
+         case &lt;-done:
+             fmt.Println("shutting down")
+             return
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Three different event sources, one clean loop. In C#, you'd need &#96;Task.WhenAny&#96; with careful task management, or an Rx observable merge.
+ 
+ ## The Empty select
+ 
+ A &#96;select&#96; with no cases blocks forever:
+ 
+ &#96;&#96;&#96;go
+ select {}  // blocks forever
+ &#96;&#96;&#96;
+ 
+ Useful for keeping a main function alive while goroutines do work:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     go server()
+     select {}  // wait forever
+ }
+ &#96;&#96;&#96;
+ 
+ Not common, but occasionally handy.
+ 
+ ## Priority with Nested select
+ 
+ &#96;select&#96; chooses randomly among ready cases. If you need priority, nest them:
+ 
+ &#96;&#96;&#96;go
+ for {
+     // First, drain high priority
+     select {
+     case msg := &lt;-highPriority:
+         handle(msg)
+         continue
+     default:
+     }
+     
+     // Then check both
+     select {
+     case msg := &lt;-highPriority:
+         handle(msg)
+     case msg := &lt;-lowPriority:
+         handle(msg)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The first &#96;select&#96; with &#96;default&#96; is non-blocking—it handles high-priority if available, otherwise falls through. This ensures high-priority messages are processed first.
+ 
+ ## Cancellation Pattern
+ 
+ Using &#96;select&#96; with a done channel for cancellation:
+ 
+ &#96;&#96;&#96;go
+ func doWork(done &lt;-chan struct{}) error {
+     for {
+         select {
+         case &lt;-done:
+             return errors.New("cancelled")
+         default:
+         }
+         
+         // Do a chunk of work
+         if finished := processChunk(); finished {
+             return nil
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Check for cancellation at the top of each iteration. We'll see a better way with &#96;context&#96; later.
+ 
+ ## Collecting Results with Timeout
+ 
+ Common pattern: gather results from multiple goroutines with an overall timeout:
+ 
+ &#96;&#96;&#96;go
+ func fetchAll(urls []string, timeout time.Duration) []Result {
+     results := make(chan Result, len(urls))
+     
+     for _, url := range urls {
+         go func(u string) {
+             resp, err := fetch(u)
+             results &lt;- Result{URL: u, Response: resp, Error: err}
+         }(url)
+     }
+     
+     var collected []Result
+     deadline := time.After(timeout)
+     
+     for i := 0; i &lt; len(urls); i++ {
+         select {
+         case r := &lt;-results:
+             collected = append(collected, r)
+         case &lt;-deadline:
+             return collected  // return what we have
+         }
+     }
+     
+     return collected
+ }
+ &#96;&#96;&#96;
+ 
+ We get as many results as complete before the timeout, then return whatever we have.
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ async Task&lt;List&lt;Result&gt;&gt; FetchAll(string[] urls, TimeSpan timeout)
+ {
+     var cts = new CancellationTokenSource(timeout);
+     var tasks = urls.Select(url =&gt; FetchAsync(url, cts.Token));
+     
+     try
+     {
+         return (await Task.WhenAll(tasks)).ToList();
+     }
+     catch (OperationCanceledException)
+     {
+         // WhenAll throws if any task cancels - harder to get partial results
+         return tasks
+             .Where(t =&gt; t.IsCompletedSuccessfully)
+             .Select(t =&gt; t.Result)
+             .ToList();
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The C# version is more awkward for partial results because &#96;Task.WhenAll&#96; is all-or-nothing.
+ 
+ ## select with Send and Receive
+ 
+ You can mix sends and receives in one select:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case ch1 &lt;- value:
+     fmt.Println("sent to ch1")
+ case msg := &lt;-ch2:
+     fmt.Println("received from ch2:", msg)
+ }
+ &#96;&#96;&#96;
+ 
+ Whichever operation can proceed, does. Useful for bidirectional communication.
+ 
+ ## The C# Comparison
+ 
+ | Go select | C# Equivalent | Notes |
+ |-----------|---------------|-------|
+ | &#96;select&#96; on multiple channels | &#96;Task.WhenAny&#96; | Less elegant syntax |
+ | Timeout with &#96;time.After&#96; | &#96;Task.WhenAny&#96; + &#96;Task.Delay&#96; | More verbose |
+ | Non-blocking with &#96;default&#96; | &#96;Task.IsCompleted&#96; check | Manual polling |
+ | Empty &#96;select {}&#96; | &#96;Task.Delay(Timeout.Infinite)&#96; | Rare in both |
+ | Priority handling | Manual with loops | No direct equivalent |
+ 
+ C# has &#96;System.Threading.Channels&#96; which gets closer:
+ 
+ &#96;&#96;&#96;csharp
+ var reader = channel.Reader;
+ while (await reader.WaitToReadAsync())
+ {
+     while (reader.TryRead(out var item))
+     {
+         Process(item);
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ But multiplexing multiple channels still requires &#96;Task.WhenAny&#96; gymnastics.
+ 
+ ## The Honest Take
+ 
+ &#96;select&#96; is one of Go's genuinely great features. It makes patterns that are awkward in other languages—timeouts, multiplexing, non-blocking checks—into one clean construct.
+ 
+ **What Go does better:**
+ - Clean syntax for multiplexing
+ - Timeouts are trivial
+ - Non-blocking operations with &#96;default&#96;
+ - Fair random selection among ready cases
+ - First-class language support
+ 
+ **What C# does better:**
+ - &#96;Task.WhenAll&#96; for collecting all results
+ - Better exception propagation
+ - Richer LINQ-style composition with Rx
+ 
+ **The verdict:**
+ If you're doing event-loop style programming—handling messages from multiple sources, implementing timeouts, coordinating shutdown—&#96;select&#96; is wonderful. It's one of those features you miss when you go back to languages without it.
+ 
+ ---
+ 
+ *Next up: mutexes and WaitGroups—because sometimes shared memory with locks is simpler than channels.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-sync.md</summary>

**Chunk 1**
Lines added: 381, lines removed: 1

```diff
@@ -1,1 +1,381 @@
- 
+ +++
+ title = "Mutexes and WaitGroups: When Channels Aren't the Answer"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "sync", "csharp"]
+ +++
+ 
+ Go's mantra is "share memory by communicating," but sometimes you just need a bloody mutex. The &#96;sync&#96; package has all the primitives you know from C#, and knowing when to use them vs channels is part of becoming proficient in Go.
+ 
+ ## sync.Mutex
+ 
+ The classic lock:
+ 
+ &#96;&#96;&#96;go
+ type Counter struct {
+     mu    sync.Mutex
+     value int
+ }
+ 
+ func (c *Counter) Increment() {
+     c.mu.Lock()
+     defer c.mu.Unlock()
+     c.value++
+ }
+ 
+ func (c *Counter) Value() int {
+     c.mu.Lock()
+     defer c.mu.Unlock()
+     return c.value
+ }
+ &#96;&#96;&#96;
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public class Counter
+ {
+     private readonly object _lock = new();
+     private int _value;
+     
+     public void Increment()
+     {
+         lock (_lock) { _value++; }
+     }
+     
+     public int Value
+     {
+         get { lock (_lock) { return _value; } }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Pretty similar. Go doesn't have a &#96;lock&#96; keyword, so you explicitly call &#96;Lock()&#96; and &#96;Unlock()&#96;. The &#96;defer&#96; ensures unlock even if the code panics.
+ 
+ ### RWMutex for Read-Heavy Workloads
+ 
+ When you have many readers and few writers:
+ 
+ &#96;&#96;&#96;go
+ type Cache struct {
+     mu    sync.RWMutex
+     items map[string]string
+ }
+ 
+ func (c *Cache) Get(key string) (string, bool) {
+     c.mu.RLock()         // read lock - multiple readers allowed
+     defer c.mu.RUnlock()
+     val, ok := c.items[key]
+     return val, ok
+ }
+ 
+ func (c *Cache) Set(key, value string) {
+     c.mu.Lock()          // write lock - exclusive
+     defer c.mu.Unlock()
+     c.items[key] = value
+ }
+ &#96;&#96;&#96;
+ 
+ Equivalent to &#96;ReaderWriterLockSlim&#96; in C#.
+ 
+ ## sync.WaitGroup
+ 
+ This is what you reach for when you need to wait for multiple goroutines to complete:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     var wg sync.WaitGroup
+     
+     for i := 0; i &lt; 5; i++ {
+         wg.Add(1)
+         go func(n int) {
+             defer wg.Done()
+             doWork(n)
+         }(i)
+     }
+     
+     wg.Wait()  // blocks until all Done() calls
+     fmt.Println("all done")
+ }
+ &#96;&#96;&#96;
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ var tasks = Enumerable.Range(0, 5)
+     .Select(n =&gt; Task.Run(() =&gt; DoWork(n)))
+     .ToArray();
+ 
+ await Task.WhenAll(tasks);
+ Console.WriteLine("all done");
+ &#96;&#96;&#96;
+ 
+ C#'s version is more concise. Go's is more explicit about the counting.
+ 
+ ### Common WaitGroup Mistakes
+ 
+ &#96;&#96;&#96;go
+ // WRONG: Add inside goroutine - race condition
+ for i := 0; i &lt; 5; i++ {
+     go func(n int) {
+         wg.Add(1)  // too late! main might call Wait() first
+         defer wg.Done()
+         doWork(n)
+     }(i)
+ }
+ 
+ // CORRECT: Add before starting goroutine
+ for i := 0; i &lt; 5; i++ {
+     wg.Add(1)
+     go func(n int) {
+         defer wg.Done()
+         doWork(n)
+     }(i)
+ }
+ &#96;&#96;&#96;
+ 
+ Always &#96;Add&#96; before &#96;go&#96;, never inside the goroutine.
+ 
+ ## sync.Once
+ 
+ Execute something exactly once, regardless of how many goroutines try:
+ 
+ &#96;&#96;&#96;go
+ var (
+     instance *Database
+     once     sync.Once
+ )
+ 
+ func GetDatabase() *Database {
+     once.Do(func() {
+         instance = connectToDatabase()
+     })
+     return instance
+ }
+ &#96;&#96;&#96;
+ 
+ C# equivalent with &#96;Lazy&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ private static readonly Lazy&lt;Database&gt; _instance = 
+     new(() =&gt; ConnectToDatabase());
+ 
+ public static Database GetDatabase() =&gt; _instance.Value;
+ &#96;&#96;&#96;
+ 
+ Or with double-checked locking... which is why &#96;Lazy&lt;T&gt;&#96; exists.
+ 
+ ## sync.Cond
+ 
+ Condition variables for signaling between goroutines:
+ 
+ &#96;&#96;&#96;go
+ type Queue struct {
+     items []int
+     cond  *sync.Cond
+ }
+ 
+ func NewQueue() *Queue {
+     return &amp;Queue{
+         cond: sync.NewCond(&amp;sync.Mutex{}),
+     }
+ }
+ 
+ func (q *Queue) Put(item int) {
+     q.cond.L.Lock()
+     defer q.cond.L.Unlock()
+     
+     q.items = append(q.items, item)
+     q.cond.Signal()  // wake one waiting goroutine
+ }
+ 
+ func (q *Queue) Get() int {
+     q.cond.L.Lock()
+     defer q.cond.L.Unlock()
+     
+     for len(q.items) == 0 {
+         q.cond.Wait()  // releases lock, waits, reacquires lock
+     }
+     
+     item := q.items[0]
+     q.items = q.items[1:]
+     return item
+ }
+ &#96;&#96;&#96;
+ 
+ Honestly? For this pattern, channels are cleaner:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ ch &lt;- item      // put
+ item := &lt;-ch    // get
+ &#96;&#96;&#96;
+ 
+ &#96;sync.Cond&#96; exists for complex scenarios where channels don't fit, but I rarely use it.
+ 
+ ## sync.Pool
+ 
+ Object pool for reducing allocations:
+ 
+ &#96;&#96;&#96;go
+ var bufferPool = sync.Pool{
+     New: func() interface{} {
+         return make([]byte, 4096)
+     },
+ }
+ 
+ func process() {
+     buf := bufferPool.Get().([]byte)
+     defer bufferPool.Put(buf)
+     
+     // use buf...
+ }
+ &#96;&#96;&#96;
+ 
+ C# has &#96;ArrayPool&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ var buffer = ArrayPool&lt;byte&gt;.Shared.Rent(4096);
+ try
+ {
+     // use buffer...
+ }
+ finally
+ {
+     ArrayPool&lt;byte&gt;.Shared.Return(buffer);
+ }
+ &#96;&#96;&#96;
+ 
+ Similar idea. Pool objects to avoid allocation pressure.
+ 
+ ## sync/atomic
+ 
+ For simple counters and flags, atomics are faster than mutexes:
+ 
+ &#96;&#96;&#96;go
+ var counter int64
+ 
+ func Increment() {
+     atomic.AddInt64(&amp;counter, 1)
+ }
+ 
+ func Value() int64 {
+     return atomic.LoadInt64(&amp;counter)
+ }
+ &#96;&#96;&#96;
+ 
+ C#:
+ 
+ &#96;&#96;&#96;csharp
+ private long _counter;
+ 
+ public void Increment() =&gt; Interlocked.Increment(ref _counter);
+ public long Value =&gt; Interlocked.Read(ref _counter);
+ &#96;&#96;&#96;
+ 
+ Same primitives, different names.
+ 
+ ## Channels vs Mutexes: When to Choose
+ 
+ **Use channels when:**
+ - Passing ownership of data between goroutines
+ - Coordinating multiple goroutines
+ - Building pipelines
+ - Signaling events
+ 
+ **Use mutexes when:**
+ - Protecting simple shared state (counters, caches)
+ - The "critical section" is obvious
+ - You don't need to transfer data, just guard it
+ - Performance matters and channels add overhead
+ 
+ **The rule of thumb:**
+ If you're passing data, use channels. If you're guarding data, use mutexes.
+ 
+ &#96;&#96;&#96;go
+ // Channel: transferring data ownership
+ workQueue := make(chan Job)
+ go worker(workQueue)
+ workQueue &lt;- newJob  // worker now "owns" this job
+ 
+ // Mutex: guarding shared state
+ type Metrics struct {
+     mu     sync.Mutex
+     counts map[string]int
+ }
+ 
+ func (m *Metrics) Inc(key string) {
+     m.mu.Lock()
+     m.counts[key]++
+     m.mu.Unlock()
+ }
+ &#96;&#96;&#96;
+ 
+ ## The map Concurrency Problem
+ 
+ Maps are not concurrency-safe in Go:
+ 
+ &#96;&#96;&#96;go
+ m := make(map[string]int)
+ 
+ go func() { m["a"] = 1 }()
+ go func() { m["b"] = 2 }()
+ // RACE CONDITION - might corrupt the map or panic
+ &#96;&#96;&#96;
+ 
+ You need either:
+ 
+ **Option 1: Mutex**
+ &#96;&#96;&#96;go
+ type SafeMap struct {
+     mu sync.RWMutex
+     m  map[string]int
+ }
+ &#96;&#96;&#96;
+ 
+ **Option 2: sync.Map**
+ &#96;&#96;&#96;go
+ var m sync.Map
+ m.Store("key", value)
+ val, ok := m.Load("key")
+ &#96;&#96;&#96;
+ 
+ &#96;sync.Map&#96; is optimised for specific patterns (keys written once, read many times). For general use, a mutex-protected map is often simpler.
+ 
+ ## The Comparison
+ 
+ | C# | Go | Notes |
+ |-----|-----|-------|
+ | &#96;lock&#96; | &#96;sync.Mutex&#96; | Manual Lock/Unlock |
+ | &#96;ReaderWriterLockSlim&#96; | &#96;sync.RWMutex&#96; | Same concept |
+ | &#96;Task.WhenAll&#96; | &#96;sync.WaitGroup&#96; | Go is more verbose |
+ | &#96;Lazy&lt;T&gt;&#96; | &#96;sync.Once&#96; | Same purpose |
+ | &#96;Monitor.Wait/Pulse&#96; | &#96;sync.Cond&#96; | Rarely needed |
+ | &#96;ConcurrentDictionary&#96; | &#96;sync.Map&#96; | Different optimisations |
+ | &#96;ArrayPool&lt;T&gt;&#96; | &#96;sync.Pool&#96; | Similar |
+ | &#96;Interlocked&#96; | &#96;sync/atomic&#96; | Same primitives |
+ 
+ ## The Honest Take
+ 
+ Go's sync package is perfectly adequate. Nothing here will surprise a C# developer who knows their threading primitives.
+ 
+ **What Go does well:**
+ - Clean, minimal API
+ - &#96;defer&#96; makes unlock reliable
+ - WaitGroup is explicit about what you're waiting for
+ 
+ **What C# does better:**
+ - &#96;lock&#96; keyword is more concise than Lock/Unlock
+ - &#96;Task.WhenAll&#96; is cleaner than WaitGroup
+ - &#96;ConcurrentDictionary&#96; has more features than &#96;sync.Map&#96;
+ - Overall better tooling for concurrency debugging
+ 
+ **The verdict:**
+ These primitives work fine. You'll miss &#96;lock&#96; syntax occasionally. You'll miss &#96;Task.WhenAll&#96;'s elegance frequently. But you'll be productive.
+ 
+ The more interesting question is channels vs mutexes. Go developers sometimes over-use channels when a mutex would be simpler. Don't cargo-cult "share by communicating" when a simple lock does the job.
+ 
+ ---
+ 
+ *Next up: context.Context—Go's answer to CancellationToken, and arguably one of the most important patterns in Go.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-context.md</summary>

**Chunk 1**
Lines added: 334, lines removed: 1

```diff
@@ -1,1 +1,334 @@
- 
+ +++
+ title = "Context Is King"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "context", "csharp"]
+ +++
+ 
+ Every Go function that does I/O, might take a while, or should be cancellable will take a &#96;context.Context&#96; as its first parameter. It's Go's answer to &#96;CancellationToken&#96;, plus request-scoped values, all in one.
+ 
+ If you're not using context properly, you're not writing idiomatic Go. It's that fundamental.
+ 
+ ## The Basics
+ 
+ &#96;&#96;&#96;go
+ func DoSomething(ctx context.Context) error {
+     // Check if already cancelled
+     select {
+     case &lt;-ctx.Done():
+         return ctx.Err()
+     default:
+     }
+     
+     // Do work...
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Every context has a &#96;Done()&#96; channel that closes when the context is cancelled. You check it periodically during long operations.
+ 
+ ## Creating Contexts
+ 
+ Start with a background or TODO context:
+ 
+ &#96;&#96;&#96;go
+ ctx := context.Background()  // root context, never cancelled
+ ctx := context.TODO()        // placeholder when you're not sure what context to use
+ &#96;&#96;&#96;
+ 
+ Then derive child contexts with cancellation or deadlines:
+ 
+ &#96;&#96;&#96;go
+ // Manual cancellation
+ ctx, cancel := context.WithCancel(parentCtx)
+ defer cancel()  // always call cancel to release resources
+ 
+ // Timeout
+ ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
+ defer cancel()
+ 
+ // Deadline (absolute time)
+ ctx, cancel := context.WithDeadline(parentCtx, time.Now().Add(5*time.Second))
+ defer cancel()
+ &#96;&#96;&#96;
+ 
+ When you cancel a context, all contexts derived from it are also cancelled. It's a tree.
+ 
+ ## The C# Comparison
+ 
+ C#'s &#96;CancellationToken&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ public async Task DoSomethingAsync(CancellationToken ct)
+ {
+     ct.ThrowIfCancellationRequested();
+     
+     // Do work...
+ }
+ 
+ // Usage
+ var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
+ await DoSomethingAsync(cts.Token);
+ &#96;&#96;&#96;
+ 
+ Similar concepts:
+ 
+ | Go | C# |
+ |-----|-----|
+ | &#96;context.Context&#96; | &#96;CancellationToken&#96; |
+ | &#96;context.WithCancel&#96; | &#96;new CancellationTokenSource()&#96; |
+ | &#96;context.WithTimeout&#96; | &#96;new CancellationTokenSource(TimeSpan)&#96; |
+ | &#96;ctx.Done()&#96; channel | &#96;token.IsCancellationRequested&#96; |
+ | &#96;ctx.Err()&#96; | &#96;token.ThrowIfCancellationRequested()&#96; |
+ | &#96;context.WithValue&#96; | &#96;AsyncLocal&lt;T&gt;&#96; / HttpContext.Items |
+ 
+ The big difference: Go's context also carries request-scoped values. C# separates cancellation (&#96;CancellationToken&#96;) from request-scoped data (&#96;HttpContext&#96;, &#96;AsyncLocal&lt;T&gt;&#96;, etc.).
+ 
+ ## Context as First Parameter
+ 
+ By convention, context is always the first parameter:
+ 
+ &#96;&#96;&#96;go
+ // CORRECT
+ func GetUser(ctx context.Context, id string) (*User, error)
+ 
+ // WRONG - context should be first
+ func GetUser(id string, ctx context.Context) (*User, error)
+ 
+ // WRONG - don't put context in structs
+ type UserService struct {
+     ctx context.Context  // NO!
+ }
+ &#96;&#96;&#96;
+ 
+ This convention is enforced by linters and universally followed. Don't be creative.
+ 
+ ## Proper Cancellation Checking
+ 
+ In long operations, check for cancellation periodically:
+ 
+ &#96;&#96;&#96;go
+ func ProcessItems(ctx context.Context, items []Item) error {
+     for _, item := range items {
+         // Check at the start of each iteration
+         select {
+         case &lt;-ctx.Done():
+             return ctx.Err()
+         default:
+         }
+         
+         if err := processItem(ctx, item); err != nil {
+             return err
+         }
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ For I/O operations, pass the context through:
+ 
+ &#96;&#96;&#96;go
+ func FetchData(ctx context.Context, url string) ([]byte, error) {
+     req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
+     if err != nil {
+         return nil, err
+     }
+     
+     resp, err := http.DefaultClient.Do(req)
+     if err != nil {
+         return nil, err  // includes context cancellation
+     }
+     defer resp.Body.Close()
+     
+     return io.ReadAll(resp.Body)
+ }
+ &#96;&#96;&#96;
+ 
+ When the context is cancelled, the HTTP request is aborted. Same for database queries, gRPC calls, etc.
+ 
+ ## Context Values
+ 
+ Context can carry request-scoped values:
+ 
+ &#96;&#96;&#96;go
+ type contextKey string
+ 
+ const userIDKey contextKey = "userID"
+ 
+ func WithUserID(ctx context.Context, userID string) context.Context {
+     return context.WithValue(ctx, userIDKey, userID)
+ }
+ 
+ func GetUserID(ctx context.Context) (string, bool) {
+     userID, ok := ctx.Value(userIDKey).(string)
+     return userID, ok
+ }
+ &#96;&#96;&#96;
+ 
+ Use sparingly! Context values should be:
+ - Request-scoped data that transits process boundaries (request IDs, auth tokens)
+ - Not a replacement for function parameters
+ 
+ &#96;&#96;&#96;go
+ // BAD: Using context to avoid passing parameters
+ ctx = context.WithValue(ctx, "db", database)
+ ctx = context.WithValue(ctx, "logger", logger)
+ // Now your function signatures lie about their dependencies
+ 
+ // GOOD: Pass dependencies explicitly, use context for request-scoped data
+ func HandleRequest(ctx context.Context, db *Database, logger *Logger) {
+     requestID := GetRequestID(ctx)  // request-scoped, appropriate
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ ## HTTP Server Context
+ 
+ In HTTP servers, the request carries context:
+ 
+ &#96;&#96;&#96;go
+ func handler(w http.ResponseWriter, r *http.Request) {
+     ctx := r.Context()  // cancelled if client disconnects
+     
+     result, err := doExpensiveOperation(ctx)
+     if err != nil {
+         if errors.Is(err, context.Canceled) {
+             // Client disconnected, don't bother responding
+             return
+         }
+         http.Error(w, err.Error(), 500)
+         return
+     }
+     
+     json.NewEncoder(w).Encode(result)
+ }
+ &#96;&#96;&#96;
+ 
+ The request context is automatically cancelled when:
+ - The client closes the connection
+ - The request times out
+ - The server is shutting down (with proper setup)
+ 
+ ## Timeout Patterns
+ 
+ Setting per-operation timeouts:
+ 
+ &#96;&#96;&#96;go
+ func QueryWithTimeout(ctx context.Context, query string) ([]Row, error) {
+     ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+     defer cancel()
+     
+     return db.QueryContext(ctx, query)
+ }
+ &#96;&#96;&#96;
+ 
+ The timeout is scoped to this operation. If the parent context has a shorter deadline, that wins.
+ 
+ &#96;&#96;&#96;go
+ // Parent has 3 second deadline
+ parentCtx, _ := context.WithTimeout(context.Background(), 3*time.Second)
+ 
+ // Child requests 5 seconds, but will actually timeout at 3
+ childCtx, _ := context.WithTimeout(parentCtx, 5*time.Second)
+ &#96;&#96;&#96;
+ 
+ Child contexts can only be more restrictive than parents, never less.
+ 
+ ## Cancellation Propagation
+ 
+ When you start goroutines, propagate the context:
+ 
+ &#96;&#96;&#96;go
+ func ProcessInParallel(ctx context.Context, items []Item) error {
+     g, ctx := errgroup.WithContext(ctx)  // from golang.org/x/sync/errgroup
+     
+     for _, item := range items {
+         item := item
+         g.Go(func() error {
+             return process(ctx, item)  // same context
+         })
+     }
+     
+     return g.Wait()
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;errgroup&#96; package creates a derived context that cancels when any goroutine returns an error. All other goroutines see the cancellation.
+ 
+ ## Common Mistakes
+ 
+ **Don't store context in structs:**
+ &#96;&#96;&#96;go
+ // WRONG
+ type Worker struct {
+     ctx context.Context
+ }
+ 
+ // RIGHT: pass context to methods
+ func (w *Worker) Do(ctx context.Context) error
+ &#96;&#96;&#96;
+ 
+ **Don't use string keys for context values:**
+ &#96;&#96;&#96;go
+ // WRONG: key collisions possible
+ ctx = context.WithValue(ctx, "userID", id)
+ 
+ // RIGHT: unexported type prevents collisions
+ type contextKey string
+ const userIDKey contextKey = "userID"
+ &#96;&#96;&#96;
+ 
+ **Don't ignore context cancellation:**
+ &#96;&#96;&#96;go
+ // WRONG: ignoring cancellation
+ func slowOperation(ctx context.Context) {
+     time.Sleep(10 * time.Second)  // doesn't respect context
+ }
+ 
+ // RIGHT: check context
+ func slowOperation(ctx context.Context) error {
+     select {
+     case &lt;-time.After(10 * time.Second):
+         return nil
+     case &lt;-ctx.Done():
+         return ctx.Err()
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Aspect | Go context.Context | C# CancellationToken |
+ |--------|-------------------|---------------------|
+ | Cancellation | Yes | Yes |
+ | Timeouts | Yes (WithTimeout) | Yes (CTS constructor) |
+ | Request values | Yes (WithValue) | No (use HttpContext) |
+ | First parameter convention | Always | Often last |
+ | Integrated with I/O | Yes | Yes |
+ | Tree structure | Yes (parent-child) | Yes (linked tokens) |
+ 
+ ## The Honest Take
+ 
+ Context is one of Go's better patterns. It unifies cancellation and request-scoped values into one concept that permeates the ecosystem.
+ 
+ **What Go does well:**
+ - Single abstraction for cancellation + deadlines + values
+ - Universal convention (first parameter)
+ - Clean propagation through call chains
+ - Well integrated with stdlib (http, database/sql, etc.)
+ 
+ **What C# does better:**
+ - Clearer separation of concerns (CancellationToken vs HttpContext)
+ - &#96;CancellationToken&#96; is optional by default (overloads without it)
+ - Easier to add cancellation to existing APIs
+ - Less ceremony for simple cases
+ 
+ **The verdict:**
+ Context feels heavyweight at first—every function needs &#96;ctx context.Context&#96; as its first parameter. But the consistency pays off. You can always cancel. You can always set timeouts. You can always trace request IDs through your system.
+ 
+ Once you're used to it, going back to languages without pervasive cancellation support feels limiting.
+ 
+ ---
+ 
+ *That wraps up the concurrency section. Go's model is different from async/await, but it's powerful and consistent. Goroutines for concurrency, channels for communication, context for cancellation and request-scoping. Learn those three and you've got Go's concurrency story.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      19
---
content/posts/dotnet-to-go-channels.md
content/posts/dotnet-to-go-context.md
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-goroutines.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-select.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-sync.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 19 posts are created and the build is successful. Let me summarize the complete series for the user.</details></think>

---

All 5 concurrency posts done! 19 posts total now. Here's the complete series:

## C# to Go Series (19 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"**
2. **"Goodbye .csproj, Hello go.mod"**
3. **"The Phrasebook: C# Concepts in Go Terms"**

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"**
5. **"Where Did My Properties Go?"**
6. **"Generics: Late to the Party"**
7. **"The Million Dollar Mistake, Differently"**
8. **"No Enums? No Problem (Sort Of)"**

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"**
10. **"Panic and Recover: The Emergency Exit"**
11. **"The switch Statement You Always Wanted"**

### Phase 4: Memory & Pointers
12. **"Pointers Without the Pain"**
13. **"Stack vs Heap: Go's Escape Analysis"**
14. **"Slices Are Not Arrays (And Neither Is List<T>)"**

### Phase 5: Concurrency ← **NEW**
15. **"Async/Await vs Goroutines: A Mindset Shift"** — No function colouring, blocking is fine, the `go` keyword, why it feels backwards then clicks
16. **"Channels: The sync You Didn't Know You Wanted"** — Buffered vs unbuffered, closing, fan-out/fan-in, pipelines, comparison to BlockingCollection
17. **"select: Multiplexing Like a Pro"** — Waiting on multiple channels, timeouts with `time.After`, non-blocking with `default`, the pattern C# doesn't have
18. **"Mutexes and WaitGroups: When Channels Aren't the Answer"** — sync package deep-dive, when to use locks vs channels, the map concurrency problem
19. **"Context Is King"** — Cancellation, timeouts, request-scoped values, the first-parameter convention, why it's everywhere

The concurrency section highlights where Go genuinely shines:
- No async/await virus (no coloured functions)
- `select` is cleaner than `Task.WhenAny` gymnastics
- Goroutines are cheaper than Tasks
- Context unifies cancellation + timeouts + request values

But also acknowledges where C# is better:
- `Task.WhenAll` is more elegant than WaitGroup
- `lock` keyword beats manual Lock/Unlock
- Better debugging tooling
- Clearer separation of concerns

---

_**User (2025-12-30 00:36Z)**_

This is the end of the full phase 1: 

let's go!

Interfaces & Composition

Implicit Interfaces: Scary Then Brilliant — No implements keyword, duck typing done right
Composition Over Inheritance (For Real This Time) — Embedding, delegation, and why you won't miss base classes
The Empty Interface and Type Assertions — interface{}, any, and when you're basically back to object

keep the tone, we're getting a bit more difficult so feel free to be more casual at times

Explain things that are new to dotnet devs, maybe embeddings etc, need some defitnion

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create 3 posts for the Interfaces & Composition section. They want me to:
1. Keep the tone but be more casual at times since it's getting more difficult
2. Explain things that are new to .NET devs, like embedding - give proper definitions

Let me write these posts with good explanations of Go-specific concepts like embedding, implicit interfaces, etc.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-interfaces.md</summary>

**Chunk 1**
Lines added: 250, lines removed: 1

```diff
@@ -1,1 +1,250 @@
- 
+ +++
+ title = "Implicit Interfaces: Scary Then Brilliant"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "interfaces", "csharp"]
+ +++
+ 
+ Here's a sentence that'll make every C# developer uncomfortable: Go interfaces don't require an &#96;implements&#96; keyword. You never explicitly declare that a type implements an interface. If your type has the right methods, it implements the interface. Automatically. Implicitly.
+ 
+ This sounds like chaos. It felt like chaos to me for the first week. Then it clicked, and now C#'s explicit interface declarations feel like unnecessary paperwork.
+ 
+ ## The C# Way: Explicit Declaration
+ 
+ In C#, implementing an interface is a contract you sign explicitly:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IWriter
+ {
+     void Write(byte[] data);
+ }
+ 
+ public class FileWriter : IWriter  // explicit declaration
+ {
+     public void Write(byte[] data)
+     {
+         // write to file
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;: IWriter&#96; is required. Without it, &#96;FileWriter&#96; doesn't implement &#96;IWriter&#96;, even if it has a matching &#96;Write&#96; method. The compiler enforces this contract.
+ 
+ ## The Go Way: Implicit Satisfaction
+ 
+ Go flips this around:
+ 
+ &#96;&#96;&#96;go
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type FileWriter struct {
+     // fields
+ }
+ 
+ func (f *FileWriter) Write(p []byte) (n int, err error) {
+     // write to file
+     return len(p), nil
+ }
+ 
+ // FileWriter now implements Writer. No declaration needed.
+ &#96;&#96;&#96;
+ 
+ There's no &#96;implements Writer&#96; anywhere. The &#96;FileWriter&#96; type has a method &#96;Write(p []byte) (n int, err error)&#96;, which matches the &#96;Writer&#96; interface's signature. Therefore, &#96;FileWriter&#96; implements &#96;Writer&#96;. Done.
+ 
+ This is called **structural typing** or, less formally, **duck typing**: if it walks like a duck and quacks like a duck, it's a duck. If your type has the methods an interface requires, it implements that interface.
+ 
+ ## Why This Is Actually Good
+ 
+ I know, I know. "But how do I know what interfaces my type implements?" "What if I accidentally implement something?" "How do I document my intent?"
+ 
+ Let me address these, because they were my exact objections.
+ 
+ ### You Can Define Interfaces After the Fact
+ 
+ This is the killer feature. In C#, if you want an interface, you design it upfront, or you go back and modify all implementing types when you add one later.
+ 
+ In Go, you can define an interface that existing types already satisfy:
+ 
+ &#96;&#96;&#96;go
+ // You wrote this last month
+ type Database struct { ... }
+ func (db *Database) Query(sql string) ([]Row, error) { ... }
+ func (db *Database) Exec(sql string) error { ... }
+ 
+ // Today you want to test something that uses Database
+ type Querier interface {
+     Query(sql string) ([]Row, error)
+ }
+ 
+ // Database already implements Querier. No changes needed.
+ func ProcessData(q Querier) { ... }
+ &#96;&#96;&#96;
+ 
+ You created a new interface. &#96;Database&#96; implements it without any modification. Your production code doesn't change. Your tests can use a mock &#96;Querier&#96;. Beautiful.
+ 
+ In C#, you'd need to go back and add &#96;: IQuerier&#96; to &#96;Database&#96;. That's a code change, a new commit, potentially a new deployment—all for what should be a refactoring detail.
+ 
+ ### Small Interfaces Are Encouraged
+ 
+ Go's standard library is full of tiny interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ 
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type Closer interface {
+     Close() error
+ }
+ &#96;&#96;&#96;
+ 
+ One method each. Dozens of types implement &#96;Reader&#96;—files, network connections, HTTP response bodies, byte buffers, compression streams. They don't know about each other. They just happen to have a &#96;Read&#96; method.
+ 
+ This leads to highly composable code. Functions take the smallest interface they need:
+ 
+ &#96;&#96;&#96;go
+ func Copy(dst Writer, src Reader) (int64, error)
+ &#96;&#96;&#96;
+ 
+ Anything readable to anything writable. Files to network. Network to memory. Whatever. If it has the methods, it works.
+ 
+ In C#, you'd need &#96;IReadable&#96; and &#96;IWritable&#96; interfaces defined somewhere, and every type would need to explicitly implement them. The friction means you'd probably just use concrete types or create fat interfaces.
+ 
+ ### Accidental Implementation Is Rare
+ 
+ "But what if I accidentally implement an interface I didn't mean to?"
+ 
+ In practice, this almost never happens. Interfaces in Go tend to have method names specific to their purpose. The odds that your &#96;type Banana struct{}&#96; accidentally has a method &#96;func (b Banana) Read(p []byte) (int, error)&#96; are slim.
+ 
+ And if it does? So what? If your banana can be read from, maybe someone will find a creative use for that. The type system isn't going to explode.
+ 
+ ## Checking Interface Satisfaction
+ 
+ If you want to verify at compile time that a type implements an interface, use this pattern:
+ 
+ &#96;&#96;&#96;go
+ var _ Writer = (*FileWriter)(nil)
+ &#96;&#96;&#96;
+ 
+ This declares an anonymous variable of type &#96;Writer&#96; and assigns a nil &#96;*FileWriter&#96; to it. If &#96;*FileWriter&#96; doesn't implement &#96;Writer&#96;, compilation fails.
+ 
+ The variable is discarded (assigned to &#96;_&#96;), so there's no runtime cost. It's purely a compile-time check.
+ 
+ &#96;&#96;&#96;go
+ // In your file, somewhere near the type definition
+ var _ io.Reader = (*MyReader)(nil)
+ var _ io.Writer = (*MyWriter)(nil)
+ var _ http.Handler = (*MyHandler)(nil)
+ &#96;&#96;&#96;
+ 
+ This is the Go equivalent of declaring intent. Use it when the interface implementation is non-obvious or contractually important.
+ 
+ ## Interface Values: Two Components
+ 
+ Here's something C# developers don't think about: an interface value in Go has two components:
+ 
+ 1. **The type**: what concrete type is stored
+ 2. **The value**: the actual data
+ 
+ &#96;&#96;&#96;go
+ var w Writer
+ fmt.Printf("type: %T, value: %v\n", w, w)
+ // type: &lt;nil&gt;, value: &lt;nil&gt;
+ 
+ w = &amp;FileWriter{}
+ fmt.Printf("type: %T, value: %v\n", w, w)
+ // type: *main.FileWriter, value: &amp;{...}
+ &#96;&#96;&#96;
+ 
+ This matters because of the nil interface trap we covered earlier. An interface is only &#96;nil&#96; when both type and value are nil. Assign a nil pointer and the type is set, so the interface isn't nil.
+ 
+ ## Interfaces on Values vs Pointers
+ 
+ Methods can have value receivers or pointer receivers. This affects interface implementation:
+ 
+ &#96;&#96;&#96;go
+ type Speaker interface {
+     Speak() string
+ }
+ 
+ type Dog struct{ Name string }
+ 
+ // Value receiver
+ func (d Dog) Speak() string {
+     return "Woof!"
+ }
+ 
+ var s Speaker
+ s = Dog{Name: "Rex"}   // OK - Dog implements Speaker
+ s = &amp;Dog{Name: "Rex"}  // OK - *Dog also implements Speaker (Go is helpful here)
+ &#96;&#96;&#96;
+ 
+ But watch what happens with pointer receivers:
+ 
+ &#96;&#96;&#96;go
+ type Cat struct{ Name string }
+ 
+ // Pointer receiver
+ func (c *Cat) Speak() string {
+     return "Meow!"
+ }
+ 
+ var s Speaker
+ s = &amp;Cat{Name: "Whiskers"}  // OK - *Cat implements Speaker
+ s = Cat{Name: "Whiskers"}   // ERROR - Cat does NOT implement Speaker
+ &#96;&#96;&#96;
+ 
+ Why? Because you can always get a pointer from a value (&#96;&amp;cat&#96;), but you can't always get an addressable value from a pointer. Go is strict about this.
+ 
+ **The rule**: if any method has a pointer receiver, use pointers with that interface.
+ 
+ ## Comparing to C# Interface Features
+ 
+ | Feature | C# | Go |
+ |---------|-----|-----|
+ | Explicit implementation | Required (&#96;: IInterface&#96;) | Not possible |
+ | Implicit implementation | Not possible | Automatic |
+ | Default methods | Yes (C# 8+) | No |
+ | Static methods | Yes (C# 11) | No |
+ | Properties | Yes | No (use methods) |
+ | Generic interfaces | Yes | Yes (Go 1.18+) |
+ | Explicit interface implementation | Yes (&#96;IFoo.Bar()&#96;) | No |
+ | Covariance/contravariance | Yes (&#96;out&#96;/&#96;in&#96;) | No |
+ 
+ Go interfaces are simpler. That simplicity is the point.
+ 
+ ## The Honest Take
+ 
+ Implicit interfaces felt wrong. "How will I know what my type implements?" "How will I communicate intent?"
+ 
+ Then I realised: the caller defines what it needs. The implementer just provides capabilities. If those match, great. If not, no harm done.
+ 
+ **What Go does better:**
+ - Define interfaces at the point of use, not declaration
+ - Small, composable interfaces are natural
+ - No ceremony—just write the methods
+ - Retroactive interface satisfaction
+ - Decouples interface from implementation completely
+ 
+ **What C# does better:**
+ - Clear documentation of intent (&#96;: IInterface&#96;)
+ - IDE "go to implementations" is easier
+ - Explicit interface implementation for conflicts
+ - Default interface methods
+ - Richer interface features (properties, statics)
+ 
+ **The verdict:**
+ Once you stop thinking "I need to declare my interfaces upfront" and start thinking "I'll define an interface when I need the abstraction," Go's approach makes beautiful sense. It's just a different philosophy.
+ 
+ The interface belongs to the consumer, not the producer. That inversion takes time to internalise, but it's powerful.
+ 
+ ---
+ 
+ *Next up: composition via embedding—Go's alternative to inheritance, and why you really won't miss base classes.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-composition.md</summary>

**Chunk 1**
Lines added: 344, lines removed: 1

```diff
@@ -1,1 +1,344 @@
- 
+ +++
+ title = "Composition Over Inheritance (For Real This Time)"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "composition", "embedding", "csharp"]
+ +++
+ 
+ We've all heard "favour composition over inheritance." We've all nodded sagely. And then we've all written class hierarchies three levels deep because, well, it's right there and it's easy.
+ 
+ Go doesn't give you the choice. There's no inheritance. Zero. You can't extend a type. You can't override methods. There's no &#96;virtual&#96;, no &#96;abstract&#96;, no &#96;base&#96;.
+ 
+ Instead, Go has **embedding**—a form of composition that feels almost like inheritance but isn't. And after using it for a while, I genuinely don't miss base classes.
+ 
+ ## What Is Embedding?
+ 
+ Embedding is when you include one type inside another without giving it a field name:
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+     Age  int
+ }
+ 
+ type Employee struct {
+     Person              // embedded - no field name
+     EmployeeID string
+     Department string
+ }
+ &#96;&#96;&#96;
+ 
+ Notice: &#96;Person&#96; is listed without a name. It's not &#96;person Person&#96;, just &#96;Person&#96;. That's embedding.
+ 
+ What does this give you? The embedded type's fields and methods are **promoted** to the outer type:
+ 
+ &#96;&#96;&#96;go
+ emp := Employee{
+     Person:     Person{Name: "Alice", Age: 30},
+     EmployeeID: "E123",
+     Department: "Engineering",
+ }
+ 
+ // These all work:
+ fmt.Println(emp.Name)        // "Alice" - promoted from Person
+ fmt.Println(emp.Age)         // 30 - promoted from Person
+ fmt.Println(emp.EmployeeID)  // "E123" - direct field
+ fmt.Println(emp.Person.Name) // "Alice" - explicit access still works
+ &#96;&#96;&#96;
+ 
+ The &#96;Employee&#96; type didn't "inherit" from &#96;Person&#96;. It *contains* a &#96;Person&#96; and Go conveniently promotes its members.
+ 
+ ## Methods Are Promoted Too
+ 
+ If &#96;Person&#96; has methods, &#96;Employee&#96; gets them:
+ 
+ &#96;&#96;&#96;go
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hi, I'm %s", p.Name)
+ }
+ 
+ emp := Employee{Person: Person{Name: "Alice"}}
+ fmt.Println(emp.Greet())  // "Hi, I'm Alice"
+ &#96;&#96;&#96;
+ 
+ The method is promoted. You call it on &#96;Employee&#96;, but it executes as if called on the embedded &#96;Person&#96;. 
+ 
+ This looks like inheritance. But there's a crucial difference.
+ 
+ ## It's Not Inheritance: The Receiver Stays the Same
+ 
+ In inheritance, an overridden method in a subclass can access &#96;this&#96;/&#96;self&#96; as the subclass type. That's polymorphism.
+ 
+ In embedding, the method's receiver is still the embedded type:
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+ }
+ 
+ func (p Person) Introduce() string {
+     return fmt.Sprintf("I am %s", p.Name)
+ }
+ 
+ type Employee struct {
+     Person
+     Title string
+ }
+ 
+ // This is NOT overriding - it's shadowing
+ func (e Employee) Introduce() string {
+     return fmt.Sprintf("I am %s, %s", e.Name, e.Title)
+ }
+ &#96;&#96;&#96;
+ 
+ If &#96;Person.Introduce()&#96; called another method, that call wouldn't magically dispatch to &#96;Employee&#96;'s version:
+ 
+ &#96;&#96;&#96;go
+ func (p Person) FullIntro() string {
+     return p.Introduce() + ". Nice to meet you!"  // calls Person.Introduce, always
+ }
+ 
+ emp := Employee{Person: Person{Name: "Alice"}, Title: "Engineer"}
+ fmt.Println(emp.FullIntro())  // "I am Alice. Nice to meet you!"
+ // Not "I am Alice, Engineer. Nice to meet you!"
+ &#96;&#96;&#96;
+ 
+ There's no dynamic dispatch based on the outer type. The embedded &#96;Person&#96; doesn't know it's inside an &#96;Employee&#96;. It just does its thing.
+ 
+ This is composition, not inheritance. It's a feature, not a limitation.
+ 
+ ## Multiple Embedding
+ 
+ You can embed multiple types:
+ 
+ &#96;&#96;&#96;go
+ type Reader struct { ... }
+ func (r Reader) Read(p []byte) (int, error) { ... }
+ 
+ type Writer struct { ... }
+ func (w Writer) Write(p []byte) (int, error) { ... }
+ 
+ type ReadWriter struct {
+     Reader
+     Writer
+ }
+ 
+ // ReadWriter now has both Read and Write methods
+ &#96;&#96;&#96;
+ 
+ This is like implementing multiple interfaces, except you're getting actual implementations, not just contracts.
+ 
+ If there are conflicts (both embedded types have a method with the same name), you get a compile error when you try to call the ambiguous method. You resolve it by calling explicitly:
+ 
+ &#96;&#96;&#96;go
+ rw.Reader.SomeMethod()  // explicit disambiguation
+ rw.Writer.SomeMethod()
+ &#96;&#96;&#96;
+ 
+ ## Embedding Interfaces
+ 
+ You can also embed interfaces in interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ 
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type ReadWriter interface {
+     Reader  // embedded
+     Writer  // embedded
+ }
+ &#96;&#96;&#96;
+ 
+ This is just interface composition. &#96;ReadWriter&#96; requires both &#96;Read&#96; and &#96;Write&#96; methods.
+ 
+ And you can embed interfaces in structs:
+ 
+ &#96;&#96;&#96;go
+ type MyHandler struct {
+     http.Handler  // embedded interface
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;MyHandler&#96; has a field of type &#96;http.Handler&#96;, and its methods are promoted. You can create a &#96;MyHandler&#96; with any &#96;http.Handler&#96; implementation.
+ 
+ This is useful for decorating or wrapping behaviour.
+ 
+ ## The "Delegation" Pattern
+ 
+ Want to wrap something and override specific behaviour? Embed and shadow:
+ 
+ &#96;&#96;&#96;go
+ type LoggingWriter struct {
+     io.Writer  // embedded interface
+ }
+ 
+ func (lw LoggingWriter) Write(p []byte) (n int, err error) {
+     log.Printf("writing %d bytes", len(p))
+     return lw.Writer.Write(p)  // delegate to embedded
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;LoggingWriter&#96; embeds an &#96;io.Writer&#96;. It has its own &#96;Write&#96; method that logs then delegates. Everything else passes through unchanged.
+ 
+ Use it like:
+ 
+ &#96;&#96;&#96;go
+ file, _ := os.Create("output.txt")
+ logged := LoggingWriter{Writer: file}
+ logged.Write([]byte("hello"))  // logs then writes
+ &#96;&#96;&#96;
+ 
+ This is the decorator pattern, but simple and type-safe.
+ 
+ ## Comparing to C# Inheritance
+ 
+ Let's see the same concept in C#:
+ 
+ &#96;&#96;&#96;csharp
+ public class Person
+ {
+     public string Name { get; set; }
+     public virtual string Greet() =&gt; $"Hi, I'm {Name}";
+ }
+ 
+ public class Employee : Person
+ {
+     public string EmployeeID { get; set; }
+     public override string Greet() =&gt; $"Hi, I'm {Name}, employee {EmployeeID}";
+ }
+ &#96;&#96;&#96;
+ 
+ With inheritance, &#96;Employee&#96; IS-A &#96;Person&#96;. Polymorphism works. Override methods get called even when accessed through a base reference.
+ 
+ &#96;&#96;&#96;csharp
+ Person p = new Employee { Name = "Alice", EmployeeID = "E123" };
+ Console.WriteLine(p.Greet());  // "Hi, I'm Alice, employee E123" - polymorphic!
+ &#96;&#96;&#96;
+ 
+ Go's embedding doesn't do this. &#96;Employee&#96; HAS-A &#96;Person&#96;. No polymorphism. No override resolution.
+ 
+ ## When You'll Miss Inheritance
+ 
+ Let's be honest: there are patterns that inheritance handles elegantly.
+ 
+ **Template Method Pattern:**
+ 
+ &#96;&#96;&#96;csharp
+ public abstract class DataProcessor
+ {
+     public void Process()
+     {
+         var data = LoadData();
+         var transformed = Transform(data);  // subclass provides this
+         Save(transformed);
+     }
+     
+     protected abstract object Transform(object data);
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, you'd use an interface:
+ 
+ &#96;&#96;&#96;go
+ type Transformer interface {
+     Transform(data any) any
+ }
+ 
+ type DataProcessor struct {
+     transformer Transformer
+ }
+ 
+ func (dp *DataProcessor) Process() {
+     data := dp.LoadData()
+     transformed := dp.transformer.Transform(data)
+     dp.Save(transformed)
+ }
+ &#96;&#96;&#96;
+ 
+ More explicit, arguably clearer, but more code.
+ 
+ **Protected Members:**
+ 
+ C# has &#96;protected&#96;—visible to derived classes. Go has nothing like this. Everything is either exported (public) or unexported (package-private).
+ 
+ If you want controlled extension points, you design them explicitly with interfaces, not protected methods.
+ 
+ ## When Embedding Shines
+ 
+ **Extending functionality without modification:**
+ 
+ &#96;&#96;&#96;go
+ type CountingReader struct {
+     io.Reader
+     count int
+ }
+ 
+ func (cr *CountingReader) Read(p []byte) (n int, err error) {
+     n, err = cr.Reader.Read(p)
+     cr.count += n
+     return
+ }
+ &#96;&#96;&#96;
+ 
+ Wrap any reader. Count bytes. Original reader unchanged.
+ 
+ **Combining capabilities:**
+ 
+ &#96;&#96;&#96;go
+ type Server struct {
+     http.Server       // get all http.Server fields and methods
+     Logger *log.Logger
+     Metrics *Metrics
+ }
+ &#96;&#96;&#96;
+ 
+ Your server has everything &#96;http.Server&#96; has, plus your additions.
+ 
+ **Implementing interfaces via delegation:**
+ 
+ &#96;&#96;&#96;go
+ type DB struct {
+     pool *sql.DB  // not embedded, private
+ }
+ 
+ // Expose only what you want
+ func (db *DB) Query(q string) (*sql.Rows, error) {
+     return db.pool.Query(q)
+ }
+ &#96;&#96;&#96;
+ 
+ Control the surface area. Don't embed if you don't want to expose everything.
+ 
+ ## The Honest Take
+ 
+ I was skeptical. "Composition over inheritance" sounded like coping. Then I used Go for six months and realised: I don't miss inheritance. Not really.
+ 
+ **What Go does better:**
+ - Forces you to think about composition
+ - No fragile base class problem
+ - No diamond inheritance nightmare
+ - Clear delegation chain
+ - Easy to wrap and extend behaviour
+ 
+ **What C# does better:**
+ - Polymorphism when you actually need it
+ - Template method pattern
+ - Protected members for controlled extension
+ - Clearer "IS-A" relationships in domain modelling
+ 
+ **The verdict:**
+ Inheritance is a sharp tool. It's powerful when used well and creates brittle, tangled hierarchies when used poorly. Go removes the temptation.
+ 
+ Embedding plus interfaces gives you most of what you need. The rest can be solved with explicit design patterns. You'll write more code sometimes, but it'll be clearer code.
+ 
+ And honestly? Those deep inheritance hierarchies you built in C#? They probably shouldn't have been inheritance anyway.
+ 
+ ---
+ 
+ *Next up: the empty interface and type assertions—when you're basically back to &#96;object&#96;, and how to work with Go's dynamic typing escape hatch.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-any.md</summary>

**Chunk 1**
Lines added: 329, lines removed: 1

```diff
@@ -1,1 +1,329 @@
- 
+ +++
+ title = "The Empty Interface and Type Assertions"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "interfaces", "any", "csharp"]
+ +++
+ 
+ Go has a type called &#96;any&#96;. Before Go 1.18, it was written &#96;interface{}&#96;. Same thing, nicer name. And it's basically Go's version of &#96;object&#96;—the type that can hold anything.
+ 
+ Every type in Go implements &#96;any&#96; because &#96;any&#96; has no methods. Zero requirements means universal satisfaction. And that means when you use &#96;any&#96;, you're opting out of the type system.
+ 
+ Let's talk about when that's okay, when it's not, and how to get your types back when you need them.
+ 
+ ## What Is &#96;any&#96; / &#96;interface{}&#96;?
+ 
+ An empty interface is an interface with no methods:
+ 
+ &#96;&#96;&#96;go
+ interface{}  // the old syntax
+ any          // alias added in Go 1.18, same thing
+ &#96;&#96;&#96;
+ 
+ Since there are no required methods, every type satisfies this interface. Everything is an &#96;any&#96;.
+ 
+ &#96;&#96;&#96;go
+ var x any
+ 
+ x = 42              // int
+ x = "hello"         // string
+ x = []int{1, 2, 3}  // slice
+ x = struct{}{}      // empty struct
+ x = nil             // nil
+ &#96;&#96;&#96;
+ 
+ All valid. &#96;any&#96; is the universal container.
+ 
+ ## The C# Equivalent: &#96;object&#96;
+ 
+ C#'s &#96;object&#96; is the same idea:
+ 
+ &#96;&#96;&#96;csharp
+ object x;
+ x = 42;
+ x = "hello";
+ x = new List&lt;int&gt; { 1, 2, 3 };
+ &#96;&#96;&#96;
+ 
+ Both languages have this escape hatch for "I don't know the type at compile time." Both languages encourage you to avoid it when possible.
+ 
+ ## Why &#96;any&#96; Exists
+ 
+ Sometimes you genuinely don't know the type:
+ 
+ **JSON with unknown structure:**
+ 
+ &#96;&#96;&#96;go
+ var data any
+ json.Unmarshal(rawBytes, &amp;data)
+ // data is now map[string]any or []any or a primitive
+ &#96;&#96;&#96;
+ 
+ **Generic containers before Go had generics:**
+ 
+ &#96;&#96;&#96;go
+ // Before Go 1.18
+ type Stack struct {
+     items []interface{}
+ }
+ 
+ func (s *Stack) Push(item interface{}) {
+     s.items = append(s.items, item)
+ }
+ &#96;&#96;&#96;
+ 
+ **Function parameters that accept anything:**
+ 
+ &#96;&#96;&#96;go
+ func Println(a ...any) (n int, err error)
+ &#96;&#96;&#96;
+ 
+ &#96;fmt.Println&#96; takes &#96;any&#96; because it prints anything.
+ 
+ ## Type Assertions: Getting Types Back
+ 
+ When you have an &#96;any&#96; and need the actual type, you use a **type assertion**:
+ 
+ &#96;&#96;&#96;go
+ var x any = "hello"
+ 
+ s := x.(string)  // assert x is a string
+ fmt.Println(s)   // "hello"
+ &#96;&#96;&#96;
+ 
+ The syntax is &#96;value.(Type)&#96;. It says "I believe this &#96;any&#96; contains a &#96;Type&#96;, give it to me."
+ 
+ ### The Danger: Panics
+ 
+ If you're wrong, it panics:
+ 
+ &#96;&#96;&#96;go
+ var x any = 42
+ s := x.(string)  // panic: interface conversion: int is not string
+ &#96;&#96;&#96;
+ 
+ This is like an invalid cast exception in C#:
+ 
+ &#96;&#96;&#96;csharp
+ object x = 42;
+ string s = (string)x;  // InvalidCastException
+ &#96;&#96;&#96;
+ 
+ ### The Safe Way: Comma-OK Idiom
+ 
+ Always use the two-value form in real code:
+ 
+ &#96;&#96;&#96;go
+ var x any = 42
+ 
+ s, ok := x.(string)
+ if !ok {
+     fmt.Println("x is not a string")
+ } else {
+     fmt.Println(s)
+ }
+ &#96;&#96;&#96;
+ 
+ If the assertion fails, &#96;ok&#96; is &#96;false&#96; and &#96;s&#96; is the zero value of &#96;string&#96;. No panic.
+ 
+ This is like C#'s &#96;as&#96; operator plus null check:
+ 
+ &#96;&#96;&#96;csharp
+ object x = 42;
+ if (x is string s)
+ {
+     Console.WriteLine(s);
+ }
+ else
+ {
+     Console.WriteLine("x is not a string");
+ }
+ &#96;&#96;&#96;
+ 
+ ## Type Switches: Handling Multiple Types
+ 
+ When you need to handle different types, use a type switch:
+ 
+ &#96;&#96;&#96;go
+ func describe(x any) {
+     switch v := x.(type) {
+     case int:
+         fmt.Printf("int: %d\n", v)
+     case string:
+         fmt.Printf("string: %s\n", v)
+     case bool:
+         fmt.Printf("bool: %t\n", v)
+     case []int:
+         fmt.Printf("slice of ints: %v\n", v)
+     default:
+         fmt.Printf("unknown type: %T\n", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;x.(type)&#96; syntax only works in a switch. Each case binds &#96;v&#96; to the correctly typed value.
+ 
+ This is cleaner than chained type assertions:
+ 
+ &#96;&#96;&#96;go
+ // DON'T do this
+ if i, ok := x.(int); ok {
+     // ...
+ } else if s, ok := x.(string); ok {
+     // ...
+ } else if b, ok := x.(bool); ok {
+     // ...
+ }
+ 
+ // DO this
+ switch v := x.(type) {
+ case int:
+     // v is int
+ case string:
+     // v is string
+ case bool:
+     // v is bool
+ }
+ &#96;&#96;&#96;
+ 
+ ## Working with JSON
+ 
+ This is where &#96;any&#96; shows up most in real code. JSON decoding into unknown structures:
+ 
+ &#96;&#96;&#96;go
+ func processJSON(raw []byte) error {
+     var data any
+     if err := json.Unmarshal(raw, &amp;data); err != nil {
+         return err
+     }
+     
+     return walkJSON(data)
+ }
+ 
+ func walkJSON(v any) error {
+     switch val := v.(type) {
+     case map[string]any:
+         for key, value := range val {
+             fmt.Printf("key: %s\n", key)
+             walkJSON(value)
+         }
+     case []any:
+         for i, item := range val {
+             fmt.Printf("index: %d\n", i)
+             walkJSON(item)
+         }
+     case string:
+         fmt.Printf("string: %s\n", val)
+     case float64:  // JSON numbers are float64
+         fmt.Printf("number: %f\n", val)
+     case bool:
+         fmt.Printf("bool: %t\n", val)
+     case nil:
+         fmt.Println("null")
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ JSON objects become &#96;map[string]any&#96;. Arrays become &#96;[]any&#96;. Numbers are always &#96;float64&#96; (JSON doesn't distinguish int from float).
+ 
+ ## The Performance Cost
+ 
+ There's overhead to &#96;any&#96;. The interface value stores two pointers (type and value), and type assertions have runtime cost.
+ 
+ For hot paths, you want concrete types:
+ 
+ &#96;&#96;&#96;go
+ // Slower - any with type assertion
+ func processAny(x any) {
+     if n, ok := x.(int); ok {
+         // work with n
+     }
+ }
+ 
+ // Faster - concrete type
+ func processInt(n int) {
+     // work with n
+ }
+ &#96;&#96;&#96;
+ 
+ With generics in Go 1.18+, you often don't need &#96;any&#96;:
+ 
+ &#96;&#96;&#96;go
+ // Before generics
+ func Contains(slice []any, item any) bool { ... }
+ 
+ // With generics - type safe, no assertions needed
+ func Contains[T comparable](slice []T, item T) bool { ... }
+ &#96;&#96;&#96;
+ 
+ ## When to Use &#96;any&#96;
+ 
+ **Legitimate uses:**
+ 
+ - JSON/YAML with unknown structure
+ - Reflection-based code
+ - Interfacing with dynamic systems
+ - Printf-style variadic functions
+ 
+ **Code smells:**
+ 
+ - Using &#96;any&#96; to avoid thinking about types
+ - &#96;map[string]any&#96; as a "flexible" data structure (define a struct)
+ - &#96;any&#96; parameters when a specific interface would work
+ - Type assertions scattered throughout code
+ 
+ ## Comparing to C#
+ 
+ | Aspect | Go &#96;any&#96; | C# &#96;object&#96; |
+ |--------|----------|-------------|
+ | Boxing value types | No (pointers stored) | Yes |
+ | Type assertion | &#96;x.(Type)&#96; | &#96;(Type)x&#96; or &#96;x as Type&#96; |
+ | Safe assertion | &#96;v, ok := x.(Type)&#96; | &#96;x is Type v&#96; |
+ | Type switch | &#96;switch v := x.(type)&#96; | &#96;switch (x)&#96; with patterns |
+ | Performance cost | Yes | Yes (especially boxing) |
+ 
+ C# has better pattern matching:
+ 
+ &#96;&#96;&#96;csharp
+ object x = GetSomething();
+ var result = x switch
+ {
+     int i =&gt; $"int: {i}",
+     string s =&gt; $"string: {s}",
+     IEnumerable&lt;int&gt; list =&gt; $"list with {list.Count()} items",
+     { } obj =&gt; $"object: {obj}",
+     null =&gt; "null"
+ };
+ &#96;&#96;&#96;
+ 
+ Go's type switch is simpler but less powerful.
+ 
+ ## The Honest Take
+ 
+ &#96;any&#96; is an escape hatch. Sometimes you need it. Most of the time, you don't.
+ 
+ **What Go does okay:**
+ - Clear syntax for type assertions
+ - Type switches are readable
+ - No boxing for value types (unlike C#)
+ 
+ **What C# does better:**
+ - Richer pattern matching
+ - &#96;is&#96; and &#96;as&#96; operators are more intuitive
+ - Better tooling for discovering what types you'll encounter
+ 
+ **What both should make you do:**
+ - Reach for generics first
+ - Define concrete interfaces where possible
+ - Use &#96;any&#96; only at boundaries (JSON parsing, reflection, interop)
+ 
+ **The verdict:**
+ Every time you write &#96;any&#96;, ask yourself: "Do I really not know the type here?" Often you do know it, or you could define an interface that captures what you need.
+ 
+ &#96;any&#96; is the "I give up" of Go's type system. Sometimes giving up is appropriate. A well-designed API rarely needs it.
+ 
+ ---
+ 
+ *That wraps up the interfaces and composition section. Go's approach is simpler than C#'s—implicit interfaces, embedding instead of inheritance, and a minimal &#96;any&#96; type for the truly dynamic cases. It's less powerful in some ways, but the constraints push you toward cleaner designs.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      22
---
content/posts/dotnet-to-go-any.md
content/posts/dotnet-to-go-channels.md
content/posts/dotnet-to-go-composition.md
content/posts/dotnet-to-go-context.md
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-goroutines.md
content/posts/dotnet-to-go-interfaces.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-select.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-sync.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 22 posts are done and the build passes. Let me summarize the complete series for the user.</details></think>

---

All 3 Interfaces & Composition posts done! 22 posts total now. Here's the complete series:

## C# to Go Series (22 posts)

### Phase 1: Getting Oriented (3)
1. "You Know .NET, Now Meet the Go Toolchain"
2. "Goodbye .csproj, Hello go.mod"
3. "The Phrasebook: C# Concepts in Go Terms"

### Phase 2: Types & Data (5)
4. "Your Class Is Now a Struct (And That's Fine)"
5. "Where Did My Properties Go?"
6. "Generics: Late to the Party"
7. "The Million Dollar Mistake, Differently"
8. "No Enums? No Problem (Sort Of)"

### Phase 3: Control Flow & Error Handling (3)
9. "if err != nil: Your New Reality"
10. "Panic and Recover: The Emergency Exit"
11. "The switch Statement You Always Wanted"

### Phase 4: Memory & Pointers (3)
12. "Pointers Without the Pain"
13. "Stack vs Heap: Go's Escape Analysis"
14. "Slices Are Not Arrays (And Neither Is List<T>)"

### Phase 5: Concurrency (5)
15. "Async/Await vs Goroutines: A Mindset Shift"
16. "Channels: The sync You Didn't Know You Wanted"
17. "select: Multiplexing Like a Pro"
18. "Mutexes and WaitGroups: When Channels Aren't the Answer"
19. "Context Is King"

### Phase 6: Interfaces & Composition ← **NEW** (3)
20. **"Implicit Interfaces: Scary Then Brilliant"** — No implements keyword, structural typing, defining interfaces after the fact, the compile-time satisfaction check (`var _ Writer = (*MyType)(nil)`), value vs pointer receivers with interfaces
21. **"Composition Over Inheritance (For Real This Time)"** — What embedding actually is (fields without names), method promotion, why it's NOT inheritance (receiver stays the same), multiple embedding, the decorator/delegation pattern
22. **"The Empty Interface and Type Assertions"** — `any` / `interface{}` as Go's `object`, type assertions (`x.(Type)`), the comma-ok idiom, type switches, when `any` is legitimate vs a code smell

Key definitions included:
- **Embedding**: Including a type without a field name, promoting its methods and fields
- **Structural typing**: If it has the methods, it implements the interface
- **Type assertion**: Extracting a concrete type from an interface value
- **Method promotion**: Embedded type's methods become available on the outer type

That's Phase 1 complete! Ready for more whenever you are.

---

_**User (2025-12-30 00:39Z)**_

Phase 2: The Ecosystem
Project Structure & Modules

Organising a Real Project — Package design, internal folders, and avoiding circular dependencies
Multi-Module Repos: Monorepo Thinking — When one go.mod isn't enough

Testing

Testing Without a Framework — Built-in testing, table-driven tests, and why you might not miss xUnit
Mocking in a Language Without Mockito — Interfaces, fakes, and when to reach for testify
Benchmarks and Profiling Out of the Box — go test -bench and pprof for the performance-curious

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create Phase 2 of the ecosystem posts - 5 posts covering:

1. Organising a Real Project — Package design, internal folders, and avoiding circular dependencies
2. Multi-Module Repos: Monorepo Thinking — When one go.mod isn't enough
3. Testing Without a Framework — Built-in testing, table-driven tests, and why you might not miss xUnit
4. Mocking in a Language Without Mockito — Interfaces, fakes, and when to reach for testify
5. Benchmarks and Profiling Out of the Box — go test -bench and pprof for the performance-curious

Let me write all 5 posts with the established tone - casual, technical, fair to both languages.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-project-structure.md</summary>

**Chunk 1**
Lines added: 338, lines removed: 1

```diff
@@ -1,1 +1,338 @@
- 
+ +++
+ title = "Organising a Real Project"
+ date = "2025-01-03"
+ draft = false
+ tags = ["go", "dotnet", "project-structure", "packages", "csharp"]
+ +++
+ 
+ So you've got the basics. You can write Go code. Now you need to organise it into something that won't become a tangled mess in six months.
+ 
+ Go has opinions about project structure. Some are enforced by the compiler. Some are conventions so universal they might as well be enforced. Coming from .NET's solution/project/namespace hierarchy, Go's flat package model takes adjustment.
+ 
+ Let's figure out how to structure a real project.
+ 
+ ## The Mental Model Shift
+ 
+ In C#, you think in layers:
+ 
+ &#96;&#96;&#96;
+ Solution (MySolution.sln)
+   └── Project (MyApp.csproj)
+         └── Namespace (MyApp.Services)
+               └── Class (UserService.cs)
+ &#96;&#96;&#96;
+ 
+ In Go, it's flatter:
+ 
+ &#96;&#96;&#96;
+ Module (go.mod)
+   └── Package (directory)
+         └── Files (*.go)
+ &#96;&#96;&#96;
+ 
+ There's no solution concept. No &#96;.csproj&#96; files. A module is a collection of packages, and packages are directories. That's it.
+ 
+ ## Package Basics
+ 
+ A package is a directory. Every &#96;.go&#96; file in that directory must have the same &#96;package&#96; declaration:
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod
+ ├── main.go           // package main
+ └── user/
+     ├── user.go       // package user
+     └── validation.go // package user (same package!)
+ &#96;&#96;&#96;
+ 
+ All files in &#96;user/&#96; share the same package namespace. They can access each other's unexported (lowercase) identifiers. It's like they're all one file, split for organisation.
+ 
+ ### Package vs Directory Name
+ 
+ By convention, the package name matches the directory name:
+ 
+ &#96;&#96;&#96;go
+ // In directory "user/"
+ package user  // matches directory name
+ &#96;&#96;&#96;
+ 
+ You *can* name them differently, but don't. It confuses everyone.
+ 
+ ### Importing
+ 
+ Import paths are relative to the module root:
+ 
+ &#96;&#96;&#96;go
+ // go.mod says: module github.com/myname/myproject
+ 
+ import "github.com/myname/myproject/user"
+ 
+ func main() {
+     u := user.New("Alice")  // user is the package name
+ }
+ &#96;&#96;&#96;
+ 
+ ## A Real Project Layout
+ 
+ Here's a layout that works for most non-trivial projects:
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod
+ ├── go.sum
+ ├── main.go                 // or cmd/myapp/main.go
+ ├── internal/
+ │   ├── config/
+ │   │   └── config.go
+ │   ├── database/
+ │   │   ├── database.go
+ │   │   └── migrations.go
+ │   └── handlers/
+ │       ├── user.go
+ │       └── product.go
+ ├── pkg/
+ │   └── validation/
+ │       └── validation.go
+ └── api/
+     └── openapi.yaml
+ &#96;&#96;&#96;
+ 
+ Let's break this down.
+ 
+ ### &#96;internal/&#96; — The Privacy Fence
+ 
+ The &#96;internal&#96; directory is magic. The Go compiler enforces that packages under &#96;internal/&#96; can only be imported by code rooted at the parent of &#96;internal/&#96;.
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── internal/
+ │   └── secret/       // only myproject can import this
+ └── cmd/
+     └── myapp/
+         └── main.go   // can import internal/secret
+ &#96;&#96;&#96;
+ 
+ If someone else imports your module, they *cannot* import &#96;internal/secret&#96;. The compiler refuses.
+ 
+ This is Go's answer to &#96;internal&#96; visibility in C#. Use it for implementation details you don't want to be part of your public API.
+ 
+ ### &#96;pkg/&#96; — Exportable Packages (Convention)
+ 
+ The &#96;pkg/&#96; directory is purely convention (not enforced). It signals "these packages are intended for external use."
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── internal/         // private
+ └── pkg/              // public (by convention)
+     └── validation/   // anyone can import this
+ &#96;&#96;&#96;
+ 
+ Some projects skip &#96;pkg/&#96; and put public packages at the root. Both are fine. Just be consistent.
+ 
+ ### &#96;cmd/&#96; — Multiple Binaries
+ 
+ If your module produces multiple executables:
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── cmd/
+ │   ├── server/
+ │   │   └── main.go   // builds to 'server' binary
+ │   └── cli/
+ │       └── main.go   // builds to 'cli' binary
+ └── internal/
+     └── shared/       // shared by both
+ &#96;&#96;&#96;
+ 
+ Build with:
+ 
+ &#96;&#96;&#96;bash
+ go build ./cmd/server
+ go build ./cmd/cli
+ &#96;&#96;&#96;
+ 
+ ### No &#96;src/&#96; Directory
+ 
+ Coming from Java or older Go (GOPATH era), you might want a &#96;src/&#96; directory. Don't. Modern Go modules don't use it. Put your code at the root.
+ 
+ ## Avoiding Circular Dependencies
+ 
+ Go doesn't allow circular imports. If package A imports package B, package B cannot import package A. The compiler rejects it.
+ 
+ This is different from C#, where circular references between projects are blocked but classes within a project can reference each other freely.
+ 
+ ### The Problem
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── user/
+ │   └── user.go       // imports "myproject/order"
+ └── order/
+     └── order.go      // imports "myproject/user" - COMPILE ERROR
+ &#96;&#96;&#96;
+ 
+ ### Solutions
+ 
+ **1. Extract shared types to a third package:**
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── user/
+ │   └── user.go       // imports "myproject/models"
+ ├── order/
+ │   └── order.go      // imports "myproject/models"
+ └── models/
+     └── models.go     // shared types, imports neither
+ &#96;&#96;&#96;
+ 
+ **2. Use interfaces at boundaries:**
+ 
+ &#96;&#96;&#96;go
+ // order/order.go
+ package order
+ 
+ type UserGetter interface {
+     GetUser(id string) (*User, error)
+ }
+ 
+ type OrderService struct {
+     users UserGetter  // interface, not concrete user.Service
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;order&#96; doesn't import &#96;user&#96;. It depends on an interface that &#96;user.Service&#96; happens to implement.
+ 
+ **3. Merge packages:**
+ 
+ Sometimes the cycle means the packages are too closely related to be separate. Merge them.
+ 
+ ## Package Design Principles
+ 
+ ### Small, Focused Packages
+ 
+ Go encourages small packages with clear responsibilities. Not one giant &#96;utils&#96; package.
+ 
+ &#96;&#96;&#96;
+ // BAD
+ utils/
+ ├── string_helpers.go
+ ├── http_helpers.go
+ ├── database_helpers.go
+ └── random_stuff.go
+ 
+ // BETTER
+ stringutil/
+     └── stringutil.go
+ httputil/
+     └── httputil.go
+ database/
+     └── helpers.go
+ &#96;&#96;&#96;
+ 
+ ### Name Packages by What They Provide
+ 
+ Package names should be nouns describing what they provide:
+ 
+ &#96;&#96;&#96;
+ // GOOD
+ http, json, user, config, database
+ 
+ // BAD  
+ helpers, utils, common, misc
+ &#96;&#96;&#96;
+ 
+ ### Avoid Stutter
+ 
+ The package name is part of the identifier when used:
+ 
+ &#96;&#96;&#96;go
+ // BAD - stutters
+ user.UserService
+ http.HTTPClient
+ config.ConfigLoader
+ 
+ // GOOD - no stutter
+ user.Service
+ http.Client
+ config.Loader
+ &#96;&#96;&#96;
+ 
+ ### One Package, One Purpose
+ 
+ Each package should have a single, clear purpose. If you're struggling to name it, it might be doing too much.
+ 
+ ## Comparing to C# Project Structure
+ 
+ | C# | Go |
+ |-----|-----|
+ | Solution (&#96;.sln&#96;) | Module (&#96;go.mod&#96;) |
+ | Project (&#96;.csproj&#96;) | Package (directory) |
+ | Namespace | Package |
+ | &#96;internal&#96; modifier | &#96;internal/&#96; directory |
+ | Folder structure | Package structure (folders = packages) |
+ | Circular project refs blocked | Circular imports blocked |
+ | Multiple assemblies | Multiple packages |
+ | Multiple executables | &#96;cmd/&#96; subdirectories |
+ 
+ ## A Practical Example
+ 
+ Let's say you're building an API server. Here's how I'd structure it:
+ 
+ &#96;&#96;&#96;
+ myapi/
+ ├── go.mod
+ ├── go.sum
+ ├── main.go                      // entry point, wires things up
+ ├── internal/
+ │   ├── api/
+ │   │   ├── router.go            // HTTP routing
+ │   │   ├── middleware.go        // auth, logging, etc.
+ │   │   └── handlers/
+ │   │       ├── users.go
+ │   │       └── products.go
+ │   ├── domain/
+ │   │   ├── user.go              // User type and business logic
+ │   │   └── product.go
+ │   ├── repository/
+ │   │   ├── user_repo.go         // database operations
+ │   │   └── product_repo.go
+ │   └── config/
+ │       └── config.go
+ ├── pkg/
+ │   └── response/
+ │       └── response.go          // shared API response types
+ └── migrations/
+     └── 001_initial.sql
+ &#96;&#96;&#96;
+ 
+ - &#96;internal/&#96; keeps implementation details private
+ - &#96;domain/&#96; has business types with no external dependencies
+ - &#96;repository/&#96; handles persistence
+ - &#96;api/handlers/&#96; maps HTTP to domain operations
+ - &#96;pkg/response/&#96; is a utility others could use
+ 
+ ## The Honest Take
+ 
+ Go's package system is simpler than C#'s project/namespace hierarchy. That simplicity is mostly good—less configuration, clearer structure.
+ 
+ **What Go does better:**
+ - &#96;internal/&#96; is enforced by the compiler, not convention
+ - No &#96;.csproj&#96; files to manage
+ - Package = directory is clear and simple
+ - Forced to avoid circular dependencies
+ 
+ **What C# does better:**
+ - Namespaces can span multiple assemblies
+ - More flexibility in organisation
+ - Better tooling for refactoring package structure
+ - Multiple classes per file without namespace issues
+ 
+ **The verdict:**
+ Go's constraints push you toward better design. No circular dependencies means you think about boundaries upfront. &#96;internal/&#96; enforced by the compiler means you actually use it.
+ 
+ It's more restrictive, but those restrictions prevent the spaghetti that large C# solutions sometimes become.
+ 
+ ---
+ 
+ *Next up: multi-module repos—when you need more than one &#96;go.mod&#96; and how to think about monorepo structure in Go.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-monorepo.md</summary>

**Chunk 1**
Lines added: 251, lines removed: 1

```diff
@@ -1,1 +1,251 @@
- 
+ +++
+ title = "Multi-Module Repos: Monorepo Thinking"
+ date = "2025-01-03"
+ draft = false
+ tags = ["go", "dotnet", "modules", "monorepo", "csharp"]
+ +++
+ 
+ Most Go projects have one &#96;go.mod&#96; file at the root. One module, one version, simple. But what happens when your repo grows? When you have shared libraries, multiple services, and teams stepping on each other's toes?
+ 
+ You need multiple modules. And Go's support for this is... functional. Not beautiful, but functional.
+ 
+ ## When One Module Isn't Enough
+ 
+ Stick with one module when you can. But consider multiple modules when:
+ 
+ **Independent versioning matters:**
+ Your repo has a shared library (&#96;pkg/auth&#96;) and two services (&#96;cmd/api&#96;, &#96;cmd/worker&#96;). Library changes shouldn't force service releases.
+ 
+ **Different dependency needs:**
+ One service needs a heavy dependency (ML framework, database driver) that others don't need.
+ 
+ **Teams need isolation:**
+ Different teams own different parts of the repo and want independent build/test/release cycles.
+ 
+ ## The Multi-Module Layout
+ 
+ Here's what a multi-module repo looks like:
+ 
+ &#96;&#96;&#96;
+ mycompany/
+ ├── go.work              // workspace file (Go 1.18+)
+ ├── services/
+ │   ├── api/
+ │   │   ├── go.mod       // module github.com/mycompany/services/api
+ │   │   ├── go.sum
+ │   │   └── main.go
+ │   └── worker/
+ │       ├── go.mod       // module github.com/mycompany/services/worker
+ │       ├── go.sum
+ │       └── main.go
+ └── libs/
+     ├── auth/
+     │   ├── go.mod       // module github.com/mycompany/libs/auth
+     │   ├── go.sum
+     │   └── auth.go
+     └── database/
+         ├── go.mod       // module github.com/mycompany/libs/database
+         ├── go.sum
+         └── database.go
+ &#96;&#96;&#96;
+ 
+ Each directory with a &#96;go.mod&#96; is an independent module. They can be versioned, released, and depended upon separately.
+ 
+ ## Go Workspaces
+ 
+ Before Go 1.18, working with multiple modules in one repo was painful. You'd constantly be editing &#96;go.mod&#96; files to use &#96;replace&#96; directives during development, then removing them before commit.
+ 
+ Go 1.18 introduced **workspaces**. Create a &#96;go.work&#96; file at the root:
+ 
+ &#96;&#96;&#96;go
+ // go.work
+ go 1.22
+ 
+ use (
+     ./services/api
+     ./services/worker
+     ./libs/auth
+     ./libs/database
+ )
+ &#96;&#96;&#96;
+ 
+ Now Go commands understand the whole repo:
+ 
+ &#96;&#96;&#96;bash
+ # From repo root
+ go build ./...      # builds all modules
+ go test ./...       # tests all modules
+ go mod tidy         # tidies all modules
+ &#96;&#96;&#96;
+ 
+ The &#96;go.work&#96; file is for local development. Don't commit it (add to &#96;.gitignore&#96;). Each module should work independently for CI/CD and consumers.
+ 
+ ## Cross-Module Dependencies
+ 
+ Modules in the same repo can depend on each other:
+ 
+ &#96;&#96;&#96;go
+ // services/api/go.mod
+ module github.com/mycompany/services/api
+ 
+ go 1.22
+ 
+ require (
+     github.com/mycompany/libs/auth v0.2.0
+     github.com/mycompany/libs/database v0.1.5
+ )
+ &#96;&#96;&#96;
+ 
+ For published modules, this just works—Go fetches from the module proxy.
+ 
+ For local development without &#96;go.work&#96;, you'd need &#96;replace&#96; directives:
+ 
+ &#96;&#96;&#96;go
+ // services/api/go.mod (during local dev only)
+ replace github.com/mycompany/libs/auth =&gt; ../../libs/auth
+ replace github.com/mycompany/libs/database =&gt; ../../libs/database
+ &#96;&#96;&#96;
+ 
+ Workspaces make &#96;replace&#96; unnecessary for local work.
+ 
+ ## Versioning Strategy
+ 
+ Each module is versioned independently. The repo might look like:
+ 
+ &#96;&#96;&#96;
+ libs/auth           v0.2.0, v0.2.1, v0.3.0
+ libs/database       v0.1.0, v0.1.5
+ services/api        v1.0.0, v1.1.0
+ services/worker     v1.0.0
+ &#96;&#96;&#96;
+ 
+ Use git tags to version modules:
+ 
+ &#96;&#96;&#96;bash
+ git tag libs/auth/v0.3.0
+ git push origin libs/auth/v0.3.0
+ &#96;&#96;&#96;
+ 
+ The tag format &#96;path/vX.Y.Z&#96; tells Go which module the version applies to.
+ 
+ ## Comparing to .NET
+ 
+ C#'s approach to monorepos is different:
+ 
+ | Aspect | .NET | Go |
+ |--------|------|-----|
+ | Project file | &#96;.csproj&#96; per project | &#96;go.mod&#96; per module |
+ | Solution | &#96;.sln&#96; groups projects | &#96;go.work&#96; for workspace |
+ | Local references | &#96;&lt;ProjectReference&gt;&#96; | &#96;replace&#96; or &#96;go.work&#96; |
+ | Versioning | NuGet packages | Module versions (git tags) |
+ | Build all | &#96;dotnet build MySolution.sln&#96; | &#96;go build ./...&#96; |
+ | Private packages | Private NuGet feed | Private GOPROXY or replace |
+ 
+ .NET's solution file is more mature for multi-project scenarios. &#96;go.work&#96; is newer and simpler.
+ 
+ ## The Practical Workflow
+ 
+ ### Adding a New Module
+ 
+ &#96;&#96;&#96;bash
+ mkdir -p services/newservice
+ cd services/newservice
+ go mod init github.com/mycompany/services/newservice
+ &#96;&#96;&#96;
+ 
+ Add to &#96;go.work&#96;:
+ 
+ &#96;&#96;&#96;go
+ use (
+     // ... existing
+     ./services/newservice
+ )
+ &#96;&#96;&#96;
+ 
+ ### Depending on a Local Module
+ 
+ In your module's code:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/mycompany/libs/auth"
+ &#96;&#96;&#96;
+ 
+ Then run:
+ 
+ &#96;&#96;&#96;bash
+ go get github.com/mycompany/libs/auth@latest
+ # or specific version
+ go get github.com/mycompany/libs/auth@v0.2.0
+ &#96;&#96;&#96;
+ 
+ ### Releasing a Module
+ 
+ 1. Make your changes
+ 2. Update version in dependents' &#96;go.mod&#96; files
+ 3. Commit everything
+ 4. Tag the module: &#96;git tag libs/auth/v0.3.0&#96;
+ 5. Push: &#96;git push origin libs/auth/v0.3.0&#96;
+ 
+ ### CI/CD Considerations
+ 
+ Your CI shouldn't use &#96;go.work&#96;—it should test each module independently:
+ 
+ &#96;&#96;&#96;yaml
+ # Example GitHub Actions
+ jobs:
+   test-auth:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - working-directory: libs/auth
+         run: go test ./...
+ 
+   test-api:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - working-directory: services/api
+         run: go test ./...
+ &#96;&#96;&#96;
+ 
+ Each module builds and tests in isolation.
+ 
+ ## When NOT to Multi-Module
+ 
+ Multi-module adds complexity. Avoid it if:
+ 
+ - Your code is tightly coupled anyway
+ - You don't need independent versioning
+ - You're the only developer
+ - The repo isn't that big yet
+ 
+ Start with one module. Split when you feel the pain.
+ 
+ ## The Honest Take
+ 
+ Go workspaces solved the biggest pain point (local development), but multi-module repos are still more work than single modules.
+ 
+ **What Go does okay:**
+ - Workspaces make local dev tolerable
+ - Independent versioning is powerful
+ - Module isolation is clear
+ 
+ **What's still awkward:**
+ - Tag-based versioning for paths is clunky (&#96;libs/auth/v0.3.0&#96;)
+ - No solution-level dependency management
+ - CI needs to understand module structure
+ - Tooling is module-centric, not repo-centric
+ 
+ **What .NET does better:**
+ - Solution files coordinate multiple projects elegantly
+ - Project references just work
+ - NuGet versioning is more flexible
+ - Better IDE support for multi-project workflows
+ 
+ **The verdict:**
+ If you need multi-module, Go can do it. But it's not as polished as .NET's multi-project experience. Keep your module count low, use workspaces for local dev, and accept some ceremony around releases.
+ 
+ ---
+ 
+ *Next up: testing in Go—why the built-in testing package might be all you need, and why you might not miss xUnit.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-testing.md</summary>

**Chunk 1**
Lines added: 323, lines removed: 1

```diff
@@ -1,1 +1,323 @@
- 
+ +++
+ title = "Testing Without a Framework"
+ date = "2025-01-03"
+ draft = false
+ tags = ["go", "dotnet", "testing", "csharp"]
+ +++
+ 
+ In C#, you pick a test framework: xUnit, NUnit, MSTest. You install packages. You learn attributes. You configure test runners.
+ 
+ In Go, you run &#96;go test&#96;. That's it. There's one testing approach, it's built in, and it's been there since the beginning.
+ 
+ This felt limiting at first. "Where are my attributes? Where's my dependency injection? Where's my &#96;[Theory]&#96; with &#96;[InlineData]&#96;?" Then I wrote some tests and realised: Go's simplicity is the point.
+ 
+ ## The Basics
+ 
+ Test files end in &#96;_test.go&#96;. Test functions start with &#96;Test&#96;:
+ 
+ &#96;&#96;&#96;go
+ // math.go
+ package math
+ 
+ func Add(a, b int) int {
+     return a + b
+ }
+ 
+ // math_test.go
+ package math
+ 
+ import "testing"
+ 
+ func TestAdd(t *testing.T) {
+     result := Add(2, 3)
+     if result != 5 {
+         t.Errorf("Add(2, 3) = %d; want 5", result)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Run with:
+ 
+ &#96;&#96;&#96;bash
+ go test
+ go test -v           # verbose output
+ go test ./...        # all packages
+ go test -run TestAdd # specific test
+ &#96;&#96;&#96;
+ 
+ No attributes. No framework imports. Just a function that takes &#96;*testing.T&#96;.
+ 
+ ## Comparing to xUnit
+ 
+ Here's the same test in xUnit:
+ 
+ &#96;&#96;&#96;csharp
+ public class MathTests
+ {
+     [Fact]
+     public void Add_TwoNumbers_ReturnsSum()
+     {
+         var result = Math.Add(2, 3);
+         Assert.Equal(5, result);
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Go's version is more verbose in the assertion (&#96;if&#96; + &#96;t.Errorf&#96; vs &#96;Assert.Equal&#96;), but there's no class wrapper, no attribute, no dependency on a test framework package.
+ 
+ ## The testing.T Type
+ 
+ The &#96;*testing.T&#96; parameter is your test context. Key methods:
+ 
+ &#96;&#96;&#96;go
+ func TestSomething(t *testing.T) {
+     t.Log("informational message")      // only shown with -v
+     t.Error("test failed but continue") // marks fail, continues
+     t.Fatal("test failed, stop now")    // marks fail, stops this test
+     t.Skip("skipping this test")        // skips test
+     
+     // Formatted versions
+     t.Logf("value is %d", 42)
+     t.Errorf("got %d, want %d", actual, expected)
+     t.Fatalf("unexpected error: %v", err)
+ }
+ &#96;&#96;&#96;
+ 
+ No assertion library needed. You write &#96;if&#96; statements and call &#96;t.Error&#96; or &#96;t.Fatal&#96;.
+ 
+ ## Table-Driven Tests
+ 
+ This is Go's answer to &#96;[Theory]&#96; with &#96;[InlineData]&#96;. Instead of attributes, you use a slice of test cases:
+ 
+ &#96;&#96;&#96;go
+ func TestAdd(t *testing.T) {
+     tests := []struct {
+         name     string
+         a, b     int
+         expected int
+     }{
+         {"positive numbers", 2, 3, 5},
+         {"negative numbers", -1, -1, -2},
+         {"zero", 0, 0, 0},
+         {"mixed", -5, 10, 5},
+     }
+ 
+     for _, tt := range tests {
+         t.Run(tt.name, func(t *testing.T) {
+             result := Add(tt.a, tt.b)
+             if result != tt.expected {
+                 t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, result, tt.expected)
+             }
+         })
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;t.Run&#96; creates a subtest. Each case runs independently, shows up separately in output, and can be run individually:
+ 
+ &#96;&#96;&#96;bash
+ go test -run TestAdd/positive_numbers
+ &#96;&#96;&#96;
+ 
+ Compare to xUnit:
+ 
+ &#96;&#96;&#96;csharp
+ [Theory]
+ [InlineData(2, 3, 5)]
+ [InlineData(-1, -1, -2)]
+ [InlineData(0, 0, 0)]
+ [InlineData(-5, 10, 5)]
+ public void Add_VariousInputs_ReturnsExpected(int a, int b, int expected)
+ {
+     Assert.Equal(expected, Math.Add(a, b));
+ }
+ &#96;&#96;&#96;
+ 
+ xUnit is more concise. Go's version is more explicit and doesn't require learning attribute syntax. Personal preference.
+ 
+ ## Test Setup and Teardown
+ 
+ No &#96;[SetUp]&#96; or &#96;[TearDown]&#96; attributes. Use regular functions:
+ 
+ &#96;&#96;&#96;go
+ func TestWithSetup(t *testing.T) {
+     // Setup
+     db := setupTestDatabase()
+     defer db.Close()  // Teardown
+     
+     // Test
+     result := QueryUsers(db)
+     if len(result) != 0 {
+         t.Error("expected empty database")
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ For shared setup across tests, use &#96;TestMain&#96;:
+ 
+ &#96;&#96;&#96;go
+ var testDB *Database
+ 
+ func TestMain(m *testing.M) {
+     // Setup before all tests
+     testDB = setupTestDatabase()
+     
+     // Run tests
+     code := m.Run()
+     
+     // Teardown after all tests
+     testDB.Close()
+     
+     os.Exit(code)
+ }
+ 
+ func TestSomething(t *testing.T) {
+     // testDB is available
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;TestMain&#96; is the entry point for the test binary. It's like a test fixture that wraps all tests.
+ 
+ ## Parallel Tests
+ 
+ Run tests in parallel:
+ 
+ &#96;&#96;&#96;go
+ func TestParallel1(t *testing.T) {
+     t.Parallel()
+     // This test can run alongside other parallel tests
+ }
+ 
+ func TestParallel2(t *testing.T) {
+     t.Parallel()
+     // So can this one
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;t.Parallel()&#96; marks a test as safe to run concurrently. Go runs parallel tests up to &#96;GOMAXPROCS&#96; simultaneously.
+ 
+ ## Test Coverage
+ 
+ Built in:
+ 
+ &#96;&#96;&#96;bash
+ go test -cover                     # show coverage percentage
+ go test -coverprofile=coverage.out # generate profile
+ go tool cover -html=coverage.out   # view in browser
+ &#96;&#96;&#96;
+ 
+ No third-party tools needed. Coverage is a first-class feature.
+ 
+ ## Subtests for Organisation
+ 
+ Group related tests:
+ 
+ &#96;&#96;&#96;go
+ func TestUser(t *testing.T) {
+     t.Run("Create", func(t *testing.T) {
+         t.Run("valid input", func(t *testing.T) { ... })
+         t.Run("missing name", func(t *testing.T) { ... })
+         t.Run("invalid email", func(t *testing.T) { ... })
+     })
+     
+     t.Run("Update", func(t *testing.T) {
+         t.Run("existing user", func(t *testing.T) { ... })
+         t.Run("non-existent user", func(t *testing.T) { ... })
+     })
+ }
+ &#96;&#96;&#96;
+ 
+ Run specific groups:
+ 
+ &#96;&#96;&#96;bash
+ go test -run TestUser/Create
+ go test -run TestUser/Create/valid_input
+ &#96;&#96;&#96;
+ 
+ ## Helper Functions
+ 
+ Mark a function as a test helper so errors report the caller's line:
+ 
+ &#96;&#96;&#96;go
+ func assertEqual(t *testing.T, got, want int) {
+     t.Helper()  // errors will show caller's line number
+     if got != want {
+         t.Errorf("got %d, want %d", got, want)
+     }
+ }
+ 
+ func TestSomething(t *testing.T) {
+     assertEqual(t, Add(2, 2), 4)  // error shows this line, not assertEqual
+ }
+ &#96;&#96;&#96;
+ 
+ ## What About Assertions?
+ 
+ Go's standard library has no assertion functions. You write:
+ 
+ &#96;&#96;&#96;go
+ if result != expected {
+     t.Errorf("got %v, want %v", result, expected)
+ }
+ &#96;&#96;&#96;
+ 
+ Instead of:
+ 
+ &#96;&#96;&#96;csharp
+ Assert.Equal(expected, result);
+ &#96;&#96;&#96;
+ 
+ This is verbose. Many people use the &#96;testify&#96; package for assertions:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/stretchr/testify/assert"
+ 
+ func TestAdd(t *testing.T) {
+     assert.Equal(t, 5, Add(2, 3))
+     assert.NotNil(t, somePointer)
+     assert.Contains(t, "hello world", "world")
+ }
+ &#96;&#96;&#96;
+ 
+ Testify is popular, but some Go developers consider it unnecessary. The standard approach works fine; it's just more typing.
+ 
+ ## The Comparison
+ 
+ | Feature | xUnit/NUnit | Go testing |
+ |---------|-------------|------------|
+ | Test discovery | Attributes | Naming convention (&#96;Test*&#96;) |
+ | Assertions | Rich library | Manual or testify |
+ | Parameterised tests | &#96;[Theory]&#96; | Table-driven |
+ | Setup/Teardown | Attributes | Manual or &#96;TestMain&#96; |
+ | Parallel | &#96;[Collection]&#96; | &#96;t.Parallel()&#96; |
+ | Coverage | Third-party or VS | Built-in |
+ | Mocking | Moq, NSubstitute | Interfaces + manual |
+ | Test runner | Separate tool | &#96;go test&#96; |
+ 
+ ## The Honest Take
+ 
+ Go's testing is simpler but more manual. You write more code per test, but there's less framework magic to understand.
+ 
+ **What Go does better:**
+ - Zero dependencies for basic testing
+ - Coverage built in
+ - &#96;go test&#96; just works
+ - Table-driven tests are powerful
+ - No framework version conflicts
+ 
+ **What C# does better:**
+ - Rich assertion libraries
+ - Better IDE integration (Test Explorer)
+ - More flexible parameterised tests
+ - Better test output formatting
+ - Mature mocking ecosystem
+ 
+ **The verdict:**
+ For simple unit tests, Go's built-in testing is fine. You'll write more boilerplate, but you'll spend zero time configuring frameworks.
+ 
+ For complex test scenarios, you might miss xUnit's features. But honestly? Most tests are simple. Go's approach handles them perfectly well.
+ 
+ ---
+ 
+ *Next up: mocking in Go—interfaces, hand-written fakes, and when to reach for testify/mock.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-mocking.md</summary>

**Chunk 1**
Lines added: 338, lines removed: 1

```diff
@@ -1,1 +1,338 @@
- 
+ +++
+ title = "Mocking in a Language Without Mockito"
+ date = "2025-01-03"
+ draft = false
+ tags = ["go", "dotnet", "testing", "mocking", "csharp"]
+ +++
+ 
+ In C#, you reach for Moq or NSubstitute without thinking. Interface? Mock it. Verify calls? Easy. Set up return values? One line.
+ 
+ Go doesn't have a standard mocking framework. There's no reflection-based proxy generation. No &#96;Mock&lt;IUserService&gt;()&#96;. The Go way is more manual, and that's... actually fine? Let me explain.
+ 
+ ## The C# Approach
+ 
+ You've done this a thousand times:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IUserRepository
+ {
+     User GetById(int id);
+     void Save(User user);
+ }
+ 
+ [Fact]
+ public void ProcessUser_CallsRepository()
+ {
+     var mockRepo = new Mock&lt;IUserRepository&gt;();
+     mockRepo.Setup(r =&gt; r.GetById(1)).Returns(new User { Id = 1, Name = "Alice" });
+     
+     var service = new UserService(mockRepo.Object);
+     service.Process(1);
+     
+     mockRepo.Verify(r =&gt; r.GetById(1), Times.Once);
+ }
+ &#96;&#96;&#96;
+ 
+ Clean, expressive, powerful. Moq generates a proxy class at runtime that implements the interface and records calls.
+ 
+ ## The Go Approach: Hand-Written Fakes
+ 
+ Go doesn't have reflection-based mocking (well, it does, but it's not idiomatic). Instead, you write your own test doubles:
+ 
+ &#96;&#96;&#96;go
+ type UserRepository interface {
+     GetByID(id int) (*User, error)
+     Save(user *User) error
+ }
+ 
+ // Fake implementation for testing
+ type FakeUserRepo struct {
+     Users map[int]*User
+     SaveCalled bool
+     SavedUser *User
+ }
+ 
+ func (f *FakeUserRepo) GetByID(id int) (*User, error) {
+     user, ok := f.Users[id]
+     if !ok {
+         return nil, ErrNotFound
+     }
+     return user, nil
+ }
+ 
+ func (f *FakeUserRepo) Save(user *User) error {
+     f.SaveCalled = true
+     f.SavedUser = user
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Then in your test:
+ 
+ &#96;&#96;&#96;go
+ func TestProcessUser(t *testing.T) {
+     repo := &amp;FakeUserRepo{
+         Users: map[int]*User{
+             1: {ID: 1, Name: "Alice"},
+         },
+     }
+     
+     service := NewUserService(repo)
+     service.Process(1)
+     
+     if !repo.SaveCalled {
+         t.Error("expected Save to be called")
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ More code. More manual work. But you control everything, and there's no magic.
+ 
+ ## Why Go Developers Accept This
+ 
+ Three reasons:
+ 
+ **1. Interfaces are small**
+ 
+ Go's implicit interfaces encourage tiny interfaces. One or two methods. Writing a fake for a two-method interface is trivial.
+ 
+ &#96;&#96;&#96;go
+ type Saver interface {
+     Save(user *User) error
+ }
+ 
+ // Fake is one function
+ type FakeSaver struct {
+     Err error
+ }
+ 
+ func (f *FakeSaver) Save(user *User) error {
+     return f.Err
+ }
+ &#96;&#96;&#96;
+ 
+ Compare to C#'s larger interfaces with 10+ methods. Moq saves significant effort there.
+ 
+ **2. Fakes are reusable**
+ 
+ You write the fake once, use it everywhere. Put it in a &#96;testing&#96; package or &#96;_test.go&#96; file:
+ 
+ &#96;&#96;&#96;go
+ // In repository/testing.go or repository/fake_test.go
+ type FakeUserRepo struct { ... }
+ &#96;&#96;&#96;
+ 
+ Now all tests can use it. The upfront cost pays off.
+ 
+ **3. Explicit is better than magic**
+ 
+ Go's philosophy. When a test fails, you can see exactly what the fake does. No proxy magic. No setup/verify DSL to decode.
+ 
+ ## The testify/mock Package
+ 
+ If you really want Moq-style mocking, testify provides it:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/stretchr/testify/mock"
+ 
+ type MockUserRepo struct {
+     mock.Mock
+ }
+ 
+ func (m *MockUserRepo) GetByID(id int) (*User, error) {
+     args := m.Called(id)
+     if args.Get(0) == nil {
+         return nil, args.Error(1)
+     }
+     return args.Get(0).(*User), args.Error(1)
+ }
+ 
+ func (m *MockUserRepo) Save(user *User) error {
+     args := m.Called(user)
+     return args.Error(0)
+ }
+ &#96;&#96;&#96;
+ 
+ Then use it:
+ 
+ &#96;&#96;&#96;go
+ func TestProcessUser(t *testing.T) {
+     repo := new(MockUserRepo)
+     repo.On("GetByID", 1).Return(&amp;User{ID: 1, Name: "Alice"}, nil)
+     repo.On("Save", mock.Anything).Return(nil)
+     
+     service := NewUserService(repo)
+     service.Process(1)
+     
+     repo.AssertCalled(t, "Save", mock.Anything)
+ }
+ &#96;&#96;&#96;
+ 
+ Closer to Moq, but you still write the mock struct manually. testify handles the setup/verification plumbing.
+ 
+ ## Generated Mocks: mockgen and mockery
+ 
+ Tools can generate mock implementations:
+ 
+ **mockgen** (from gomock):
+ 
+ &#96;&#96;&#96;bash
+ mockgen -source=repository.go -destination=mock_repository.go
+ &#96;&#96;&#96;
+ 
+ **mockery**:
+ 
+ &#96;&#96;&#96;bash
+ mockery --name=UserRepository
+ &#96;&#96;&#96;
+ 
+ These generate the boilerplate. You still use them manually in tests.
+ 
+ ## Patterns for Effective Fakes
+ 
+ ### Function Fields
+ 
+ For simple cases, use function fields:
+ 
+ &#96;&#96;&#96;go
+ type FakeNotifier struct {
+     NotifyFunc func(userID int, message string) error
+ }
+ 
+ func (f *FakeNotifier) Notify(userID int, message string) error {
+     if f.NotifyFunc != nil {
+         return f.NotifyFunc(userID, message)
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ In tests:
+ 
+ &#96;&#96;&#96;go
+ notifier := &amp;FakeNotifier{
+     NotifyFunc: func(userID int, message string) error {
+         if userID != 1 {
+             t.Errorf("unexpected userID: %d", userID)
+         }
+         return nil
+     },
+ }
+ &#96;&#96;&#96;
+ 
+ Inline behaviour per test. No shared state.
+ 
+ ### Recording Calls
+ 
+ Track what was called:
+ 
+ &#96;&#96;&#96;go
+ type FakeNotifier struct {
+     Calls []NotifyCall
+ }
+ 
+ type NotifyCall struct {
+     UserID  int
+     Message string
+ }
+ 
+ func (f *FakeNotifier) Notify(userID int, message string) error {
+     f.Calls = append(f.Calls, NotifyCall{userID, message})
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Then assert:
+ 
+ &#96;&#96;&#96;go
+ if len(notifier.Calls) != 1 {
+     t.Errorf("expected 1 call, got %d", len(notifier.Calls))
+ }
+ if notifier.Calls[0].UserID != 1 {
+     t.Errorf("wrong userID: %d", notifier.Calls[0].UserID)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Error Injection
+ 
+ Make errors configurable:
+ 
+ &#96;&#96;&#96;go
+ type FakeRepo struct {
+     GetErr  error
+     SaveErr error
+ }
+ 
+ func (f *FakeRepo) GetByID(id int) (*User, error) {
+     if f.GetErr != nil {
+         return nil, f.GetErr
+     }
+     return &amp;User{ID: id}, nil
+ }
+ &#96;&#96;&#96;
+ 
+ Test error paths:
+ 
+ &#96;&#96;&#96;go
+ repo := &amp;FakeRepo{GetErr: sql.ErrNoRows}
+ // test handles error correctly
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Feature | Moq/NSubstitute | Go Fakes | testify/mock |
+ |---------|-----------------|----------|--------------|
+ | Boilerplate | None | Manual | Some |
+ | Setup syntax | Fluent | Manual | Method calls |
+ | Verification | Built-in | Manual | Built-in |
+ | Type safety | Good | Excellent | Okay (strings) |
+ | Debugging | Proxy magic | Clear code | Some magic |
+ | Learning curve | Moderate | Low | Low |
+ | Generation | Not needed | Optional | Optional |
+ 
+ ## When to Use What
+ 
+ **Hand-written fakes when:**
+ - Interface is small (1-3 methods)
+ - You need the fake in multiple tests
+ - You want maximum clarity
+ - You prefer no dependencies
+ 
+ **testify/mock when:**
+ - Interface is larger
+ - You need verification of call counts/order
+ - You're comfortable with the DSL
+ - You want Moq-like experience
+ 
+ **Generated mocks when:**
+ - Interface is large and changes frequently
+ - You have many interfaces to mock
+ - You want consistency across the codebase
+ 
+ ## The Honest Take
+ 
+ I thought I'd miss Moq. I don't, really.
+ 
+ **What Go does better:**
+ - No mock magic to debug
+ - Fakes are real code you can step through
+ - Small interfaces mean small fakes
+ - No framework dependency
+ 
+ **What C# does better:**
+ - Zero boilerplate for any interface
+ - Powerful verification syntax
+ - Better for large interfaces
+ - Established patterns and tooling
+ 
+ **The verdict:**
+ Go's approach is more work for each interface, but that work is simple and debuggable. If you design with small interfaces (as Go encourages), the fake-writing burden is minimal.
+ 
+ Start with hand-written fakes. Reach for testify/mock if you find yourself writing the same patterns repeatedly. Use generated mocks for genuinely large interfaces.
+ 
+ The bigger lesson: good interface design reduces mocking complexity in any language. Go just makes that more obvious.
+ 
+ ---
+ 
+ *Next up: benchmarks and profiling—&#96;go test -bench&#96; and pprof for understanding where your performance actually goes.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-benchmarks.md</summary>

**Chunk 1**
Lines added: 349, lines removed: 1

```diff
@@ -1,1 +1,349 @@
- 
+ +++
+ title = "Benchmarks and Profiling Out of the Box"
+ date = "2025-01-03"
+ draft = false
+ tags = ["go", "dotnet", "testing", "performance", "benchmarks", "csharp"]
+ +++
+ 
+ Here's something that surprised me: Go has built-in benchmarking. No BenchmarkDotNet to install. No configuration. Write a function, run &#96;go test -bench&#96;, get numbers.
+ 
+ And profiling? Also built in. CPU profiles, memory profiles, blocking profiles—all from the standard toolchain.
+ 
+ Coming from .NET where you install BenchmarkDotNet for proper benchmarks and a separate profiler for profiling, Go's integrated approach is refreshing.
+ 
+ ## Writing Benchmarks
+ 
+ Benchmark functions start with &#96;Benchmark&#96; and take &#96;*testing.B&#96;:
+ 
+ &#96;&#96;&#96;go
+ func BenchmarkAdd(b *testing.B) {
+     for i := 0; i &lt; b.N; i++ {
+         Add(2, 3)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ That &#96;b.N&#96; is key. The framework controls it, running your code enough times to get stable measurements.
+ 
+ Run with:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=.                    # all benchmarks
+ go test -bench=BenchmarkAdd         # specific benchmark
+ go test -bench=. -benchtime=5s      # run for 5 seconds
+ go test -bench=. -count=10          # run 10 times
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ BenchmarkAdd-8    1000000000    0.3192 ns/op
+ &#96;&#96;&#96;
+ 
+ Translation: on 8 cores, ran 1 billion iterations, each took ~0.32 nanoseconds.
+ 
+ ## Comparing to BenchmarkDotNet
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ [Benchmark]
+ public int Add() =&gt; Math.Add(2, 3);
+ &#96;&#96;&#96;
+ 
+ Then run the benchmark project. BenchmarkDotNet gives you beautiful output, statistical analysis, memory diagnostics, multiple runtimes...
+ 
+ Go's benchmarks are simpler. Less analysis, less ceremony, faster feedback.
+ 
+ ## Benchmarking with Setup
+ 
+ Don't include setup in the measured loop:
+ 
+ &#96;&#96;&#96;go
+ func BenchmarkParse(b *testing.B) {
+     data := loadTestData()  // setup, not measured
+     
+     b.ResetTimer()  // start timing from here
+     
+     for i := 0; i &lt; b.N; i++ {
+         Parse(data)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;b.ResetTimer()&#96; excludes setup time from measurements.
+ 
+ ## Memory Benchmarks
+ 
+ Track allocations:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=. -benchmem
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ BenchmarkParse-8    50000    32145 ns/op    4096 B/op    12 allocs/op
+ &#96;&#96;&#96;
+ 
+ Now you see: 4096 bytes allocated per operation, 12 separate allocations.
+ 
+ You can also report memory in code:
+ 
+ &#96;&#96;&#96;go
+ func BenchmarkAllocations(b *testing.B) {
+     b.ReportAllocs()
+     for i := 0; i &lt; b.N; i++ {
+         _ = make([]byte, 1024)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## Benchmark Comparison
+ 
+ Compare different implementations:
+ 
+ &#96;&#96;&#96;go
+ func BenchmarkConcatPlus(b *testing.B) {
+     for i := 0; i &lt; b.N; i++ {
+         s := "hello" + " " + "world"
+         _ = s
+     }
+ }
+ 
+ func BenchmarkConcatBuilder(b *testing.B) {
+     for i := 0; i &lt; b.N; i++ {
+         var sb strings.Builder
+         sb.WriteString("hello")
+         sb.WriteString(" ")
+         sb.WriteString("world")
+         _ = sb.String()
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Run both:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=BenchmarkConcat
+ &#96;&#96;&#96;
+ 
+ Use &#96;benchstat&#96; for statistical comparison:
+ 
+ &#96;&#96;&#96;bash
+ go install golang.org/x/perf/cmd/benchstat@latest
+ 
+ go test -bench=. -count=10 &gt; old.txt
+ # make changes
+ go test -bench=. -count=10 &gt; new.txt
+ 
+ benchstat old.txt new.txt
+ &#96;&#96;&#96;
+ 
+ Output shows whether changes are statistically significant.
+ 
+ ## Sub-Benchmarks
+ 
+ Test different sizes:
+ 
+ &#96;&#96;&#96;go
+ func BenchmarkSort(b *testing.B) {
+     sizes := []int{10, 100, 1000, 10000}
+     
+     for _, size := range sizes {
+         b.Run(fmt.Sprintf("size=%d", size), func(b *testing.B) {
+             data := generateData(size)
+             b.ResetTimer()
+             
+             for i := 0; i &lt; b.N; i++ {
+                 sort.Ints(data)
+             }
+         })
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ BenchmarkSort/size=10-8       5000000     234 ns/op
+ BenchmarkSort/size=100-8       500000    3456 ns/op
+ BenchmarkSort/size=1000-8       30000   45678 ns/op
+ BenchmarkSort/size=10000-8       2000  678901 ns/op
+ &#96;&#96;&#96;
+ 
+ ## CPU Profiling
+ 
+ Generate a CPU profile:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=. -cpuprofile=cpu.prof
+ &#96;&#96;&#96;
+ 
+ Analyse with pprof:
+ 
+ &#96;&#96;&#96;bash
+ go tool pprof cpu.prof
+ &#96;&#96;&#96;
+ 
+ Interactive commands:
+ 
+ &#96;&#96;&#96;
+ (pprof) top           # hottest functions
+ (pprof) top --cum     # including callees
+ (pprof) list FuncName # source annotation
+ (pprof) web           # open graph in browser
+ &#96;&#96;&#96;
+ 
+ Or the web UI:
+ 
+ &#96;&#96;&#96;bash
+ go tool pprof -http=:8080 cpu.prof
+ &#96;&#96;&#96;
+ 
+ Opens a browser with flame graphs, call graphs, source annotations.
+ 
+ ## Memory Profiling
+ 
+ Generate memory profiles:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=. -memprofile=mem.prof
+ &#96;&#96;&#96;
+ 
+ Analyse:
+ 
+ &#96;&#96;&#96;bash
+ go tool pprof mem.prof
+ (pprof) top           # biggest allocators
+ (pprof) list FuncName # source with allocation sizes
+ &#96;&#96;&#96;
+ 
+ Two views:
+ 
+ &#96;&#96;&#96;bash
+ go tool pprof -alloc_space mem.prof  # total bytes allocated
+ go tool pprof -inuse_space mem.prof  # bytes in use at snapshot
+ &#96;&#96;&#96;
+ 
+ ## Runtime Profiling
+ 
+ For running applications (not benchmarks):
+ 
+ &#96;&#96;&#96;go
+ import (
+     "net/http"
+     _ "net/http/pprof"  // side-effect import
+ )
+ 
+ func main() {
+     go func() {
+         http.ListenAndServe("localhost:6060", nil)
+     }()
+     
+     // your application
+ }
+ &#96;&#96;&#96;
+ 
+ Now you can:
+ 
+ &#96;&#96;&#96;bash
+ go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
+ go tool pprof http://localhost:6060/debug/pprof/heap
+ go tool pprof http://localhost:6060/debug/pprof/goroutine
+ &#96;&#96;&#96;
+ 
+ Profile a live application without restarting.
+ 
+ ## The Comparison
+ 
+ | Feature | BenchmarkDotNet | Go Benchmarks |
+ |---------|-----------------|---------------|
+ | Setup | NuGet + project | Built-in |
+ | Statistical analysis | Extensive | Basic (use benchstat) |
+ | Memory tracking | Detailed | Good |
+ | Profiling integration | Separate tools | Built-in |
+ | Output format | Beautiful | Functional |
+ | Multiple runtimes | Yes | No (just Go) |
+ | Configuration | Attributes | Code |
+ 
+ ## Practical Tips
+ 
+ ### Avoid Compiler Optimisation
+ 
+ The compiler might optimise away unused results:
+ 
+ &#96;&#96;&#96;go
+ // BAD: compiler might skip the work
+ func BenchmarkBad(b *testing.B) {
+     for i := 0; i &lt; b.N; i++ {
+         Add(2, 3)  // result unused, might be optimised away
+     }
+ }
+ 
+ // GOOD: use the result
+ var result int
+ 
+ func BenchmarkGood(b *testing.B) {
+     var r int
+     for i := 0; i &lt; b.N; i++ {
+         r = Add(2, 3)
+     }
+     result = r  // prevent optimisation
+ }
+ &#96;&#96;&#96;
+ 
+ ### Benchmark What Matters
+ 
+ Don't benchmark trivial operations:
+ 
+ &#96;&#96;&#96;go
+ // Pointless: measures loop overhead more than Add
+ func BenchmarkTrivial(b *testing.B) {
+     for i := 0; i &lt; b.N; i++ {
+         _ = 2 + 3
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Benchmark real workloads with realistic data sizes.
+ 
+ ### Profile Before Optimising
+ 
+ Don't guess. Profile first:
+ 
+ &#96;&#96;&#96;bash
+ go test -bench=SlowFunction -cpuprofile=cpu.prof
+ go tool pprof -http=:8080 cpu.prof
+ &#96;&#96;&#96;
+ 
+ Find the actual bottleneck. Often it's not where you'd expect.
+ 
+ ## The Honest Take
+ 
+ Go's built-in benchmarking is one of its genuinely great features. Zero setup, good enough for most needs.
+ 
+ **What Go does better:**
+ - Zero dependencies for benchmarking
+ - Integrated profiling
+ - pprof is excellent
+ - Quick feedback loop
+ - Live application profiling is easy
+ 
+ **What BenchmarkDotNet does better:**
+ - More rigorous statistical analysis
+ - Better output formatting
+ - Multiple runtime comparison
+ - More configuration options
+ - Memory diagnostics are more detailed
+ 
+ **The verdict:**
+ For day-to-day "is this fast enough?" benchmarking, Go's built-in tools are excellent. For publishing performance claims or deep analysis, BenchmarkDotNet is more thorough.
+ 
+ But Go wins on the "I can just do this" factor. No packages to install. No project to configure. Write a function, run a command, get numbers. That low friction means you actually benchmark things.
+ 
+ ---
+ 
+ *That wraps up Phase 2 on the ecosystem—project structure, testing, mocking, and benchmarking. These are the tools you'll use every day. Go's approach is consistently simpler than .NET's, with trade-offs in power and flexibility. But for most work, simpler is better.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      27
---
content/posts/dotnet-to-go-any.md
content/posts/dotnet-to-go-benchmarks.md
content/posts/dotnet-to-go-channels.md
content/posts/dotnet-to-go-composition.md
content/posts/dotnet-to-go-context.md
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-goroutines.md
content/posts/dotnet-to-go-interfaces.md
content/posts/dotnet-to-go-mocking.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-monorepo.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-project-structure.md
content/posts/dotnet-to-go-select.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-sync.md
content/posts/dotnet-to-go-testing.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 27 posts are done and the build passes. Let me summarize the complete series for the user.</details></think>

---

All 5 Phase 2 Ecosystem posts done! **27 posts total now.** Here's the complete series:

## C# to Go Series (27 posts)

### Phase 1: The Fundamentals

**Getting Oriented (3)**
1. "You Know .NET, Now Meet the Go Toolchain"
2. "Goodbye .csproj, Hello go.mod"
3. "The Phrasebook: C# Concepts in Go Terms"

**Types & Data (5)**
4. "Your Class Is Now a Struct (And That's Fine)"
5. "Where Did My Properties Go?"
6. "Generics: Late to the Party"
7. "The Million Dollar Mistake, Differently"
8. "No Enums? No Problem (Sort Of)"

**Control Flow & Error Handling (3)**
9. "if err != nil: Your New Reality"
10. "Panic and Recover: The Emergency Exit"
11. "The switch Statement You Always Wanted"

**Memory & Pointers (3)**
12. "Pointers Without the Pain"
13. "Stack vs Heap: Go's Escape Analysis"
14. "Slices Are Not Arrays (And Neither Is List<T>)"

**Concurrency (5)**
15. "Async/Await vs Goroutines: A Mindset Shift"
16. "Channels: The sync You Didn't Know You Wanted"
17. "select: Multiplexing Like a Pro"
18. "Mutexes and WaitGroups: When Channels Aren't the Answer"
19. "Context Is King"

**Interfaces & Composition (3)**
20. "Implicit Interfaces: Scary Then Brilliant"
21. "Composition Over Inheritance (For Real This Time)"
22. "The Empty Interface and Type Assertions"

---

### Phase 2: The Ecosystem ← **NEW**

**Project Structure & Modules (2)**
23. **"Organising a Real Project"** — Package design, `internal/` enforcement, avoiding circular dependencies, the flat structure mental model
24. **"Multi-Module Repos: Monorepo Thinking"** — `go.work` workspaces, cross-module dependencies, versioning with path-prefixed tags

**Testing (3)**
25. **"Testing Without a Framework"** — Built-in `testing` package, `*testing.T`, table-driven tests, subtests, coverage, `TestMain`
26. **"Mocking in a Language Without Mockito"** — Hand-written fakes, function fields, testify/mock, generated mocks, why small interfaces make this bearable
27. **"Benchmarks and Profiling Out of the Box"** — `go test -bench`, `-benchmem`, CPU/memory profiling with pprof, comparing to BenchmarkDotNet

That's a proper comprehensive series! Ready for Phase 3 (Deployment) whenever you want to tackle containers, cloud, and CI/CD!

---

_**User (2025-12-30 00:39Z)**_

actually we have these to do before we get to deployment

Common Patterns & Libraries

HTTP Services: net/http vs ASP.NET Core — Handlers, middleware, and routers without the ceremony
JSON: struct Tags and the Marshal Dance — Newtonsoft this is not
Configuration Without IOptions<T> — Viper, envconfig, and keeping it simple
Logging: slog and the Structured Logging Story — From ILogger to Go's new standard
Database Access: database/sql vs Entity Framework — Connection pooling, scanning rows, and missing your ORM
GORM and Friends: When You Do Want an ORM — Trade-offs for C# devs used to EF Core

Tooling

Linting and Formatting: gofmt Is Non-Negotiable — golangci-lint, staticcheck, and embracing enforced style
Generate All the Things — go generate, code generation patterns, and why Go devs love it
Debugging: Delve vs Visual Studio's Comfort — Getting productive with dlv and your IDE

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create 9 more posts before deployment - 6 for Common Patterns & Libraries and 3 for Tooling. Let me write all 9 posts.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-http.md</summary>

**Chunk 1**
Lines added: 347, lines removed: 1

```diff
@@ -1,1 +1,347 @@
- 
+ +++
+ title = "HTTP Services: net/http vs ASP.NET Core"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "http", "web", "csharp"]
+ +++
+ 
+ ASP.NET Core is a sophisticated web framework. Dependency injection, middleware pipelines, model binding, routing with attributes, OpenAPI generation... it does a lot for you.
+ 
+ Go's &#96;net/http&#96; is a standard library package. It does HTTP. That's about it.
+ 
+ This sounds like a step down. It is, in some ways. But there's power in simplicity, and Go's HTTP story is more capable than it first appears.
+ 
+ ## The Simplest Server
+ 
+ Go:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "fmt"
+     "net/http"
+ )
+ 
+ func main() {
+     http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
+         fmt.Fprintf(w, "Hello, World!")
+     })
+     
+     http.ListenAndServe(":8080", nil)
+ }
+ &#96;&#96;&#96;
+ 
+ C# minimal API:
+ 
+ &#96;&#96;&#96;csharp
+ var app = WebApplication.Create();
+ app.MapGet("/", () =&gt; "Hello, World!");
+ app.Run();
+ &#96;&#96;&#96;
+ 
+ C#'s is shorter. But Go's has zero dependencies, zero configuration, and zero framework magic.
+ 
+ ## Handlers: The Building Block
+ 
+ In ASP.NET Core, you have controllers, minimal API delegates, or Razor Pages. In Go, you have handlers.
+ 
+ A handler is anything that implements &#96;http.Handler&#96;:
+ 
+ &#96;&#96;&#96;go
+ type Handler interface {
+     ServeHTTP(ResponseWriter, *Request)
+ }
+ &#96;&#96;&#96;
+ 
+ One method. That's it.
+ 
+ &#96;&#96;&#96;go
+ type HelloHandler struct {
+     greeting string
+ }
+ 
+ func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+     fmt.Fprintf(w, "%s, visitor!", h.greeting)
+ }
+ 
+ func main() {
+     http.Handle("/hello", HelloHandler{greeting: "Welcome"})
+     http.ListenAndServe(":8080", nil)
+ }
+ &#96;&#96;&#96;
+ 
+ Or use &#96;http.HandlerFunc&#96; for simpler cases:
+ 
+ &#96;&#96;&#96;go
+ http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
+     fmt.Fprintf(w, "Hello!")
+ })
+ &#96;&#96;&#96;
+ 
+ ## Request and Response
+ 
+ The &#96;*http.Request&#96; contains everything about the incoming request:
+ 
+ &#96;&#96;&#96;go
+ func handler(w http.ResponseWriter, r *http.Request) {
+     // Method
+     method := r.Method  // "GET", "POST", etc.
+     
+     // URL and path
+     path := r.URL.Path
+     query := r.URL.Query().Get("id")
+     
+     // Headers
+     contentType := r.Header.Get("Content-Type")
+     
+     // Body
+     body, _ := io.ReadAll(r.Body)
+     defer r.Body.Close()
+     
+     // Form data
+     r.ParseForm()
+     name := r.FormValue("name")
+     
+     // Context (for cancellation, deadlines, values)
+     ctx := r.Context()
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;http.ResponseWriter&#96; is how you respond:
+ 
+ &#96;&#96;&#96;go
+ func handler(w http.ResponseWriter, r *http.Request) {
+     // Set headers (before writing body)
+     w.Header().Set("Content-Type", "application/json")
+     
+     // Set status code (before writing body)
+     w.WriteHeader(http.StatusCreated)
+     
+     // Write body
+     w.Write([]byte(&#96;{"status": "ok"}&#96;))
+     
+     // Or use fmt
+     fmt.Fprintf(w, &#96;{"id": %d}&#96;, 123)
+ }
+ &#96;&#96;&#96;
+ 
+ Order matters: headers and status must be set before writing the body.
+ 
+ ## Routing: The Weak Spot
+ 
+ Go 1.22 improved the standard library router significantly:
+ 
+ &#96;&#96;&#96;go
+ mux := http.NewServeMux()
+ 
+ mux.HandleFunc("GET /users", listUsers)
+ mux.HandleFunc("POST /users", createUser)
+ mux.HandleFunc("GET /users/{id}", getUser)      // path parameters!
+ mux.HandleFunc("DELETE /users/{id}", deleteUser)
+ 
+ http.ListenAndServe(":8080", mux)
+ &#96;&#96;&#96;
+ 
+ Access path parameters:
+ 
+ &#96;&#96;&#96;go
+ func getUser(w http.ResponseWriter, r *http.Request) {
+     id := r.PathValue("id")  // Go 1.22+
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ Before 1.22, you needed a third-party router. Many projects still use them:
+ 
+ **chi** — lightweight, idiomatic:
+ &#96;&#96;&#96;go
+ r := chi.NewRouter()
+ r.Get("/users/{id}", getUser)
+ &#96;&#96;&#96;
+ 
+ **gorilla/mux** — feature-rich (now maintained by community):
+ &#96;&#96;&#96;go
+ r := mux.NewRouter()
+ r.HandleFunc("/users/{id}", getUser).Methods("GET")
+ &#96;&#96;&#96;
+ 
+ **gin** — fast, popular, framework-like:
+ &#96;&#96;&#96;go
+ r := gin.Default()
+ r.GET("/users/:id", getUser)
+ &#96;&#96;&#96;
+ 
+ If you're starting fresh with Go 1.22+, try the standard library first.
+ 
+ ## Middleware
+ 
+ Middleware in Go is just a function that wraps a handler:
+ 
+ &#96;&#96;&#96;go
+ func loggingMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         start := time.Now()
+         next.ServeHTTP(w, r)
+         log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
+     })
+ }
+ 
+ func authMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         token := r.Header.Get("Authorization")
+         if !isValidToken(token) {
+             http.Error(w, "Unauthorized", http.StatusUnauthorized)
+             return
+         }
+         next.ServeHTTP(w, r)
+     })
+ }
+ &#96;&#96;&#96;
+ 
+ Chain them:
+ 
+ &#96;&#96;&#96;go
+ handler := loggingMiddleware(authMiddleware(myHandler))
+ http.Handle("/api/", handler)
+ &#96;&#96;&#96;
+ 
+ Compare to ASP.NET Core:
+ 
+ &#96;&#96;&#96;csharp
+ app.UseLogging();
+ app.UseAuthentication();
+ app.MapControllers();
+ &#96;&#96;&#96;
+ 
+ Go's is more manual but the pattern is explicit.
+ 
+ ## Comparing to ASP.NET Core
+ 
+ | Feature | ASP.NET Core | Go net/http |
+ |---------|--------------|-------------|
+ | DI | Built-in | Manual or wire |
+ | Routing | Attribute or minimal | Method + path (1.22+) |
+ | Model binding | Automatic | Manual (JSON decode) |
+ | Validation | DataAnnotations | Manual or validator lib |
+ | Middleware | Pipeline | Function wrapping |
+ | OpenAPI | Swashbuckle | Third-party (swag, etc.) |
+ | Auth | Identity, policies | Manual or third-party |
+ | Config | IConfiguration | Environment or libs |
+ 
+ ASP.NET Core does more out of the box. Go makes you build it yourself or choose libraries.
+ 
+ ## A Realistic Handler
+ 
+ Here's what a real handler looks like:
+ 
+ &#96;&#96;&#96;go
+ type UserHandler struct {
+     repo UserRepository
+ }
+ 
+ func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
+     id := r.PathValue("id")
+     
+     user, err := h.repo.FindByID(r.Context(), id)
+     if err != nil {
+         if errors.Is(err, ErrNotFound) {
+             http.Error(w, "User not found", http.StatusNotFound)
+             return
+         }
+         http.Error(w, "Internal error", http.StatusInternalServerError)
+         return
+     }
+     
+     w.Header().Set("Content-Type", "application/json")
+     json.NewEncoder(w).Encode(user)
+ }
+ 
+ func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
+     var input CreateUserRequest
+     if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil {
+         http.Error(w, "Invalid JSON", http.StatusBadRequest)
+         return
+     }
+     
+     // Validation
+     if input.Email == "" {
+         http.Error(w, "Email required", http.StatusBadRequest)
+         return
+     }
+     
+     user, err := h.repo.Create(r.Context(), input)
+     if err != nil {
+         http.Error(w, "Failed to create user", http.StatusInternalServerError)
+         return
+     }
+     
+     w.Header().Set("Content-Type", "application/json")
+     w.WriteHeader(http.StatusCreated)
+     json.NewEncoder(w).Encode(user)
+ }
+ &#96;&#96;&#96;
+ 
+ More code than an ASP.NET Core controller. But you can see exactly what's happening.
+ 
+ ## Graceful Shutdown
+ 
+ Something ASP.NET Core handles automatically that Go requires explicitly:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     srv := &amp;http.Server{
+         Addr:    ":8080",
+         Handler: router,
+     }
+     
+     go func() {
+         if err := srv.ListenAndServe(); err != http.ErrServerClosed {
+             log.Fatalf("listen: %v", err)
+         }
+     }()
+     
+     // Wait for interrupt signal
+     quit := make(chan os.Signal, 1)
+     signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
+     &lt;-quit
+     
+     // Graceful shutdown with timeout
+     ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
+     defer cancel()
+     
+     if err := srv.Shutdown(ctx); err != nil {
+         log.Fatalf("shutdown: %v", err)
+     }
+     
+     log.Println("Server stopped")
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ ASP.NET Core is a full-featured web framework. Go's &#96;net/http&#96; is a building block.
+ 
+ **What Go does better:**
+ - Simple mental model
+ - No framework lock-in
+ - Explicit control over everything
+ - Very fast startup
+ - Small binaries
+ 
+ **What ASP.NET Core does better:**
+ - Batteries included
+ - Model binding and validation
+ - Authentication/authorization
+ - OpenAPI generation
+ - Richer middleware ecosystem
+ 
+ **The verdict:**
+ For simple services, &#96;net/http&#96; is delightfully straightforward. For complex APIs with lots of endpoints, validation, and documentation needs, you'll either write a lot of code or reach for a framework like Gin or Echo.
+ 
+ Neither is wrong. Go gives you the choice that ASP.NET Core makes for you.
+ 
+ ---
+ 
+ *Next up: JSON handling—struct tags, marshalling, and why it's more manual than Newtonsoft.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-json.md</summary>

**Chunk 1**
Lines added: 323, lines removed: 1

```diff
@@ -1,1 +1,323 @@
- 
+ +++
+ title = "JSON: Struct Tags and the Marshal Dance"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "json", "serialization", "csharp"]
+ +++
+ 
+ In C#, you add &#96;[JsonProperty("name")]&#96; or rely on naming conventions. The serializer figures out the rest. Newtonsoft.Json has been battle-tested for over a decade, and System.Text.Json is catching up fast.
+ 
+ Go's &#96;encoding/json&#96; is simpler. Not worse, necessarily, but definitely more manual. And it has quirks that'll catch you out.
+ 
+ ## The Basics
+ 
+ Go uses **struct tags** to control JSON field names:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID        int       &#96;json:"id"&#96;
+     FirstName string    &#96;json:"first_name"&#96;
+     Email     string    &#96;json:"email"&#96;
+     CreatedAt time.Time &#96;json:"created_at"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ Those backtick strings are struct tags. The &#96;json&#96; key tells the JSON encoder how to handle each field.
+ 
+ Marshal to JSON:
+ 
+ &#96;&#96;&#96;go
+ user := User{ID: 1, FirstName: "Alice", Email: "alice@example.com"}
+ data, err := json.Marshal(user)
+ // {"id":1,"first_name":"Alice","email":"alice@example.com","created_at":"0001-01-01T00:00:00Z"}
+ &#96;&#96;&#96;
+ 
+ Unmarshal from JSON:
+ 
+ &#96;&#96;&#96;go
+ var user User
+ err := json.Unmarshal([]byte(&#96;{"id":1,"first_name":"Alice"}&#96;), &amp;user)
+ &#96;&#96;&#96;
+ 
+ ## Struct Tag Options
+ 
+ The &#96;json&#96; tag supports several options:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID       int    &#96;json:"id"&#96;                    // rename to "id"
+     Name     string &#96;json:"name,omitempty"&#96;        // omit if empty
+     Password string &#96;json:"-"&#96;                     // never include
+     Email    string &#96;json:"email,omitempty"&#96;       // rename + omit if empty
+     internal string                                 // unexported, always ignored
+ }
+ &#96;&#96;&#96;
+ 
+ | Tag | Effect |
+ |-----|--------|
+ | &#96;json:"name"&#96; | Field appears as "name" in JSON |
+ | &#96;json:",omitempty"&#96; | Omit if zero value |
+ | &#96;json:"-"&#96; | Never marshal/unmarshal |
+ | &#96;json:"-,"&#96; | Field literally named "-" (rare) |
+ 
+ ## The omitempty Gotcha
+ 
+ &#96;omitempty&#96; omits **zero values**. This catches people:
+ 
+ &#96;&#96;&#96;go
+ type Response struct {
+     Count int  &#96;json:"count,omitempty"&#96;
+     Found bool &#96;json:"found,omitempty"&#96;
+ }
+ 
+ r := Response{Count: 0, Found: false}
+ data, _ := json.Marshal(r)
+ // {} — both fields omitted because they're zero values!
+ &#96;&#96;&#96;
+ 
+ If zero is a meaningful value, don't use &#96;omitempty&#96;. Or use a pointer:
+ 
+ &#96;&#96;&#96;go
+ type Response struct {
+     Count *int  &#96;json:"count,omitempty"&#96;  // nil omitted, 0 included
+     Found *bool &#96;json:"found,omitempty"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ ## Encoding and Decoding Streams
+ 
+ For HTTP handlers, use encoders/decoders instead of Marshal/Unmarshal:
+ 
+ &#96;&#96;&#96;go
+ // Reading request body
+ func handler(w http.ResponseWriter, r *http.Request) {
+     var input CreateUserRequest
+     if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil {
+         http.Error(w, "Invalid JSON", http.StatusBadRequest)
+         return
+     }
+     
+     // ... process ...
+     
+     // Writing response
+     w.Header().Set("Content-Type", "application/json")
+     json.NewEncoder(w).Encode(response)
+ }
+ &#96;&#96;&#96;
+ 
+ More efficient than reading the body into a byte slice first.
+ 
+ ## Custom Marshalling
+ 
+ Implement &#96;json.Marshaler&#96; and &#96;json.Unmarshaler&#96; for custom behaviour:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+ )
+ 
+ func (s Status) MarshalJSON() ([]byte, error) {
+     var str string
+     switch s {
+     case StatusPending:
+         str = "pending"
+     case StatusActive:
+         str = "active"
+     case StatusCompleted:
+         str = "completed"
+     default:
+         str = "unknown"
+     }
+     return json.Marshal(str)
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     switch str {
+     case "pending":
+         *s = StatusPending
+     case "active":
+         *s = StatusActive
+     case "completed":
+         *s = StatusCompleted
+     default:
+         return fmt.Errorf("unknown status: %s", str)
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;Status&#96; marshals as a string:
+ 
+ &#96;&#96;&#96;go
+ type Order struct {
+     ID     int    &#96;json:"id"&#96;
+     Status Status &#96;json:"status"&#96;
+ }
+ 
+ order := Order{ID: 1, Status: StatusActive}
+ data, _ := json.Marshal(order)
+ // {"id":1,"status":"active"}
+ &#96;&#96;&#96;
+ 
+ ## Handling Unknown Fields
+ 
+ By default, Go ignores unknown JSON fields:
+ 
+ &#96;&#96;&#96;go
+ var user User
+ json.Unmarshal([]byte(&#96;{"id":1,"unknown_field":"ignored"}&#96;), &amp;user)
+ // No error, unknown_field silently ignored
+ &#96;&#96;&#96;
+ 
+ To catch unknown fields, use a decoder:
+ 
+ &#96;&#96;&#96;go
+ dec := json.NewDecoder(r.Body)
+ dec.DisallowUnknownFields()
+ if err := dec.Decode(&amp;user); err != nil {
+     // Error if unknown fields present
+ }
+ &#96;&#96;&#96;
+ 
+ ## Working with Dynamic JSON
+ 
+ When you don't know the structure, use &#96;map[string]any&#96; or &#96;any&#96;:
+ 
+ &#96;&#96;&#96;go
+ var data map[string]any
+ json.Unmarshal(rawJSON, &amp;data)
+ 
+ // Access fields
+ name := data["name"].(string)  // type assertion needed
+ &#96;&#96;&#96;
+ 
+ Or use &#96;json.RawMessage&#96; to defer parsing:
+ 
+ &#96;&#96;&#96;go
+ type Event struct {
+     Type    string          &#96;json:"type"&#96;
+     Payload json.RawMessage &#96;json:"payload"&#96;  // parse later
+ }
+ 
+ var event Event
+ json.Unmarshal(data, &amp;event)
+ 
+ // Now parse payload based on type
+ switch event.Type {
+ case "user_created":
+     var payload UserCreatedPayload
+     json.Unmarshal(event.Payload, &amp;payload)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Comparing to C#
+ 
+ | Feature | System.Text.Json | Go encoding/json |
+ |---------|------------------|------------------|
+ | Attribute/Tag syntax | &#96;[JsonPropertyName]&#96; | Struct tags |
+ | Naming policy | JsonNamingPolicy | Manual per-field |
+ | Ignore null | &#96;[JsonIgnore]&#96; + conditions | &#96;omitempty&#96; (but for zero values) |
+ | Custom converters | JsonConverter | Marshaler/Unmarshaler interfaces |
+ | Unknown fields | Configurable | Ignored by default |
+ | Streaming | Yes | Yes (Encoder/Decoder) |
+ | Performance | Very good | Good |
+ | Source generators | Yes (AOT-friendly) | No |
+ 
+ C# has more configuration options. Go is more explicit but less flexible.
+ 
+ ## Common Patterns
+ 
+ ### Response Wrappers
+ 
+ &#96;&#96;&#96;go
+ type APIResponse[T any] struct {
+     Data  T      &#96;json:"data,omitempty"&#96;
+     Error string &#96;json:"error,omitempty"&#96;
+ }
+ 
+ func respondJSON[T any](w http.ResponseWriter, status int, data T) {
+     w.Header().Set("Content-Type", "application/json")
+     w.WriteHeader(status)
+     json.NewEncoder(w).Encode(APIResponse[T]{Data: data})
+ }
+ 
+ func respondError(w http.ResponseWriter, status int, message string) {
+     w.Header().Set("Content-Type", "application/json")
+     w.WriteHeader(status)
+     json.NewEncoder(w).Encode(APIResponse[any]{Error: message})
+ }
+ &#96;&#96;&#96;
+ 
+ ### Embedded Structs for Composition
+ 
+ &#96;&#96;&#96;go
+ type Timestamps struct {
+     CreatedAt time.Time &#96;json:"created_at"&#96;
+     UpdatedAt time.Time &#96;json:"updated_at"&#96;
+ }
+ 
+ type User struct {
+     ID   int    &#96;json:"id"&#96;
+     Name string &#96;json:"name"&#96;
+     Timestamps
+ }
+ 
+ // JSON: {"id":1,"name":"Alice","created_at":"...","updated_at":"..."}
+ &#96;&#96;&#96;
+ 
+ Embedded struct fields are flattened.
+ 
+ ### Different Input/Output Types
+ 
+ &#96;&#96;&#96;go
+ // For creating
+ type CreateUserRequest struct {
+     Name  string &#96;json:"name"&#96;
+     Email string &#96;json:"email"&#96;
+ }
+ 
+ // For responses (includes computed fields)
+ type UserResponse struct {
+     ID        int       &#96;json:"id"&#96;
+     Name      string    &#96;json:"name"&#96;
+     Email     string    &#96;json:"email"&#96;
+     CreatedAt time.Time &#96;json:"created_at"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ Don't try to use one struct for everything. Separate request and response types.
+ 
+ ## The Honest Take
+ 
+ Go's JSON handling is straightforward but manual. You write more code, but there's less magic.
+ 
+ **What Go does well:**
+ - Simple and predictable
+ - Struct tags are readable
+ - Custom marshalling is easy
+ - Streaming encoders/decoders
+ 
+ **What C# does better:**
+ - Naming policies (automatic camelCase)
+ - Source generators for performance
+ - More attribute options
+ - Better handling of null vs missing
+ - &#96;System.Text.Json&#96; is very fast
+ 
+ **The verdict:**
+ You'll miss automatic naming policies. You'll write more struct tags than you want to. But Go's JSON handling works fine for most cases.
+ 
+ For complex JSON needs (polymorphic types, extensive customization), consider third-party libraries like &#96;easyjson&#96; (fast, generated) or &#96;jsoniter&#96; (drop-in replacement, more features).
+ 
+ ---
+ 
+ *Next up: configuration—how to load config without IOptions&lt;T&gt; and why simplicity wins.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-config.md</summary>

**Chunk 1**
Lines added: 334, lines removed: 1

```diff
@@ -1,1 +1,334 @@
- 
+ +++
+ title = "Configuration Without IOptions&lt;T&gt;"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "configuration", "csharp"]
+ +++
+ 
+ In ASP.NET Core, configuration is a whole subsystem. &#96;IConfiguration&#96;, &#96;IOptions&lt;T&gt;&#96;, &#96;IOptionsSnapshot&lt;T&gt;&#96;, &#96;IOptionsMonitor&lt;T&gt;&#96;, multiple providers, hot reload, dependency injection integration... It's sophisticated. Maybe too sophisticated.
+ 
+ Go doesn't have a standard configuration library. The community uses environment variables, simple file parsing, or third-party libraries. It's less powerful and often exactly what you need.
+ 
+ ## The Simplest Approach: Environment Variables
+ 
+ The Go standard library makes environment variables easy:
+ 
+ &#96;&#96;&#96;go
+ port := os.Getenv("PORT")
+ if port == "" {
+     port = "8080"
+ }
+ 
+ dbURL := os.Getenv("DATABASE_URL")
+ if dbURL == "" {
+     log.Fatal("DATABASE_URL required")
+ }
+ &#96;&#96;&#96;
+ 
+ That's it. No configuration provider chain. No dependency injection. Just read the environment.
+ 
+ For typed values:
+ 
+ &#96;&#96;&#96;go
+ timeout, err := strconv.Atoi(os.Getenv("TIMEOUT_SECONDS"))
+ if err != nil {
+     timeout = 30  // default
+ }
+ 
+ debug := os.Getenv("DEBUG") == "true"
+ &#96;&#96;&#96;
+ 
+ ## Struct-Based Configuration
+ 
+ Most projects define a config struct:
+ 
+ &#96;&#96;&#96;go
+ type Config struct {
+     Port        string
+     DatabaseURL string
+     Debug       bool
+     Timeout     time.Duration
+ }
+ 
+ func LoadConfig() (*Config, error) {
+     port := os.Getenv("PORT")
+     if port == "" {
+         port = "8080"
+     }
+     
+     dbURL := os.Getenv("DATABASE_URL")
+     if dbURL == "" {
+         return nil, errors.New("DATABASE_URL required")
+     }
+     
+     debug := os.Getenv("DEBUG") == "true"
+     
+     timeout := 30 * time.Second
+     if t := os.Getenv("TIMEOUT"); t != "" {
+         d, err := time.ParseDuration(t)
+         if err != nil {
+             return nil, fmt.Errorf("invalid TIMEOUT: %w", err)
+         }
+         timeout = d
+     }
+     
+     return &amp;Config{
+         Port:        port,
+         DatabaseURL: dbURL,
+         Debug:       debug,
+         Timeout:     timeout,
+     }, nil
+ }
+ &#96;&#96;&#96;
+ 
+ Then in main:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     cfg, err := LoadConfig()
+     if err != nil {
+         log.Fatalf("config error: %v", err)
+     }
+     
+     server := NewServer(cfg)
+     server.Run()
+ }
+ &#96;&#96;&#96;
+ 
+ No interfaces. No DI. Pass the config struct to things that need it.
+ 
+ ## envconfig: Less Boilerplate
+ 
+ The &#96;envconfig&#96; package reduces repetition:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/kelseyhightower/envconfig"
+ 
+ type Config struct {
+     Port        string        &#96;envconfig:"PORT" default:"8080"&#96;
+     DatabaseURL string        &#96;envconfig:"DATABASE_URL" required:"true"&#96;
+     Debug       bool          &#96;envconfig:"DEBUG" default:"false"&#96;
+     Timeout     time.Duration &#96;envconfig:"TIMEOUT" default:"30s"&#96;
+ }
+ 
+ func LoadConfig() (*Config, error) {
+     var cfg Config
+     if err := envconfig.Process("", &amp;cfg); err != nil {
+         return nil, err
+     }
+     return &amp;cfg, nil
+ }
+ &#96;&#96;&#96;
+ 
+ Struct tags define environment variable names, defaults, and requirements. Much cleaner.
+ 
+ ## Viper: The Kitchen Sink
+ 
+ If you need file-based config, multiple formats, or hot reload, Viper is the standard choice:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/spf13/viper"
+ 
+ func LoadConfig() (*Config, error) {
+     viper.SetConfigName("config")
+     viper.SetConfigType("yaml")
+     viper.AddConfigPath(".")
+     viper.AddConfigPath("/etc/myapp/")
+     
+     // Environment variables override file
+     viper.AutomaticEnv()
+     viper.SetEnvPrefix("MYAPP")
+     
+     // Defaults
+     viper.SetDefault("port", "8080")
+     viper.SetDefault("timeout", "30s")
+     
+     if err := viper.ReadInConfig(); err != nil {
+         if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
+             return nil, err
+         }
+         // Config file not found, continue with env vars and defaults
+     }
+     
+     var cfg Config
+     if err := viper.Unmarshal(&amp;cfg); err != nil {
+         return nil, err
+     }
+     
+     return &amp;cfg, nil
+ }
+ &#96;&#96;&#96;
+ 
+ config.yaml:
+ 
+ &#96;&#96;&#96;yaml
+ port: "8080"
+ database_url: "postgres://localhost/myapp"
+ debug: false
+ timeout: "30s"
+ &#96;&#96;&#96;
+ 
+ Viper is powerful but adds complexity. Use it when you need it.
+ 
+ ## Comparing to .NET
+ 
+ | Feature | .NET IConfiguration | Go |
+ |---------|---------------------|-----|
+ | Multiple sources | Built-in | Viper or manual |
+ | Environment variables | Provider | &#96;os.Getenv&#96; |
+ | JSON/YAML files | Providers | Viper or manual |
+ | Strong typing | &#96;IOptions&lt;T&gt;&#96; | Struct + unmarshal |
+ | Validation | Data annotations | Manual or validator |
+ | Hot reload | &#96;IOptionsMonitor&lt;T&gt;&#96; | Viper.WatchConfig |
+ | DI integration | Built-in | Manual |
+ | Secrets | User secrets, Key Vault | Env vars, external |
+ 
+ .NET's configuration system is more integrated. Go's is simpler but less cohesive.
+ 
+ ## Configuration Patterns
+ 
+ ### Environment-Specific Loading
+ 
+ &#96;&#96;&#96;go
+ func LoadConfig() (*Config, error) {
+     env := os.Getenv("APP_ENV")
+     if env == "" {
+         env = "development"
+     }
+     
+     // Base config
+     cfg := Config{
+         Port:    "8080",
+         Debug:   false,
+         Timeout: 30 * time.Second,
+     }
+     
+     // Environment overrides
+     switch env {
+     case "production":
+         cfg.Debug = false
+     case "development":
+         cfg.Debug = true
+     }
+     
+     // Env vars override everything
+     if port := os.Getenv("PORT"); port != "" {
+         cfg.Port = port
+     }
+     // ... more overrides
+     
+     return &amp;cfg, nil
+ }
+ &#96;&#96;&#96;
+ 
+ ### Validation
+ 
+ &#96;&#96;&#96;go
+ func (c *Config) Validate() error {
+     if c.DatabaseURL == "" {
+         return errors.New("database_url is required")
+     }
+     if c.Port == "" {
+         return errors.New("port is required")
+     }
+     if c.Timeout &lt;= 0 {
+         return errors.New("timeout must be positive")
+     }
+     return nil
+ }
+ 
+ func LoadConfig() (*Config, error) {
+     cfg := &amp;Config{...}
+     // ... load values ...
+     
+     if err := cfg.Validate(); err != nil {
+         return nil, fmt.Errorf("config validation: %w", err)
+     }
+     
+     return cfg, nil
+ }
+ &#96;&#96;&#96;
+ 
+ ### Immutable Config
+ 
+ Make config read-only after loading:
+ 
+ &#96;&#96;&#96;go
+ type Config struct {
+     port        string
+     databaseURL string
+ }
+ 
+ func (c *Config) Port() string        { return c.port }
+ func (c *Config) DatabaseURL() string { return c.databaseURL }
+ 
+ func LoadConfig() *Config {
+     return &amp;Config{
+         port:        os.Getenv("PORT"),
+         databaseURL: os.Getenv("DATABASE_URL"),
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Unexported fields + getter methods = immutable from outside the package.
+ 
+ ## What About IOptions&lt;T&gt;?
+ 
+ .NET's &#96;IOptions&lt;T&gt;&#96; pattern has benefits:
+ - Strongly typed configuration sections
+ - Validation on startup
+ - Hot reload with &#96;IOptionsMonitor&lt;T&gt;&#96;
+ - Clean injection into services
+ 
+ Go's equivalent is just... passing a struct:
+ 
+ &#96;&#96;&#96;go
+ // .NET
+ public class MyService
+ {
+     public MyService(IOptions&lt;DatabaseConfig&gt; options)
+     {
+         _connectionString = options.Value.ConnectionString;
+     }
+ }
+ 
+ // Go
+ type MyService struct {
+     connString string
+ }
+ 
+ func NewMyService(cfg *Config) *MyService {
+     return &amp;MyService{connString: cfg.DatabaseURL}
+ }
+ &#96;&#96;&#96;
+ 
+ Less ceremony in Go. But also less framework support if you want validation, hot reload, or named options.
+ 
+ ## The Honest Take
+ 
+ Go's configuration story is simpler. Whether that's better depends on your needs.
+ 
+ **What Go does well:**
+ - Environment variables are trivial
+ - No framework to learn
+ - Full control over loading logic
+ - Fast startup (no config system initialization)
+ 
+ **What .NET does better:**
+ - Integrated with DI
+ - Multiple providers out of the box
+ - Better hot reload story
+ - Options validation built-in
+ - Secrets management
+ 
+ **The verdict:**
+ For microservices that read environment variables and a config file, Go's approach is fine. &#96;envconfig&#96; handles 90% of cases.
+ 
+ For complex applications with layered configuration, validation requirements, and hot reload, you'll either use Viper or miss .NET's configuration system.
+ 
+ Start simple. Environment variables and &#96;envconfig&#96; get you far. Reach for Viper when you actually need its features.
+ 
+ ---
+ 
+ *Next up: logging with slog—Go's new structured logging standard and how it compares to ILogger.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-logging.md</summary>

**Chunk 1**
Lines added: 290, lines removed: 1

```diff
@@ -1,1 +1,290 @@
- 
+ +++
+ title = "Logging: slog and the Structured Logging Story"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "logging", "slog", "csharp"]
+ +++
+ 
+ For years, Go's logging story was "use the &#96;log&#96; package or pick a third-party library." The standard &#96;log&#96; package is basic—no levels, no structure, no context. Everyone used zerolog, zap, or logrus.
+ 
+ Then Go 1.21 shipped &#96;log/slog&#96;. Finally, structured logging in the standard library. And it's actually good.
+ 
+ ## The Old Way: log Package
+ 
+ Go's original &#96;log&#96; package:
+ 
+ &#96;&#96;&#96;go
+ import "log"
+ 
+ log.Println("server starting")
+ log.Printf("listening on port %d", 8080)
+ log.Fatal("failed to connect")  // logs and calls os.Exit(1)
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ 2025/01/04 10:30:00 server starting
+ 2025/01/04 10:30:00 listening on port 8080
+ &#96;&#96;&#96;
+ 
+ No levels. No structure. Just text. Fine for simple programs, inadequate for production.
+ 
+ ## The New Way: slog
+ 
+ Go 1.21's &#96;log/slog&#96; package:
+ 
+ &#96;&#96;&#96;go
+ import "log/slog"
+ 
+ slog.Info("server starting")
+ slog.Info("listening", "port", 8080)
+ slog.Error("failed to connect", "error", err, "host", hostname)
+ &#96;&#96;&#96;
+ 
+ Default text output:
+ 
+ &#96;&#96;&#96;
+ 2025/01/04 10:30:00 INFO server starting
+ 2025/01/04 10:30:00 INFO listening port=8080
+ 2025/01/04 10:30:00 ERROR failed to connect error="connection refused" host="db.example.com"
+ &#96;&#96;&#96;
+ 
+ Or JSON:
+ 
+ &#96;&#96;&#96;go
+ logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
+ slog.SetDefault(logger)
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;json
+ {"time":"2025-01-04T10:30:00Z","level":"INFO","msg":"listening","port":8080}
+ &#96;&#96;&#96;
+ 
+ ## Log Levels
+ 
+ slog has four levels:
+ 
+ &#96;&#96;&#96;go
+ slog.Debug("detailed debugging info")
+ slog.Info("normal operation")
+ slog.Warn("something unexpected")
+ slog.Error("something failed")
+ &#96;&#96;&#96;
+ 
+ Set the minimum level:
+ 
+ &#96;&#96;&#96;go
+ opts := &amp;slog.HandlerOptions{
+     Level: slog.LevelDebug,  // show Debug and above
+ }
+ logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
+ &#96;&#96;&#96;
+ 
+ ## Structured Attributes
+ 
+ Add key-value pairs to log entries:
+ 
+ &#96;&#96;&#96;go
+ // Alternating key-value pairs
+ slog.Info("user created", "user_id", userID, "email", email)
+ 
+ // Or use slog.Attr for type safety
+ slog.Info("user created",
+     slog.Int("user_id", userID),
+     slog.String("email", email),
+     slog.Time("created_at", time.Now()),
+ )
+ &#96;&#96;&#96;
+ 
+ ## Logger with Context
+ 
+ Add attributes that appear in every log entry:
+ 
+ &#96;&#96;&#96;go
+ logger := slog.Default().With(
+     "service", "user-api",
+     "version", "1.2.3",
+ )
+ 
+ logger.Info("request received")
+ // {"time":"...","level":"INFO","msg":"request received","service":"user-api","version":"1.2.3"}
+ &#96;&#96;&#96;
+ 
+ Or create child loggers:
+ 
+ &#96;&#96;&#96;go
+ func handleRequest(r *http.Request) {
+     requestID := r.Header.Get("X-Request-ID")
+     log := slog.Default().With("request_id", requestID)
+     
+     log.Info("processing request")
+     // ... later
+     log.Info("request complete")  // both have request_id
+ }
+ &#96;&#96;&#96;
+ 
+ ## Comparing to ILogger
+ 
+ C#'s &#96;ILogger&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ _logger.LogInformation("User created: {UserId} {Email}", userId, email);
+ &#96;&#96;&#96;
+ 
+ Go's slog:
+ 
+ &#96;&#96;&#96;go
+ slog.Info("user created", "user_id", userID, "email", email)
+ &#96;&#96;&#96;
+ 
+ Similar structured logging. Different syntax.
+ 
+ | Feature | ILogger | slog |
+ |---------|---------|------|
+ | Structured logging | Yes | Yes |
+ | Log levels | 6 (Trace-Critical) | 4 (Debug-Error) |
+ | Scopes | &#96;BeginScope()&#96; | &#96;With()&#96; |
+ | DI integration | Built-in | Manual |
+ | Providers | Many built-in | Handlers (fewer) |
+ | Message templates | &#96;{Named}&#96; placeholders | Key-value pairs |
+ | Log categories | Type-based | Manual grouping |
+ 
+ ## Using slog with HTTP Context
+ 
+ Pass loggers through context:
+ 
+ &#96;&#96;&#96;go
+ type ctxKey struct{}
+ 
+ func WithLogger(ctx context.Context, logger *slog.Logger) context.Context {
+     return context.WithValue(ctx, ctxKey{}, logger)
+ }
+ 
+ func FromContext(ctx context.Context) *slog.Logger {
+     if logger, ok := ctx.Value(ctxKey{}).(*slog.Logger); ok {
+         return logger
+     }
+     return slog.Default()
+ }
+ &#96;&#96;&#96;
+ 
+ Middleware to add request context:
+ 
+ &#96;&#96;&#96;go
+ func loggingMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         logger := slog.Default().With(
+             "request_id", r.Header.Get("X-Request-ID"),
+             "method", r.Method,
+             "path", r.URL.Path,
+         )
+         
+         ctx := WithLogger(r.Context(), logger)
+         next.ServeHTTP(w, r.WithContext(ctx))
+     })
+ }
+ 
+ // In handlers
+ func handler(w http.ResponseWriter, r *http.Request) {
+     log := FromContext(r.Context())
+     log.Info("processing")  // includes request context
+ }
+ &#96;&#96;&#96;
+ 
+ ## Custom Handlers
+ 
+ slog uses handlers for output. Write your own:
+ 
+ &#96;&#96;&#96;go
+ type PrettyHandler struct {
+     slog.Handler
+     w io.Writer
+ }
+ 
+ func (h *PrettyHandler) Handle(ctx context.Context, r slog.Record) error {
+     // Custom formatting
+     fmt.Fprintf(h.w, "[%s] %s: %s\n",
+         r.Time.Format("15:04:05"),
+         r.Level,
+         r.Message,
+     )
+     r.Attrs(func(a slog.Attr) bool {
+         fmt.Fprintf(h.w, "  %s=%v\n", a.Key, a.Value)
+         return true
+     })
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Or wrap existing handlers for filtering, sampling, etc.
+ 
+ ## Third-Party Integration
+ 
+ slog plays well with existing libraries:
+ 
+ **Output to zerolog:**
+ &#96;&#96;&#96;go
+ // zerolog adapter available
+ &#96;&#96;&#96;
+ 
+ **Output to zap:**
+ &#96;&#96;&#96;go
+ // zapslog adapter available
+ &#96;&#96;&#96;
+ 
+ You can use slog's API with your preferred backend.
+ 
+ ## Performance Considerations
+ 
+ slog is designed for production:
+ 
+ &#96;&#96;&#96;go
+ // Avoid allocation if level disabled
+ if slog.Default().Enabled(ctx, slog.LevelDebug) {
+     slog.Debug("expensive operation", "data", expensiveComputation())
+ }
+ &#96;&#96;&#96;
+ 
+ Or use &#96;LogAttrs&#96; for zero-allocation logging:
+ 
+ &#96;&#96;&#96;go
+ slog.Default().LogAttrs(ctx, slog.LevelInfo, "event",
+     slog.String("key", value),
+     slog.Int("count", n),
+ )
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ slog is a welcome addition. Not as mature as the third-party options, but good enough for most uses.
+ 
+ **What slog does well:**
+ - Standard library (no dependencies)
+ - Good API design
+ - Structured by default
+ - Handler abstraction for extensibility
+ 
+ **What ILogger does better:**
+ - More log levels
+ - Richer ecosystem
+ - DI integration
+ - Better provider options (Application Insights, Seq, etc.)
+ - Message templates with semantic meaning
+ 
+ **What third-party Go loggers do better:**
+ - zerolog: extremely fast, zero allocation
+ - zap: battle-tested, rich features
+ - Both: more production-proven
+ 
+ **The verdict:**
+ For new projects, slog is a solid choice. It's in the standard library, it's structured, it works.
+ 
+ For high-performance logging or specific output requirements, zerolog or zap might still be better.
+ 
+ If you're coming from ILogger, you'll find slog familiar but simpler. Fewer features, but the core functionality is there.
+ 
+ ---
+ 
+ *Next up: database access with database/sql—raw SQL, connection pooling, and missing your ORM.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-database.md</summary>

**Chunk 1**
Lines added: 293, lines removed: 1

```diff
@@ -1,1 +1,293 @@
- 
+ +++
+ title = "Database Access: database/sql vs Entity Framework"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "database", "sql", "csharp"]
+ +++
+ 
+ Entity Framework is an ORM. It maps objects to tables, generates SQL, tracks changes, handles migrations. You can build entire applications barely writing SQL.
+ 
+ Go's &#96;database/sql&#96; is a thin abstraction over database drivers. You write SQL. You scan results into structs. There's no change tracking, no LINQ, no automatic migrations.
+ 
+ This is going to feel like stepping back twenty years. But there's value in the simplicity.
+ 
+ ## The Basics
+ 
+ Connect to a database:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "database/sql"
+     _ "github.com/lib/pq"  // PostgreSQL driver
+ )
+ 
+ db, err := sql.Open("postgres", "postgres://user:pass@localhost/mydb?sslmode=disable")
+ if err != nil {
+     log.Fatal(err)
+ }
+ defer db.Close()
+ 
+ // Verify connection
+ if err := db.Ping(); err != nil {
+     log.Fatal(err)
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;sql.Open&#96; doesn't actually connect—it just validates the connection string. &#96;Ping&#96; makes the actual connection.
+ 
+ ## Querying
+ 
+ Single row:
+ 
+ &#96;&#96;&#96;go
+ var user User
+ err := db.QueryRowContext(ctx, 
+     "SELECT id, name, email FROM users WHERE id = $1", 
+     userID,
+ ).Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email)
+ 
+ if err == sql.ErrNoRows {
+     return nil, ErrNotFound
+ }
+ if err != nil {
+     return nil, fmt.Errorf("query user: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ Multiple rows:
+ 
+ &#96;&#96;&#96;go
+ rows, err := db.QueryContext(ctx, "SELECT id, name, email FROM users")
+ if err != nil {
+     return nil, err
+ }
+ defer rows.Close()
+ 
+ var users []User
+ for rows.Next() {
+     var u User
+     if err := rows.Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email); err != nil {
+         return nil, err
+     }
+     users = append(users, u)
+ }
+ 
+ if err := rows.Err(); err != nil {
+     return nil, err
+ }
+ &#96;&#96;&#96;
+ 
+ Note the explicit &#96;rows.Close()&#96; and &#96;rows.Err()&#96; checks. Nothing is automatic.
+ 
+ ## Executing Statements
+ 
+ Insert, update, delete:
+ 
+ &#96;&#96;&#96;go
+ result, err := db.ExecContext(ctx,
+     "INSERT INTO users (name, email) VALUES ($1, $2)",
+     name, email,
+ )
+ if err != nil {
+     return err
+ }
+ 
+ id, _ := result.LastInsertId()      // not all drivers support this
+ affected, _ := result.RowsAffected()
+ &#96;&#96;&#96;
+ 
+ ## Scanning Structs
+ 
+ You scan columns into variables one by one. This is tedious:
+ 
+ &#96;&#96;&#96;go
+ // Manual scanning
+ rows.Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email, &amp;u.CreatedAt, &amp;u.UpdatedAt)
+ &#96;&#96;&#96;
+ 
+ If your SELECT has 15 columns, you write 15 arguments.
+ 
+ Libraries like &#96;sqlx&#96; help:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/jmoiron/sqlx"
+ 
+ type User struct {
+     ID        int       &#96;db:"id"&#96;
+     Name      string    &#96;db:"name"&#96;
+     Email     string    &#96;db:"email"&#96;
+     CreatedAt time.Time &#96;db:"created_at"&#96;
+ }
+ 
+ // sqlx scans by struct tag
+ var users []User
+ err := db.SelectContext(ctx, &amp;users, "SELECT * FROM users")
+ 
+ var user User
+ err := db.GetContext(ctx, &amp;user, "SELECT * FROM users WHERE id = $1", id)
+ &#96;&#96;&#96;
+ 
+ &#96;sqlx&#96; is &#96;database/sql&#96; with convenience methods. It's not an ORM—still raw SQL—but much less boilerplate.
+ 
+ ## Transactions
+ 
+ &#96;&#96;&#96;go
+ tx, err := db.BeginTx(ctx, nil)
+ if err != nil {
+     return err
+ }
+ defer tx.Rollback()  // no-op if committed
+ 
+ _, err = tx.ExecContext(ctx, "UPDATE accounts SET balance = balance - $1 WHERE id = $2", amount, fromID)
+ if err != nil {
+     return err
+ }
+ 
+ _, err = tx.ExecContext(ctx, "UPDATE accounts SET balance = balance + $1 WHERE id = $2", amount, toID)
+ if err != nil {
+     return err
+ }
+ 
+ return tx.Commit()
+ &#96;&#96;&#96;
+ 
+ The &#96;defer tx.Rollback()&#96; is safe—it does nothing if already committed.
+ 
+ ## Connection Pooling
+ 
+ &#96;sql.DB&#96; is a connection pool. Configure it:
+ 
+ &#96;&#96;&#96;go
+ db.SetMaxOpenConns(25)              // max concurrent connections
+ db.SetMaxIdleConns(5)               // max idle connections
+ db.SetConnMaxLifetime(5 * time.Minute)  // max connection age
+ db.SetConnMaxIdleTime(1 * time.Minute)  // max idle time
+ &#96;&#96;&#96;
+ 
+ This is built in. EF Core has connection pooling too, but you rarely configure it.
+ 
+ ## Comparing to Entity Framework
+ 
+ | Feature | Entity Framework | database/sql |
+ |---------|------------------|--------------|
+ | Query language | LINQ | Raw SQL |
+ | Mapping | Automatic (conventions/attributes) | Manual or sqlx |
+ | Change tracking | Yes | No |
+ | Migrations | EF Migrations | External tools |
+ | Connection pooling | Built-in | Built-in |
+ | Transactions | DbContext/SaveChanges | Explicit Begin/Commit |
+ | Lazy loading | Supported | No |
+ | Relationships | Navigation properties | Manual joins |
+ | Learning curve | Higher | Lower (if you know SQL) |
+ 
+ ## The Repository Pattern
+ 
+ Without an ORM, you write repositories manually:
+ 
+ &#96;&#96;&#96;go
+ type UserRepository struct {
+     db *sql.DB
+ }
+ 
+ func (r *UserRepository) FindByID(ctx context.Context, id int) (*User, error) {
+     var u User
+     err := r.db.QueryRowContext(ctx,
+         "SELECT id, name, email, created_at FROM users WHERE id = $1",
+         id,
+     ).Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email, &amp;u.CreatedAt)
+     
+     if err == sql.ErrNoRows {
+         return nil, ErrNotFound
+     }
+     return &amp;u, err
+ }
+ 
+ func (r *UserRepository) Create(ctx context.Context, u *User) error {
+     return r.db.QueryRowContext(ctx,
+         "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, created_at",
+         u.Name, u.Email,
+     ).Scan(&amp;u.ID, &amp;u.CreatedAt)
+ }
+ 
+ func (r *UserRepository) Update(ctx context.Context, u *User) error {
+     _, err := r.db.ExecContext(ctx,
+         "UPDATE users SET name = $1, email = $2 WHERE id = $3",
+         u.Name, u.Email, u.ID,
+     )
+     return err
+ }
+ &#96;&#96;&#96;
+ 
+ More code than EF, but you control every query.
+ 
+ ## Handling NULLs
+ 
+ SQL NULLs don't map to Go zero values cleanly:
+ 
+ &#96;&#96;&#96;go
+ // This fails if middle_name is NULL
+ var middleName string
+ rows.Scan(&amp;middleName)  // error: converting NULL to string
+ 
+ // Use sql.NullString
+ var middleName sql.NullString
+ rows.Scan(&amp;middleName)
+ if middleName.Valid {
+     fmt.Println(middleName.String)
+ }
+ 
+ // Or use pointers
+ var middleName *string
+ rows.Scan(&amp;middleName)
+ if middleName != nil {
+     fmt.Println(*middleName)
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;sql.NullString&#96;, &#96;sql.NullInt64&#96;, etc. for nullable columns. Or use pointers.
+ 
+ ## Migrations
+ 
+ No built-in migrations. Popular tools:
+ 
+ - **golang-migrate**: SQL files, version tracking
+ - **goose**: SQL or Go migrations
+ - **atlas**: Schema-as-code approach
+ 
+ &#96;&#96;&#96;bash
+ # golang-migrate example
+ migrate create -ext sql -dir migrations create_users_table
+ migrate -path migrations -database "postgres://..." up
+ &#96;&#96;&#96;
+ 
+ You write the SQL yourself. No automatic schema generation from structs.
+ 
+ ## The Honest Take
+ 
+ Going from EF to &#96;database/sql&#96; is a shock. You're back to writing SQL, managing scans, handling nulls manually.
+ 
+ **What Go does well:**
+ - Full control over queries
+ - No ORM magic to debug
+ - Excellent connection pooling
+ - Predictable performance
+ - sqlx makes it tolerable
+ 
+ **What EF does better:**
+ - LINQ for type-safe queries
+ - Automatic change tracking
+ - Migration generation
+ - Navigation properties
+ - Much less boilerplate
+ 
+ **The verdict:**
+ If you like writing SQL and want control, &#96;database/sql&#96; is fine. Add &#96;sqlx&#96; for convenience.
+ 
+ If you're building CRUD apps and value productivity over control, you'll miss EF. A lot.
+ 
+ The Go community is more accepting of ORMs than it used to be. GORM exists, and we'll cover it next. But many Go developers prefer the explicit approach.
+ 
+ ---
+ 
+ *Next up: GORM—when you do want an ORM, and how it compares to Entity Framework.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-gorm.md</summary>

**Chunk 1**
Lines added: 365, lines removed: 1

```diff
@@ -1,1 +1,365 @@
- 
+ +++
+ title = "GORM and Friends: When You Do Want an ORM"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "database", "orm", "gorm", "csharp"]
+ +++
+ 
+ Despite Go's "just write SQL" culture, ORMs exist and are popular. GORM is the most widely used. If you're coming from Entity Framework and miss the productivity, GORM might ease the transition.
+ 
+ Fair warning: GORM is controversial in the Go community. Some love it, many avoid it. Let's look at what it offers and the trade-offs.
+ 
+ ## Basic GORM Usage
+ 
+ Define a model:
+ 
+ &#96;&#96;&#96;go
+ import "gorm.io/gorm"
+ 
+ type User struct {
+     ID        uint           &#96;gorm:"primaryKey"&#96;
+     Name      string         &#96;gorm:"size:255;not null"&#96;
+     Email     string         &#96;gorm:"uniqueIndex;not null"&#96;
+     Age       int
+     CreatedAt time.Time
+     UpdatedAt time.Time
+     DeletedAt gorm.DeletedAt &#96;gorm:"index"&#96;  // soft delete
+ }
+ &#96;&#96;&#96;
+ 
+ Connect and auto-migrate:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "gorm.io/gorm"
+     "gorm.io/driver/postgres"
+ )
+ 
+ dsn := "host=localhost user=postgres password=secret dbname=myapp"
+ db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
+ if err != nil {
+     log.Fatal(err)
+ }
+ 
+ // Create/update tables from structs
+ db.AutoMigrate(&amp;User{})
+ &#96;&#96;&#96;
+ 
+ ## CRUD Operations
+ 
+ **Create:**
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice", Email: "alice@example.com", Age: 30}
+ result := db.Create(&amp;user)
+ // user.ID is populated after insert
+ 
+ if result.Error != nil {
+     return result.Error
+ }
+ fmt.Printf("Inserted %d rows\n", result.RowsAffected)
+ &#96;&#96;&#96;
+ 
+ **Read:**
+ 
+ &#96;&#96;&#96;go
+ // By primary key
+ var user User
+ db.First(&amp;user, 1)  // find by ID
+ 
+ // By condition
+ db.First(&amp;user, "email = ?", "alice@example.com")
+ 
+ // Multiple
+ var users []User
+ db.Where("age &gt; ?", 25).Find(&amp;users)
+ 
+ // All
+ db.Find(&amp;users)
+ &#96;&#96;&#96;
+ 
+ **Update:**
+ 
+ &#96;&#96;&#96;go
+ // Update single field
+ db.Model(&amp;user).Update("Name", "Bob")
+ 
+ // Update multiple fields
+ db.Model(&amp;user).Updates(User{Name: "Bob", Age: 31})
+ 
+ // Update with map (includes zero values)
+ db.Model(&amp;user).Updates(map[string]interface{}{"Name": "Bob", "Age": 0})
+ &#96;&#96;&#96;
+ 
+ **Delete:**
+ 
+ &#96;&#96;&#96;go
+ db.Delete(&amp;user)  // soft delete if DeletedAt field exists
+ db.Unscoped().Delete(&amp;user)  // hard delete
+ &#96;&#96;&#96;
+ 
+ ## Comparing to Entity Framework
+ 
+ &#96;&#96;&#96;csharp
+ // EF Core
+ var user = await _context.Users.FindAsync(1);
+ user.Name = "Bob";
+ await _context.SaveChangesAsync();
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // GORM
+ var user User
+ db.First(&amp;user, 1)
+ db.Model(&amp;user).Update("Name", "Bob")
+ &#96;&#96;&#96;
+ 
+ Similar concepts, different APIs. GORM doesn't have change tracking like EF—you explicitly call updates.
+ 
+ ## Relationships
+ 
+ **One-to-Many:**
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID     uint
+     Name   string
+     Orders []Order  // has many
+ }
+ 
+ type Order struct {
+     ID     uint
+     UserID uint     // foreign key
+     Total  float64
+     User   User     // belongs to
+ }
+ 
+ // Load with association
+ var user User
+ db.Preload("Orders").First(&amp;user, 1)
+ 
+ for _, order := range user.Orders {
+     fmt.Println(order.Total)
+ }
+ &#96;&#96;&#96;
+ 
+ **Many-to-Many:**
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID    uint
+     Name  string
+     Roles []Role &#96;gorm:"many2many:user_roles;"&#96;
+ }
+ 
+ type Role struct {
+     ID   uint
+     Name string
+ }
+ 
+ // Load
+ db.Preload("Roles").First(&amp;user, 1)
+ 
+ // Associate
+ db.Model(&amp;user).Association("Roles").Append(&amp;Role{Name: "admin"})
+ &#96;&#96;&#96;
+ 
+ ## Preloading vs Eager Loading
+ 
+ Like EF's &#96;Include&#96;, GORM has &#96;Preload&#96;:
+ 
+ &#96;&#96;&#96;go
+ // Single association
+ db.Preload("Orders").Find(&amp;users)
+ 
+ // Nested
+ db.Preload("Orders.Items").Find(&amp;users)
+ 
+ // Conditional preload
+ db.Preload("Orders", "total &gt; ?", 100).Find(&amp;users)
+ 
+ // All associations
+ db.Preload(clause.Associations).Find(&amp;users)
+ &#96;&#96;&#96;
+ 
+ No lazy loading by default. Explicit preloading only.
+ 
+ ## Raw SQL
+ 
+ When the ORM isn't enough:
+ 
+ &#96;&#96;&#96;go
+ // Raw query
+ var users []User
+ db.Raw("SELECT * FROM users WHERE age &gt; ?", 25).Scan(&amp;users)
+ 
+ // Raw exec
+ db.Exec("UPDATE users SET age = age + 1 WHERE birthday = ?", today)
+ 
+ // Mix GORM and raw
+ db.Where("age &gt; ?", 25).Order("name").Find(&amp;users)
+ &#96;&#96;&#96;
+ 
+ ## Transactions
+ 
+ &#96;&#96;&#96;go
+ err := db.Transaction(func(tx *gorm.DB) error {
+     if err := tx.Create(&amp;user).Error; err != nil {
+         return err  // rollback
+     }
+     
+     if err := tx.Create(&amp;order).Error; err != nil {
+         return err  // rollback
+     }
+     
+     return nil  // commit
+ })
+ &#96;&#96;&#96;
+ 
+ Or manual:
+ 
+ &#96;&#96;&#96;go
+ tx := db.Begin()
+ defer func() {
+     if r := recover(); r != nil {
+         tx.Rollback()
+     }
+ }()
+ 
+ // ... operations on tx ...
+ 
+ tx.Commit()
+ &#96;&#96;&#96;
+ 
+ ## Hooks (Lifecycle Events)
+ 
+ &#96;&#96;&#96;go
+ func (u *User) BeforeCreate(tx *gorm.DB) error {
+     u.CreatedAt = time.Now()
+     return nil
+ }
+ 
+ func (u *User) AfterCreate(tx *gorm.DB) error {
+     // Send welcome email
+     return sendWelcomeEmail(u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ Like EF's &#96;SaveChanges&#96; interceptors or domain events.
+ 
+ ## The Controversies
+ 
+ GORM has critics. Common complaints:
+ 
+ **1. Magic and Reflection**
+ 
+ GORM uses reflection heavily. Errors can be cryptic, and behaviour isn't always obvious.
+ 
+ &#96;&#96;&#96;go
+ db.Where("name = ?", name).First(&amp;user)
+ // What SQL does this generate? Have to check docs or logs.
+ &#96;&#96;&#96;
+ 
+ **2. Struct Tag Complexity**
+ 
+ &#96;&#96;&#96;go
+ type Product struct {
+     ID        uint    &#96;gorm:"primaryKey;autoIncrement"&#96;
+     Code      string  &#96;gorm:"type:varchar(100);uniqueIndex"&#96;
+     Price     float64 &#96;gorm:"precision:2"&#96;
+     CreatedAt time.Time &#96;gorm:"autoCreateTime"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ The tags can get complex. Errors are runtime, not compile time.
+ 
+ **3. Query Builder Limitations**
+ 
+ Complex queries sometimes fight the API:
+ 
+ &#96;&#96;&#96;go
+ // This gets awkward
+ db.Where("status = ? AND (priority = ? OR deadline &lt; ?)", 
+     "active", "high", time.Now())
+ &#96;&#96;&#96;
+ 
+ **4. Performance**
+ 
+ Reflection has overhead. For high-throughput scenarios, raw SQL is faster.
+ 
+ ## Alternatives to GORM
+ 
+ **sqlx**: Not an ORM, just convenience over &#96;database/sql&#96;:
+ 
+ &#96;&#96;&#96;go
+ var users []User
+ db.SelectContext(ctx, &amp;users, "SELECT * FROM users WHERE age &gt; $1", 25)
+ &#96;&#96;&#96;
+ 
+ **ent**: Facebook's ORM, generates type-safe code:
+ 
+ &#96;&#96;&#96;go
+ client.User.Query().
+     Where(user.AgeGT(25)).
+     All(ctx)
+ &#96;&#96;&#96;
+ 
+ **sqlc**: Generates Go code from SQL:
+ 
+ &#96;&#96;&#96;sql
+ -- queries.sql
+ -- name: GetUser :one
+ SELECT * FROM users WHERE id = $1;
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Generated code
+ user, err := queries.GetUser(ctx, userID)
+ &#96;&#96;&#96;
+ 
+ **bun**: Lightweight ORM with better SQL control:
+ 
+ &#96;&#96;&#96;go
+ err := db.NewSelect().
+     Model(&amp;users).
+     Where("age &gt; ?", 25).
+     Scan(ctx)
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ GORM vs EF Core isn't a fair fight. EF is more mature, better integrated with .NET, and has superior tooling.
+ 
+ **When GORM makes sense:**
+ - You want EF-like productivity
+ - Your queries are mostly CRUD
+ - You're okay with the magic
+ - Team is familiar with ORMs
+ 
+ **When to avoid GORM:**
+ - Complex queries are common
+ - Performance is critical
+ - You prefer explicit SQL
+ - Team prefers "no magic"
+ 
+ **What GORM does well:**
+ - Fast development
+ - Relationship handling
+ - Migrations (basic)
+ - Familiar to ORM users
+ 
+ **What EF does better:**
+ - LINQ (type-safe queries)
+ - Change tracking
+ - Migration tooling
+ - Integration with ASP.NET
+ 
+ **The verdict:**
+ If you're building a CRUD service and miss EF's productivity, GORM is reasonable. If you're doing complex queries or care about explicit control, stick with &#96;database/sql&#96; + sqlx.
+ 
+ Many Go developers start with GORM, then move to sqlx or sqlc as they get comfortable with Go's explicit style. That's a valid journey.
+ 
+ ---
+ 
+ *Next up: tooling—linting, formatting, and why gofmt is non-negotiable.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-linting.md</summary>

**Chunk 1**
Lines added: 261, lines removed: 1

```diff
@@ -1,1 +1,261 @@
- 
+ +++
+ title = "Linting and Formatting: gofmt Is Non-Negotiable"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "linting", "csharp"]
+ +++
+ 
+ In C#, code formatting is a matter of preference. Tabs or spaces? Braces on the same line or next? Teams debate, &#96;.editorconfig&#96; files proliferate, and nobody quite agrees.
+ 
+ In Go, formatting is not a discussion. &#96;gofmt&#96; defines the One True Format, and everyone uses it. There is no debate because there's no choice.
+ 
+ This sounds authoritarian. It's actually liberating.
+ 
+ ## gofmt: The Formatter
+ 
+ Every Go file should be formatted by &#96;gofmt&#96;:
+ 
+ &#96;&#96;&#96;bash
+ gofmt -w .              # format all files in place
+ go fmt ./...            # same thing, via go command
+ &#96;&#96;&#96;
+ 
+ &#96;gofmt&#96; handles:
+ - Indentation (tabs, not spaces)
+ - Brace placement (same line, always)
+ - Spacing around operators
+ - Import grouping
+ - Line length (it doesn't wrap, but long lines are a code smell)
+ 
+ There are no options. No configuration. One format for all Go code, everywhere.
+ 
+ ## The Philosophy
+ 
+ Rob Pike (Go co-creator): "Gofmt's style is no one's favourite, yet gofmt is everyone's favourite."
+ 
+ The point isn't that &#96;gofmt&#96;'s choices are optimal. The point is that *having* a choice wastes time. Every Go codebase looks the same, which means:
+ 
+ - No bikeshedding about style
+ - Pull reviews focus on logic, not formatting  
+ - New team members read unfamiliar code easily
+ - Tooling (IDEs, linters) can assume standard formatting
+ 
+ ## goimports: gofmt Plus Import Management
+ 
+ &#96;goimports&#96; does everything &#96;gofmt&#96; does, plus:
+ - Adds missing imports
+ - Removes unused imports
+ - Groups imports (stdlib, external, internal)
+ 
+ &#96;&#96;&#96;bash
+ go install golang.org/x/tools/cmd/goimports@latest
+ goimports -w .
+ &#96;&#96;&#96;
+ 
+ Most developers use &#96;goimports&#96; instead of plain &#96;gofmt&#96;. Configure your editor to run it on save.
+ 
+ ## Linting with golangci-lint
+ 
+ Formatting ensures consistency. Linting catches bugs and enforces best practices.
+ 
+ &#96;golangci-lint&#96; is the standard meta-linter—it runs many linters in one tool:
+ 
+ &#96;&#96;&#96;bash
+ # Install
+ go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
+ 
+ # Run
+ golangci-lint run
+ &#96;&#96;&#96;
+ 
+ Default linters catch:
+ - Unused variables and imports
+ - Ineffective assignments  
+ - Missing error checks
+ - Suspicious constructs
+ 
+ ## Common Linters
+ 
+ &#96;golangci-lint&#96; bundles dozens of linters. Key ones:
+ 
+ | Linter | Purpose |
+ |--------|---------|
+ | &#96;errcheck&#96; | Unchecked errors |
+ | &#96;gosimple&#96; | Simplification suggestions |
+ | &#96;govet&#96; | Suspicious constructs |
+ | &#96;ineffassign&#96; | Ineffectual assignments |
+ | &#96;staticcheck&#96; | Advanced static analysis |
+ | &#96;unused&#96; | Unused code |
+ | &#96;gosec&#96; | Security issues |
+ | &#96;misspell&#96; | Spelling mistakes |
+ | &#96;gocyclo&#96; | Cyclomatic complexity |
+ | &#96;gocritic&#96; | Opinionated style issues |
+ 
+ ## Configuration
+ 
+ Create &#96;.golangci.yml&#96;:
+ 
+ &#96;&#96;&#96;yaml
+ linters:
+   enable:
+     - errcheck
+     - gosimple
+     - govet
+     - ineffassign
+     - staticcheck
+     - unused
+     - gosec
+     - misspell
+     
+ linters-settings:
+   errcheck:
+     check-type-assertions: true
+   govet:
+     check-shadowing: true
+   gocyclo:
+     min-complexity: 15
+ 
+ issues:
+   exclude-rules:
+     - path: _test\.go
+       linters:
+         - gosec  # less strict in tests
+ &#96;&#96;&#96;
+ 
+ Run with:
+ 
+ &#96;&#96;&#96;bash
+ golangci-lint run
+ golangci-lint run --fix  # auto-fix where possible
+ &#96;&#96;&#96;
+ 
+ ## staticcheck
+ 
+ The most powerful individual linter. It catches subtle bugs:
+ 
+ &#96;&#96;&#96;go
+ // staticcheck catches this
+ if x == nil {
+     return x.String()  // nil dereference
+ }
+ 
+ // And this
+ for i := range items {
+     go func() {
+         process(items[i])  // captures loop variable
+     }()
+ }
+ &#96;&#96;&#96;
+ 
+ Many issues that would be runtime errors become compile-time warnings.
+ 
+ ## Comparing to .NET Analyzers
+ 
+ | Feature | .NET Analyzers | Go Linting |
+ |---------|----------------|------------|
+ | Format enforcement | Optional (EditorConfig) | Mandatory (gofmt) |
+ | Built-in | Some analyzers | gofmt, go vet |
+ | Meta-linter | StyleCop, Roslyn | golangci-lint |
+ | IDE integration | Excellent | Good |
+ | CI integration | Easy | Easy |
+ | Auto-fix | Many rules | Some rules |
+ 
+ .NET has the advantage of the Roslyn compiler platform—analyzers can be very sophisticated. Go's linters are simpler but catch most issues.
+ 
+ ## Editor Integration
+ 
+ ### VS Code
+ 
+ Install the Go extension. Add to &#96;settings.json&#96;:
+ 
+ &#96;&#96;&#96;json
+ {
+     "go.formatTool": "goimports",
+     "go.lintTool": "golangci-lint",
+     "editor.formatOnSave": true,
+     "[go]": {
+         "editor.defaultFormatter": "golang.go",
+         "editor.codeActionsOnSave": {
+             "source.organizeImports": true
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### GoLand
+ 
+ Built-in support. Enable "Reformat code" and "Optimize imports" on save.
+ 
+ ### Vim/Neovim
+ 
+ Use &#96;vim-go&#96; or configure &#96;gopls&#96; (the Go language server) with your LSP setup.
+ 
+ ## CI Integration
+ 
+ Add to your pipeline:
+ 
+ &#96;&#96;&#96;yaml
+ # GitHub Actions
+ - name: golangci-lint
+   uses: golangci/golangci-lint-action@v4
+   with:
+     version: latest
+ &#96;&#96;&#96;
+ 
+ Or manually:
+ 
+ &#96;&#96;&#96;bash
+ # Install
+ curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin
+ 
+ # Run
+ golangci-lint run --timeout 5m
+ &#96;&#96;&#96;
+ 
+ ## Pre-commit Hooks
+ 
+ Enforce formatting before commit:
+ 
+ &#96;&#96;&#96;bash
+ # .git/hooks/pre-commit
+ #!/bin/sh
+ gofmt -l . | read &amp;&amp; echo "Files not formatted" &amp;&amp; exit 1
+ golangci-lint run &amp;&amp; exit 0 || exit 1
+ &#96;&#96;&#96;
+ 
+ Or use [pre-commit](https://pre-commit.com/):
+ 
+ &#96;&#96;&#96;yaml
+ # .pre-commit-config.yaml
+ repos:
+   - repo: https://github.com/golangci/golangci-lint
+     rev: v1.55.0
+     hooks:
+       - id: golangci-lint
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's enforced formatting is one of its best features. No arguments, no decisions, no config files.
+ 
+ **What Go does better:**
+ - No bikeshedding—ever
+ - All code looks the same
+ - &#96;gofmt&#96; is fast and universal
+ - No configuration to maintain
+ 
+ **What .NET does better:**
+ - More formatting options (if you want them)
+ - Roslyn analyzers are very powerful
+ - Better code action suggestions
+ - More sophisticated refactoring
+ 
+ **The verdict:**
+ You'll miss zero formatting decisions. You won't miss the arguments about formatting. &#96;golangci-lint&#96; catches most issues; enable it and move on.
+ 
+ The Go community's attitude is refreshing: format your code, lint it, and spend your energy on actual problems.
+ 
+ ---
+ 
+ *Next up: code generation with &#96;go generate&#96;—why Go developers love generating code.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generate.md</summary>

**Chunk 1**
Lines added: 311, lines removed: 1

```diff
@@ -1,1 +1,311 @@
- 
+ +++
+ title = "Generate All the Things"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "codegen", "csharp"]
+ +++
+ 
+ Go developers love code generation. Where C# uses reflection, attributes, and source generators, Go often uses tools that generate code before compilation.
+ 
+ This sounds backwards—writing code that writes code? But it has advantages: generated code is inspectable, debuggable, and has zero runtime overhead.
+ 
+ ## The go generate Command
+ 
+ Add a magic comment to your source file:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=Status
+ 
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+ )
+ &#96;&#96;&#96;
+ 
+ Run:
+ 
+ &#96;&#96;&#96;bash
+ go generate ./...
+ &#96;&#96;&#96;
+ 
+ This runs &#96;stringer -type=Status&#96; in the package directory, which generates &#96;status_string.go&#96;:
+ 
+ &#96;&#96;&#96;go
+ // Code generated by "stringer -type=Status"; DO NOT EDIT.
+ 
+ func (i Status) String() string {
+     switch i {
+     case StatusPending:
+         return "StatusPending"
+     case StatusActive:
+         return "StatusActive"
+     case StatusCompleted:
+         return "StatusCompleted"
+     }
+     return "Status(" + strconv.FormatInt(int64(i), 10) + ")"
+ }
+ &#96;&#96;&#96;
+ 
+ The generated code is committed to your repo. It's just Go code.
+ 
+ ## Common Code Generators
+ 
+ ### stringer
+ 
+ Generates &#96;String()&#96; methods for constants:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=LogLevel
+ &#96;&#96;&#96;
+ 
+ We covered this in the enums post.
+ 
+ ### mockgen
+ 
+ Generates mock implementations:
+ 
+ &#96;&#96;&#96;go
+ //go:generate mockgen -source=repository.go -destination=mock_repository.go -package=repo
+ &#96;&#96;&#96;
+ 
+ Creates mock structs for testing.
+ 
+ ### sqlc
+ 
+ Generates type-safe database code from SQL:
+ 
+ &#96;&#96;&#96;sql
+ -- queries/users.sql
+ -- name: GetUser :one
+ SELECT id, name, email FROM users WHERE id = $1;
+ 
+ -- name: ListUsers :many
+ SELECT id, name, email FROM users ORDER BY name;
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ //go:generate sqlc generate
+ &#96;&#96;&#96;
+ 
+ Produces:
+ 
+ &#96;&#96;&#96;go
+ func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
+     row := q.db.QueryRowContext(ctx, getUserSQL, id)
+     var i User
+     err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Email)
+     return i, err
+ }
+ &#96;&#96;&#96;
+ 
+ Type-safe queries with no reflection.
+ 
+ ### protoc (Protocol Buffers)
+ 
+ Generates Go code from &#96;.proto&#96; files:
+ 
+ &#96;&#96;&#96;go
+ //go:generate protoc --go_out=. --go-grpc_out=. api.proto
+ &#96;&#96;&#96;
+ 
+ ### oapi-codegen
+ 
+ Generates code from OpenAPI specs:
+ 
+ &#96;&#96;&#96;go
+ //go:generate oapi-codegen -package api -generate types,server openapi.yaml
+ &#96;&#96;&#96;
+ 
+ ### ent
+ 
+ Generates ORM code:
+ 
+ &#96;&#96;&#96;go
+ //go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema
+ &#96;&#96;&#96;
+ 
+ ## Writing Your Own Generator
+ 
+ Generators are just programs. You can write your own:
+ 
+ &#96;&#96;&#96;go
+ // gen/main.go
+ package main
+ 
+ import (
+     "os"
+     "text/template"
+ )
+ 
+ var tmpl = &#96;// Code generated; DO NOT EDIT.
+ package {{.Package}}
+ 
+ var Version = "{{.Version}}"
+ var BuildTime = "{{.BuildTime}}"
+ &#96;
+ 
+ func main() {
+     t := template.Must(template.New("version").Parse(tmpl))
+     
+     data := map[string]string{
+         "Package":   os.Getenv("GOPACKAGE"),
+         "Version":   os.Getenv("VERSION"),
+         "BuildTime": time.Now().Format(time.RFC3339),
+     }
+     
+     f, _ := os.Create("version_gen.go")
+     defer f.Close()
+     t.Execute(f, data)
+ }
+ &#96;&#96;&#96;
+ 
+ Use it:
+ 
+ &#96;&#96;&#96;go
+ //go:generate go run gen/main.go
+ &#96;&#96;&#96;
+ 
+ ## The go:generate Directive
+ 
+ The comment format:
+ 
+ &#96;&#96;&#96;go
+ //go:generate command arg1 arg2
+ &#96;&#96;&#96;
+ 
+ Rules:
+ - Must start with &#96;//go:generate&#96; (no space after //)
+ - The command runs in the package directory
+ - Environment variables available: &#96;$GOPACKAGE&#96;, &#96;$GOFILE&#96;, &#96;$GOLINE&#96;
+ - Output to stderr shows during generation
+ 
+ Multiple directives are fine:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=Status
+ //go:generate mockgen -source=service.go -destination=mock_service.go
+ &#96;&#96;&#96;
+ 
+ ## Comparing to C# Source Generators
+ 
+ C# has source generators (Roslyn) that run during compilation:
+ 
+ &#96;&#96;&#96;csharp
+ [Generator]
+ public class MyGenerator : ISourceGenerator
+ {
+     public void Execute(GeneratorExecutionContext context)
+     {
+         // Generate code based on syntax trees
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ | Aspect | C# Source Generators | Go go:generate |
+ |--------|---------------------|----------------|
+ | When runs | During compilation | Before compilation |
+ | Output | In-memory | Files in repo |
+ | Debugging | Harder | Easy (it's just files) |
+ | IDE support | Integrated | Manual regeneration |
+ | Dependencies | Part of build | External tools |
+ | Incremental | Yes | Manual |
+ 
+ C#'s generators are more integrated. Go's are more transparent.
+ 
+ ## Best Practices
+ 
+ **1. Commit generated code**
+ 
+ Generated code should be in your repo:
+ - CI doesn't need generator tools
+ - Code review includes generated changes
+ - git blame works
+ 
+ **2. Mark generated files**
+ 
+ Start with the standard header:
+ 
+ &#96;&#96;&#96;go
+ // Code generated by TOOL; DO NOT EDIT.
+ &#96;&#96;&#96;
+ 
+ Linters and editors recognize this and treat the file specially.
+ 
+ **3. Regenerate in CI**
+ 
+ Verify generated code is up-to-date:
+ 
+ &#96;&#96;&#96;yaml
+ - name: Check generated code
+   run: |
+     go generate ./...
+     git diff --exit-code
+ &#96;&#96;&#96;
+ 
+ Fails if generated code differs from committed code.
+ 
+ **4. Document generation**
+ 
+ In your README or Makefile:
+ 
+ &#96;&#96;&#96;makefile
+ generate:
+ 	go generate ./...
+ 
+ .PHONY: generate
+ &#96;&#96;&#96;
+ 
+ **5. Keep generators fast**
+ 
+ &#96;go generate&#96; runs serially. Slow generators hurt iteration speed.
+ 
+ ## Real-World Example
+ 
+ A typical project might have:
+ 
+ &#96;&#96;&#96;go
+ // internal/domain/status.go
+ //go:generate stringer -type=Status
+ 
+ // internal/repository/repository.go  
+ //go:generate mockgen -source=repository.go -destination=mock_repository.go -package=repository
+ 
+ // internal/database/queries.sql
+ //go:generate sqlc generate
+ 
+ // api/openapi.yaml
+ //go:generate oapi-codegen -package api -generate types,server,spec -o api_gen.go openapi.yaml
+ &#96;&#96;&#96;
+ 
+ Run &#96;go generate ./...&#96; and all these tools produce code.
+ 
+ ## The Honest Take
+ 
+ Code generation is more prominent in Go than C#. It's a cultural thing—Go prefers explicit, inspectable code over runtime magic.
+ 
+ **What Go does well:**
+ - Generated code is transparent
+ - Easy to debug (it's just files)
+ - No runtime reflection overhead
+ - Tools are standalone programs
+ 
+ **What C# does better:**
+ - Source generators are integrated
+ - IDE understands generated code immediately
+ - Incremental generation
+ - No manual regeneration step
+ 
+ **The verdict:**
+ If you're not used to code generation, it feels weird. But once you embrace it, you appreciate the transparency.
+ 
+ sqlc in particular is wonderful—type-safe database access without ORM magic, because the queries are analyzed at generation time.
+ 
+ Learn to love &#96;go generate ./...&#96;. It's part of the Go workflow.
+ 
+ ---
+ 
+ *Next up: debugging with Delve—getting productive with dlv after Visual Studio's polished debugging experience.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-debugging.md</summary>

**Chunk 1**
Lines added: 305, lines removed: 1

```diff
@@ -1,1 +1,305 @@
- 
+ +++
+ title = "Debugging: Delve vs Visual Studio's Comfort"
+ date = "2025-01-04"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "debugging", "csharp"]
+ +++
+ 
+ Visual Studio's debugger is exceptional. Breakpoints, watch expressions, edit-and-continue, conditional breakpoints, data tips, memory inspection, async debugging... You can debug anything, easily.
+ 
+ Go's debugger is Delve (&#96;dlv&#96;). It's good. It's not Visual Studio.
+ 
+ Let's get you productive with what Go offers.
+ 
+ ## Delve Basics
+ 
+ Install:
+ 
+ &#96;&#96;&#96;bash
+ go install github.com/go-delve/delve/cmd/dlv@latest
+ &#96;&#96;&#96;
+ 
+ Start debugging:
+ 
+ &#96;&#96;&#96;bash
+ # Debug current package
+ dlv debug
+ 
+ # Debug specific package
+ dlv debug ./cmd/server
+ 
+ # Debug a test
+ dlv test
+ 
+ # Attach to running process
+ dlv attach &lt;pid&gt;
+ &#96;&#96;&#96;
+ 
+ ## Command-Line Debugging
+ 
+ Inside &#96;dlv&#96;:
+ 
+ &#96;&#96;&#96;
+ (dlv) break main.go:15          # set breakpoint
+ (dlv) break main.handleRequest  # break on function
+ (dlv) continue                  # run until breakpoint
+ (dlv) next                      # step over
+ (dlv) step                      # step into
+ (dlv) stepout                   # step out
+ (dlv) print x                   # print variable
+ (dlv) locals                    # print local variables
+ (dlv) args                      # print function arguments
+ (dlv) goroutines                # list goroutines
+ (dlv) goroutine 5               # switch to goroutine 5
+ (dlv) stack                     # print stack trace
+ (dlv) exit                      # quit
+ &#96;&#96;&#96;
+ 
+ ## IDE Integration
+ 
+ Nobody uses &#96;dlv&#96; on the command line for daily work. Use your IDE.
+ 
+ ### VS Code
+ 
+ The Go extension integrates Delve. Create &#96;.vscode/launch.json&#96;:
+ 
+ &#96;&#96;&#96;json
+ {
+     "version": "0.2.0",
+     "configurations": [
+         {
+             "name": "Launch",
+             "type": "go",
+             "request": "launch",
+             "mode": "debug",
+             "program": "${workspaceFolder}",
+             "args": []
+         },
+         {
+             "name": "Launch Server",
+             "type": "go",
+             "request": "launch",
+             "mode": "debug",
+             "program": "${workspaceFolder}/cmd/server",
+             "args": ["-port", "8080"]
+         },
+         {
+             "name": "Debug Test",
+             "type": "go",
+             "request": "launch",
+             "mode": "test",
+             "program": "${workspaceFolder}/pkg/service"
+         },
+         {
+             "name": "Attach",
+             "type": "go",
+             "request": "attach",
+             "mode": "remote",
+             "remotePath": "",
+             "port": 2345,
+             "host": "127.0.0.1"
+         }
+     ]
+ }
+ &#96;&#96;&#96;
+ 
+ Press F5 to debug. Breakpoints, watch variables, call stack—the usual.
+ 
+ ### GoLand
+ 
+ JetBrains GoLand has excellent debugging. Click in the gutter to set breakpoints, right-click to run debug, use the Debug panel.
+ 
+ GoLand's debugger is the closest to Visual Studio's experience in the Go world.
+ 
+ ## Debugging Tests
+ 
+ Debug a specific test in VS Code:
+ 
+ 1. Open the test file
+ 2. Click "debug test" above the test function
+ 3. Or add a launch config with &#96;"mode": "test"&#96;
+ 
+ From command line:
+ 
+ &#96;&#96;&#96;bash
+ dlv test -- -test.run TestSpecificFunction
+ &#96;&#96;&#96;
+ 
+ ## Conditional Breakpoints
+ 
+ Set a breakpoint that only triggers under conditions:
+ 
+ &#96;&#96;&#96;
+ (dlv) break main.go:25
+ (dlv) condition 1 i &gt; 100
+ &#96;&#96;&#96;
+ 
+ In VS Code, right-click a breakpoint and select "Edit Breakpoint" to add conditions.
+ 
+ ## Debugging Goroutines
+ 
+ This is where Go debugging gets interesting. Your program has many goroutines:
+ 
+ &#96;&#96;&#96;
+ (dlv) goroutines
+   Goroutine 1 - User: ./main.go:15 main.main (0x4a5b6c)
+   Goroutine 2 - User: ./server.go:42 main.handleRequest (0x4a6d8e)
+   Goroutine 3 - User: ./worker.go:28 main.processJob (0x4a7f90)
+ &#96;&#96;&#96;
+ 
+ Switch between them:
+ 
+ &#96;&#96;&#96;
+ (dlv) goroutine 2
+ (dlv) stack
+ &#96;&#96;&#96;
+ 
+ In VS Code, the Call Stack panel shows all goroutines. Click to switch.
+ 
+ ## Remote Debugging
+ 
+ Debug a process on another machine:
+ 
+ On the remote:
+ 
+ &#96;&#96;&#96;bash
+ dlv debug --headless --listen=:2345 --api-version=2 ./cmd/server
+ &#96;&#96;&#96;
+ 
+ On your machine, connect with VS Code:
+ 
+ &#96;&#96;&#96;json
+ {
+     "name": "Remote",
+     "type": "go",
+     "request": "attach",
+     "mode": "remote",
+     "remotePath": "/path/on/remote",
+     "port": 2345,
+     "host": "remote.server.com"
+ }
+ &#96;&#96;&#96;
+ 
+ ## Debugging in Containers
+ 
+ Add Delve to your container:
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM golang:1.22 AS builder
+ RUN go install github.com/go-delve/delve/cmd/dlv@latest
+ COPY . .
+ RUN go build -gcflags="all=-N -l" -o /app ./cmd/server
+ 
+ FROM alpine
+ COPY --from=builder /go/bin/dlv /usr/local/bin/
+ COPY --from=builder /app /app
+ EXPOSE 8080 2345
+ CMD ["dlv", "--listen=:2345", "--headless=true", "--api-version=2", "--accept-multiclient", "exec", "/app"]
+ &#96;&#96;&#96;
+ 
+ The &#96;-gcflags="all=-N -l"&#96; disables optimisations for better debugging.
+ 
+ ## Comparing to Visual Studio
+ 
+ | Feature | Visual Studio | Delve |
+ |---------|---------------|-------|
+ | Basic breakpoints | Excellent | Good |
+ | Conditional breakpoints | Excellent | Good |
+ | Watch expressions | Excellent | Good |
+ | Edit and continue | Yes | No |
+ | Data visualizers | Rich | Basic |
+ | Async/Task debugging | Excellent | Goroutines visible |
+ | Memory inspection | Detailed | Basic |
+ | Performance profiling | Integrated | Separate tools |
+ | Remote debugging | Excellent | Good |
+ 
+ ## Common Issues
+ 
+ **"Could not launch process"**
+ 
+ Compilation failed. Check &#96;go build&#96; works first.
+ 
+ **Breakpoints not hitting**
+ 
+ Optimised builds skip breakpoints. Build with:
+ 
+ &#96;&#96;&#96;bash
+ go build -gcflags="all=-N -l"
+ &#96;&#96;&#96;
+ 
+ **Variables showing &#96;&lt;optimized out&gt;&#96;**
+ 
+ Same issue—disable optimisations.
+ 
+ **Can't see struct fields**
+ 
+ Unexported fields don't show in some views. Use &#96;print&#96; command with full path:
+ 
+ &#96;&#96;&#96;
+ (dlv) print user.internalField
+ &#96;&#96;&#96;
+ 
+ ## Debugging Tips
+ 
+ **Printf debugging is valid**
+ 
+ Sometimes &#96;fmt.Println&#96; is faster than setting up a debugger. Go compiles fast; the feedback loop is quick.
+ 
+ **Use slog for structured debugging**
+ 
+ &#96;&#96;&#96;go
+ slog.Debug("processing request", 
+     "request_id", requestID,
+     "user_id", userID,
+     "payload_size", len(payload),
+ )
+ &#96;&#96;&#96;
+ 
+ Run with &#96;DEBUG=true&#96; or appropriate log level.
+ 
+ **Panic stack traces are helpful**
+ 
+ When Go panics, you get a full stack trace. Read it:
+ 
+ &#96;&#96;&#96;
+ panic: runtime error: invalid memory address
+ 
+ goroutine 1 [running]:
+ main.processUser(...)
+     /app/main.go:42
+ main.handleRequest(...)
+     /app/main.go:28
+ main.main()
+     /app/main.go:15
+ &#96;&#96;&#96;
+ 
+ Line numbers and function names. Often enough to find the bug.
+ 
+ ## The Honest Take
+ 
+ Delve is competent. It's not Visual Studio.
+ 
+ **What Delve does well:**
+ - Goroutine debugging
+ - Remote debugging
+ - IDE integration (especially GoLand)
+ - Fast startup
+ 
+ **What Visual Studio does better:**
+ - Edit and continue
+ - Data visualization
+ - Memory inspection
+ - Historical debugging
+ - Overall polish
+ 
+ **The verdict:**
+ You'll miss Visual Studio's refinement. GoLand gets closest to that experience. VS Code with Delve is good enough for most debugging.
+ 
+ The Go community relies more on logging, tests, and reading stack traces than step debugging. The fast compile times mean printf debugging has a quick feedback loop.
+ 
+ Adjust your expectations, learn Delve's commands, and you'll be productive. Just don't expect Visual Studio's magic.
+ 
+ ---
+ 
+ *That wraps up the tooling section. Go's tools are simpler than .NET's—&#96;gofmt&#96; instead of formatting debates, &#96;golangci-lint&#96; instead of analyzer configuration, &#96;go generate&#96; instead of source generators. Simpler isn't always better, but it's often good enough.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
      36

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 36 posts are done and the build passes. Let me summarize the complete series for the user.</details></think>

---

All 9 posts done! **36 posts total now.** Here's the complete series:

## C# to Go Series (36 posts)

### Phase 1: The Fundamentals (22 posts)

**Getting Oriented** (3)
1-3. Toolchain, go.mod, Phrasebook

**Types & Data** (5)
4-8. Structs, Visibility, Generics, Nil, Enums

**Control Flow & Error Handling** (3)
9-11. Errors, Panic/Recover, Switch

**Memory & Pointers** (3)
12-14. Pointers, Escape Analysis, Slices

**Concurrency** (5)
15-19. Goroutines, Channels, Select, Sync, Context

**Interfaces & Composition** (3)
20-22. Implicit Interfaces, Composition/Embedding, any/type assertions

---

### Phase 2: The Ecosystem (14 posts)

**Project Structure & Modules** (2)
23-24. Project Structure, Multi-Module Repos

**Testing** (3)
25-27. Built-in Testing, Mocking, Benchmarks/Profiling

**Common Patterns & Libraries** (6) ← **NEW**
28. **"HTTP Services: net/http vs ASP.NET Core"** — Handlers, middleware, routing (Go 1.22+), comparing to minimal APIs
29. **"JSON: Struct Tags and the Marshal Dance"** — Struct tags, omitempty gotcha, custom marshalling, dynamic JSON
30. **"Configuration Without IOptions<T>"** — Environment variables, envconfig, Viper, keeping it simple
31. **"Logging: slog and the Structured Logging Story"** — Go 1.21's slog, levels, attributes, comparing to ILogger
32. **"Database Access: database/sql vs Entity Framework"** — Raw SQL, scanning, transactions, sqlx, missing your ORM
33. **"GORM and Friends: When You Do Want an ORM"** — GORM basics, relationships, when to use/avoid, alternatives

**Tooling** (3) ← **NEW**
34. **"Linting and Formatting: gofmt Is Non-Negotiable"** — gofmt, goimports, golangci-lint, no debates
35. **"Generate All the Things"** — go:generate, stringer, sqlc, mockgen, writing your own generators
36. **"Debugging: Delve vs Visual Studio's Comfort"** — dlv commands, IDE integration, goroutine debugging, adjusting expectations

---

Ready for Phase 3: Deployment whenever you want to tackle containers, cloud, CI/CD, and observability!

---

_**User (2025-12-31 01:06Z)**_

let's go with teh deployment section now:

Phase 3: Deployment & Production
Building & Distributing

Single Binary Deploys: The Killer Feature — Cross-compilation, no runtime dependencies, and why ops will love you
Shrinking Binaries and Build Tags — ldflags, conditional compilation, and keeping things lean

Containers & Cloud

Dockerfile for Go: Simpler Than You'd Think — Multi-stage builds, scratch images, and distroless
AWS Lambda and Go: Cold Starts That Don't Hurt — Serverless without the .NET cold start tax
Kubernetes and Go: A Natural Fit — Health checks, graceful shutdown, and playing nice with orchestration

Observability

Metrics, Traces, and Logs: The OpenTelemetry Way — Instrumenting Go services for production
Health Checks and Readiness Probes — Patterns that work in container orchestrators

CI/CD

GitHub Actions for Go Projects — Testing, linting, and releasing with goreleaser
Versioning Your Modules — Semantic versioning, tags, and avoiding dependency hell

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create 9 posts for Phase 3: Deployment & Production. Let me write all of them following the established tone and style.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-single-binary.md</summary>

**Chunk 1**
Lines added: 266, lines removed: 1

```diff
@@ -1,1 +1,266 @@
- 
+ +++
+ title = "Single Binary Deploys: The Killer Feature"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "deployment", "cross-compilation", "csharp"]
+ +++
+ 
+ Here's the thing that sold me on Go for production: you build a binary, you copy it to a server, you run it. No runtime to install. No framework version matching. No dependency hell. Just a file.
+ 
+ If you've ever dealt with .NET runtime versioning on servers, or debugged why &#96;dotnet&#96; can't find the right SDK, or explained to ops why they need to install framework X before deploying your app—Go's deployment model will feel like a revelation.
+ 
+ ## The .NET Deployment Model
+ 
+ In .NET, you have choices:
+ 
+ **Framework-dependent (FDD)**:
+ &#96;&#96;&#96;bash
+ dotnet publish -c Release
+ # Produces DLLs, needs .NET runtime on target
+ &#96;&#96;&#96;
+ 
+ Small output, but requires runtime installation and version matching.
+ 
+ **Self-contained (SCD)**:
+ &#96;&#96;&#96;bash
+ dotnet publish -c Release --self-contained -r linux-x64
+ # Produces executable + runtime + dependencies
+ # ~70MB+ for a simple API
+ &#96;&#96;&#96;
+ 
+ Everything included, but large.
+ 
+ **Single-file**:
+ &#96;&#96;&#96;bash
+ dotnet publish -c Release --self-contained -r linux-x64 -p:PublishSingleFile=true
+ # Extracts to temp on first run
+ &#96;&#96;&#96;
+ 
+ One file, but it's a bundle that extracts itself.
+ 
+ **Native AOT** (.NET 7+):
+ &#96;&#96;&#96;bash
+ dotnet publish -c Release -r linux-x64 -p:PublishAot=true
+ # True native binary, ~10-30MB
+ &#96;&#96;&#96;
+ 
+ Finally a real binary, but limited reflection support.
+ 
+ ## The Go Model: Just Build
+ 
+ &#96;&#96;&#96;bash
+ go build -o myapp ./cmd/server
+ &#96;&#96;&#96;
+ 
+ That's it. &#96;myapp&#96; is a statically-linked binary. Copy it anywhere with the same OS/architecture and run it.
+ 
+ &#96;&#96;&#96;bash
+ scp myapp server:/usr/local/bin/
+ ssh server '/usr/local/bin/myapp'
+ &#96;&#96;&#96;
+ 
+ No runtime. No dependencies. No extraction. No installation.
+ 
+ ## Cross-Compilation
+ 
+ This is where Go shines. Build for any platform from any platform:
+ 
+ &#96;&#96;&#96;bash
+ # From macOS, build for Linux
+ GOOS=linux GOARCH=amd64 go build -o myapp-linux
+ 
+ # Build for Windows
+ GOOS=windows GOARCH=amd64 go build -o myapp.exe
+ 
+ # Build for ARM (Raspberry Pi, AWS Graviton)
+ GOOS=linux GOARCH=arm64 go build -o myapp-arm64
+ &#96;&#96;&#96;
+ 
+ No Docker, no VMs, no cross-compilers to install. Set environment variables, build.
+ 
+ ### All Platforms
+ 
+ Common targets:
+ 
+ | GOOS | GOARCH | Target |
+ |------|--------|--------|
+ | linux | amd64 | Standard Linux servers |
+ | linux | arm64 | AWS Graviton, ARM servers |
+ | darwin | amd64 | Intel Macs |
+ | darwin | arm64 | Apple Silicon Macs |
+ | windows | amd64 | Windows servers |
+ 
+ &#96;&#96;&#96;bash
+ # Build for all common targets
+ for os in linux darwin windows; do
+   for arch in amd64 arm64; do
+     GOOS=$os GOARCH=$arch go build -o myapp-$os-$arch ./cmd/server
+   done
+ done
+ &#96;&#96;&#96;
+ 
+ ## Static Linking by Default
+ 
+ Go binaries are statically linked by default. No shared library dependencies:
+ 
+ &#96;&#96;&#96;bash
+ ldd myapp
+ # not a dynamic executable
+ &#96;&#96;&#96;
+ 
+ Compare to a typical C program:
+ 
+ &#96;&#96;&#96;bash
+ ldd /usr/bin/ls
+ # linux-vdso.so.1
+ # libselinux.so.1
+ # libc.so.6
+ # libpcre2-8.so.0
+ # ...
+ &#96;&#96;&#96;
+ 
+ Static linking means:
+ - No "works on my machine" due to library versions
+ - Deploy to minimal containers (scratch, distroless)
+ - No glibc compatibility concerns
+ 
+ ### CGO and Dynamic Linking
+ 
+ The exception is CGO—Go code that calls C libraries:
+ 
+ &#96;&#96;&#96;go
+ // #include &lt;sqlite3.h&gt;
+ import "C"
+ &#96;&#96;&#96;
+ 
+ CGO produces dynamically-linked binaries. Disable it if you don't need it:
+ 
+ &#96;&#96;&#96;bash
+ CGO_ENABLED=0 go build -o myapp
+ &#96;&#96;&#96;
+ 
+ Most pure-Go programs don't need CGO.
+ 
+ ## Binary Size
+ 
+ A simple Go HTTP server: ~10-15MB
+ A typical Go CLI tool: ~5-10MB
+ A complex service with many dependencies: ~20-30MB
+ 
+ Compare to .NET self-contained: 70-150MB
+ Compare to .NET Native AOT: 10-30MB
+ 
+ Go binaries are competitive with .NET AOT and much smaller than self-contained.
+ 
+ ## Build Reproducibility
+ 
+ Go builds are reproducible by default. Same inputs, same binary:
+ 
+ &#96;&#96;&#96;bash
+ go build -o app1 ./cmd/server
+ go build -o app2 ./cmd/server
+ sha256sum app1 app2
+ # Same hash (usually)
+ &#96;&#96;&#96;
+ 
+ For guaranteed reproducibility:
+ 
+ &#96;&#96;&#96;bash
+ go build -trimpath -ldflags="-s -w" -o myapp
+ &#96;&#96;&#96;
+ 
+ - &#96;-trimpath&#96;: removes file paths from binary
+ - &#96;-s -w&#96;: strips debug info and DWARF
+ 
+ ## Deployment Patterns
+ 
+ ### Direct Binary Deployment
+ 
+ &#96;&#96;&#96;bash
+ # Build
+ go build -o myapp ./cmd/server
+ 
+ # Deploy
+ scp myapp server:/opt/myapp/
+ ssh server 'systemctl restart myapp'
+ &#96;&#96;&#96;
+ 
+ Systemd unit file:
+ 
+ &#96;&#96;&#96;ini
+ [Unit]
+ Description=My App
+ After=network.target
+ 
+ [Service]
+ Type=simple
+ ExecStart=/opt/myapp/myapp
+ Restart=always
+ Environment=PORT=8080
+ 
+ [Install]
+ WantedBy=multi-user.target
+ &#96;&#96;&#96;
+ 
+ ### Tarball Distribution
+ 
+ &#96;&#96;&#96;bash
+ # Build and package
+ go build -o myapp ./cmd/server
+ tar -czvf myapp-linux-amd64.tar.gz myapp config.yaml
+ 
+ # Distribute
+ curl -L https://releases.example.com/myapp-linux-amd64.tar.gz | tar xz
+ ./myapp
+ &#96;&#96;&#96;
+ 
+ ### Container (Preview for Later)
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM scratch
+ COPY myapp /myapp
+ ENTRYPOINT ["/myapp"]
+ &#96;&#96;&#96;
+ 
+ A container with just your binary. We'll cover this properly in the Dockerfile post.
+ 
+ ## The Comparison
+ 
+ | Aspect | .NET SCD | .NET AOT | Go |
+ |--------|----------|----------|-----|
+ | Binary size | 70-150MB | 10-30MB | 10-20MB |
+ | Cross-compilation | Limited | Limited | Trivial |
+ | Runtime required | No | No | No |
+ | Reflection support | Full | Limited | Full |
+ | CGO equivalent | P/Invoke | P/Invoke | CGO |
+ | Build time | Moderate | Slow | Fast |
+ | Static linking | Optional | Default | Default |
+ 
+ ## The Honest Take
+ 
+ Single binary deployment is Go's killer feature for operations.
+ 
+ **What Go does better:**
+ - Trivial cross-compilation
+ - Fast builds
+ - Small binaries by default
+ - No runtime installation
+ - Static linking by default
+ 
+ **What .NET does better:**
+ - .NET AOT is catching up
+ - Better Windows integration
+ - Richer ecosystem for some domains
+ - Native AOT on more platforms (eventually)
+ 
+ **The verdict:**
+ If deployment simplicity matters—and it should—Go wins. One binary, one target, done. 
+ 
+ Your ops team will thank you. Your deployment scripts will be three lines. Your containers will be tiny. Your CI/CD will be simple.
+ 
+ This is the feature that keeps Go relevant in a world of VMs and containers. Simplicity scales.
+ 
+ ---
+ 
+ *Next up: shrinking binaries and build tags—ldflags, conditional compilation, and getting even leaner.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-build-tags.md</summary>

**Chunk 1**
Lines added: 330, lines removed: 1

```diff
@@ -1,1 +1,330 @@
- 
+ +++
+ title = "Shrinking Binaries and Build Tags"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "deployment", "build-tags", "csharp"]
+ +++
+ 
+ Go binaries are already small compared to .NET self-contained deployments. But sometimes you want smaller—for Lambda deployments, embedded systems, or just because.
+ 
+ Let's look at &#96;ldflags&#96; for stripping binaries and build tags for conditional compilation.
+ 
+ ## Stripping with ldflags
+ 
+ The simplest optimisation:
+ 
+ &#96;&#96;&#96;bash
+ go build -ldflags="-s -w" -o myapp
+ &#96;&#96;&#96;
+ 
+ | Flag | Effect | Size Impact |
+ |------|--------|-------------|
+ | &#96;-s&#96; | Strip symbol table | ~15-20% smaller |
+ | &#96;-w&#96; | Strip DWARF debug info | ~10-15% smaller |
+ 
+ Combined, you might see 25-30% reduction.
+ 
+ Before:
+ &#96;&#96;&#96;bash
+ go build -o myapp &amp;&amp; ls -lh myapp
+ # 14M myapp
+ &#96;&#96;&#96;
+ 
+ After:
+ &#96;&#96;&#96;bash
+ go build -ldflags="-s -w" -o myapp &amp;&amp; ls -lh myapp
+ # 10M myapp
+ &#96;&#96;&#96;
+ 
+ ### Embedding Version Information
+ 
+ Use &#96;ldflags&#96; to set variables at build time:
+ 
+ &#96;&#96;&#96;go
+ // main.go
+ package main
+ 
+ var (
+     version   = "dev"
+     commit    = "none"
+     buildTime = "unknown"
+ )
+ 
+ func main() {
+     fmt.Printf("Version: %s, Commit: %s, Built: %s\n", version, commit, buildTime)
+ }
+ &#96;&#96;&#96;
+ 
+ Build with values:
+ 
+ &#96;&#96;&#96;bash
+ go build -ldflags="-s -w \
+   -X main.version=1.2.3 \
+   -X main.commit=$(git rev-parse --short HEAD) \
+   -X main.buildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
+   -o myapp
+ &#96;&#96;&#96;
+ 
+ Now &#96;myapp --version&#96; shows real build info, baked in at compile time.
+ 
+ ## Build Tags: Conditional Compilation
+ 
+ Build tags let you include/exclude files based on conditions. It's Go's equivalent to &#96;#if DEBUG&#96; or conditional compilation symbols.
+ 
+ ### File-Level Tags
+ 
+ Add a comment at the top of a file:
+ 
+ &#96;&#96;&#96;go
+ //go:build linux
+ 
+ package main
+ 
+ // This file only compiles on Linux
+ func platformSpecificSetup() {
+     // Linux-specific code
+ }
+ &#96;&#96;&#96;
+ 
+ Or exclude a platform:
+ 
+ &#96;&#96;&#96;go
+ //go:build !windows
+ 
+ package main
+ 
+ // This file compiles everywhere except Windows
+ &#96;&#96;&#96;
+ 
+ ### Combining Tags
+ 
+ &#96;&#96;&#96;go
+ //go:build linux &amp;&amp; amd64
+ 
+ // Only Linux on x86-64
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ //go:build linux || darwin
+ 
+ // Linux or macOS
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ //go:build !cgo
+ 
+ // Only when CGO is disabled
+ &#96;&#96;&#96;
+ 
+ ### Custom Build Tags
+ 
+ Define your own:
+ 
+ &#96;&#96;&#96;go
+ //go:build premium
+ 
+ package features
+ 
+ func PremiumFeatures() {
+     // Only in premium builds
+ }
+ &#96;&#96;&#96;
+ 
+ Build with:
+ 
+ &#96;&#96;&#96;bash
+ go build -tags premium -o myapp-premium
+ &#96;&#96;&#96;
+ 
+ Without the tag, files marked &#96;//go:build premium&#96; are excluded.
+ 
+ ### Common Use Cases
+ 
+ **Debug vs Production:**
+ 
+ &#96;&#96;&#96;go
+ //go:build debug
+ 
+ package main
+ 
+ func init() {
+     log.SetLevel(log.DebugLevel)
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ //go:build !debug
+ 
+ package main
+ 
+ func init() {
+     log.SetLevel(log.InfoLevel)
+ }
+ &#96;&#96;&#96;
+ 
+ **Feature Flags:**
+ 
+ &#96;&#96;&#96;go
+ //go:build enterprise
+ 
+ package auth
+ 
+ func SSOLogin() { ... }
+ &#96;&#96;&#96;
+ 
+ **Platform-Specific Implementations:**
+ 
+ &#96;&#96;&#96;
+ mypackage/
+ ├── file.go           // shared code
+ ├── file_linux.go     // Linux-specific
+ ├── file_windows.go   // Windows-specific
+ └── file_darwin.go    // macOS-specific
+ &#96;&#96;&#96;
+ 
+ Go automatically selects by filename suffix: &#96;_linux.go&#96;, &#96;_windows.go&#96;, &#96;_darwin.go&#96;, &#96;_amd64.go&#96;, &#96;_arm64.go&#96;.
+ 
+ ## UPX Compression (Controversial)
+ 
+ UPX compresses executables:
+ 
+ &#96;&#96;&#96;bash
+ go build -ldflags="-s -w" -o myapp
+ upx --best myapp
+ &#96;&#96;&#96;
+ 
+ Before UPX: 10MB
+ After UPX: 3MB
+ 
+ Sounds great, but:
+ - Slower startup (decompression)
+ - Some virus scanners flag UPX-packed binaries
+ - Can interfere with debugging
+ - Memory usage increases at runtime
+ 
+ Most Go developers skip UPX. The uncompressed binary is usually small enough.
+ 
+ ## Trimpath for Reproducibility
+ 
+ Remove local paths from the binary:
+ 
+ &#96;&#96;&#96;bash
+ go build -trimpath -o myapp
+ &#96;&#96;&#96;
+ 
+ Without &#96;-trimpath&#96;, stack traces contain your local paths:
+ 
+ &#96;&#96;&#96;
+ /Users/alice/projects/myapp/main.go:42
+ &#96;&#96;&#96;
+ 
+ With &#96;-trimpath&#96;:
+ 
+ &#96;&#96;&#96;
+ myapp/main.go:42
+ &#96;&#96;&#96;
+ 
+ Cleaner error messages and reproducible builds.
+ 
+ ## Comparing to .NET
+ 
+ | Feature | .NET | Go |
+ |---------|------|-----|
+ | Strip debug info | PublishTrimmed | &#96;-ldflags="-s -w"&#96; |
+ | Conditional compilation | &#96;#if DEBUG&#96; | Build tags |
+ | Platform-specific | Runtime checks or #if | File suffixes |
+ | Build-time variables | MSBuild properties | &#96;-X main.var=value&#96; |
+ | IL trimming | PublishTrimmed | N/A (no IL) |
+ 
+ .NET's trimming is more complex because it's trimming IL and dependencies. Go doesn't have this problem—it compiles to native code and includes only what's used.
+ 
+ ## A Complete Production Build
+ 
+ &#96;&#96;&#96;bash
+ #!/bin/bash
+ 
+ VERSION=$(git describe --tags --always --dirty)
+ COMMIT=$(git rev-parse --short HEAD)
+ BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
+ 
+ go build \
+   -trimpath \
+   -ldflags="-s -w \
+     -X main.version=$VERSION \
+     -X main.commit=$COMMIT \
+     -X main.buildTime=$BUILD_TIME" \
+   -o myapp \
+   ./cmd/server
+ &#96;&#96;&#96;
+ 
+ This produces:
+ - Stripped binary (smaller)
+ - No local paths (reproducible)
+ - Version info embedded (debuggable in production)
+ 
+ ## Build Tags in Practice
+ 
+ A common pattern for different build configurations:
+ 
+ &#96;&#96;&#96;
+ cmd/server/
+ ├── main.go
+ ├── config_dev.go      //go:build dev
+ ├── config_prod.go     //go:build !dev
+ &#96;&#96;&#96;
+ 
+ config_dev.go:
+ &#96;&#96;&#96;go
+ //go:build dev
+ 
+ package main
+ 
+ var defaultConfig = Config{
+     LogLevel: "debug",
+     Database: "localhost:5432",
+ }
+ &#96;&#96;&#96;
+ 
+ config_prod.go:
+ &#96;&#96;&#96;go
+ //go:build !dev
+ 
+ package main
+ 
+ var defaultConfig = Config{
+     LogLevel: "info",
+     Database: "",  // must be set via env
+ }
+ &#96;&#96;&#96;
+ 
+ Build:
+ &#96;&#96;&#96;bash
+ go build -tags dev -o myapp-dev   # includes config_dev.go
+ go build -o myapp                  # includes config_prod.go
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's build customisation is simpler than .NET's MSBuild system.
+ 
+ **What Go does well:**
+ - Simple ldflags for common needs
+ - Build tags are straightforward
+ - File suffixes for platform code
+ - Fast rebuilds
+ 
+ **What .NET does better:**
+ - More sophisticated trimming
+ - Rich MSBuild conditionals
+ - Better IDE support for conditional code
+ - Source generators for build-time code
+ 
+ **The verdict:**
+ For most cases, &#96;-ldflags="-s -w"&#96; and maybe a build tag or two is all you need. Go's simplicity means less configuration and fewer surprises.
+ 
+ If you're coming from complex MSBuild configurations, you might miss the flexibility. But you probably won't miss the complexity.
+ 
+ ---
+ 
+ *Next up: Dockerfiles for Go—multi-stage builds, scratch images, and why Go containers are so small.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-docker.md</summary>

**Chunk 1**
Lines added: 327, lines removed: 1

```diff
@@ -1,1 +1,327 @@
- 
+ +++
+ title = "Dockerfile for Go: Simpler Than You'd Think"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "docker", "containers", "csharp"]
+ +++
+ 
+ Go's static binaries make for tiny Docker images. Where a .NET container might be 200MB+, a Go container can be under 20MB. Sometimes under 10MB.
+ 
+ This isn't just about bragging rights. Smaller images mean faster pulls, faster scaling, smaller attack surface, and lower storage costs.
+ 
+ ## The Simplest Dockerfile
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM golang:1.22 AS builder
+ WORKDIR /app
+ COPY go.mod go.sum ./
+ RUN go mod download
+ COPY . .
+ RUN CGO_ENABLED=0 go build -ldflags="-s -w" -o /app/server ./cmd/server
+ 
+ FROM scratch
+ COPY --from=builder /app/server /server
+ ENTRYPOINT ["/server"]
+ &#96;&#96;&#96;
+ 
+ That's it. A multi-stage build producing a minimal image.
+ 
+ ### What's Happening
+ 
+ **Stage 1: Build**
+ - Start from official Go image
+ - Copy and download dependencies first (layer caching)
+ - Copy source and build
+ - &#96;CGO_ENABLED=0&#96; ensures static linking
+ 
+ **Stage 2: Run**
+ - &#96;scratch&#96; is an empty image—literally nothing
+ - Copy just the binary
+ - Run it
+ 
+ Result: an image containing only your binary.
+ 
+ ## Image Size Comparison
+ 
+ &#96;&#96;&#96;bash
+ docker images
+ REPOSITORY          TAG       SIZE
+ myapp-go            latest    12MB
+ myapp-dotnet-aot    latest    45MB
+ myapp-dotnet-scd    latest    210MB
+ &#96;&#96;&#96;
+ 
+ Go with scratch: ~10-15MB
+ .NET AOT: ~40-80MB
+ .NET self-contained: ~200-300MB
+ 
+ ## The scratch vs distroless Decision
+ 
+ ### scratch
+ 
+ Literally empty. No shell, no utilities, no nothing.
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM scratch
+ COPY myapp /myapp
+ ENTRYPOINT ["/myapp"]
+ &#96;&#96;&#96;
+ 
+ Pros:
+ - Smallest possible
+ - Minimal attack surface
+ - Nothing to exploit
+ 
+ Cons:
+ - No shell for debugging (&#96;docker exec&#96; won't help)
+ - No CA certificates (HTTPS fails)
+ - No timezone data
+ 
+ ### distroless
+ 
+ Google's minimal images—just enough to run binaries:
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM gcr.io/distroless/static-debian12
+ COPY myapp /myapp
+ ENTRYPOINT ["/myapp"]
+ &#96;&#96;&#96;
+ 
+ Pros:
+ - Includes CA certificates
+ - Includes timezone data
+ - Still very small (~2MB base)
+ - Some debugging possible
+ 
+ Cons:
+ - Slightly larger than scratch
+ - Still no shell
+ 
+ ### alpine
+ 
+ Minimal Linux with shell:
+ 
+ &#96;&#96;&#96;dockerfile
+ FROM alpine:3.19
+ RUN apk add --no-cache ca-certificates tzdata
+ COPY myapp /myapp
+ ENTRYPOINT ["/myapp"]
+ &#96;&#96;&#96;
+ 
+ Pros:
+ - Has a shell
+ - Easy debugging
+ - Package manager available
+ - ~5MB base
+ 
+ Cons:
+ - Uses musl libc (usually fine for Go)
+ - Larger than scratch/distroless
+ - More attack surface
+ 
+ ## A Production Dockerfile
+ 
+ &#96;&#96;&#96;dockerfile
+ # Build stage
+ FROM golang:1.22-alpine AS builder
+ 
+ WORKDIR /app
+ 
+ # Dependencies first for layer caching
+ COPY go.mod go.sum ./
+ RUN go mod download
+ 
+ # Copy source
+ COPY . .
+ 
+ # Build with optimizations
+ ARG VERSION=dev
+ ARG COMMIT=unknown
+ RUN CGO_ENABLED=0 GOOS=linux go build \
+     -trimpath \
+     -ldflags="-s -w -X main.version=${VERSION} -X main.commit=${COMMIT}" \
+     -o server ./cmd/server
+ 
+ # Runtime stage
+ FROM gcr.io/distroless/static-debian12
+ 
+ # Copy binary
+ COPY --from=builder /app/server /server
+ 
+ # Copy any config files needed
+ COPY --from=builder /app/config.yaml /config.yaml
+ 
+ # Non-root user (distroless provides nonroot user)
+ USER nonroot:nonroot
+ 
+ EXPOSE 8080
+ 
+ ENTRYPOINT ["/server"]
+ &#96;&#96;&#96;
+ 
+ ### Build It
+ 
+ &#96;&#96;&#96;bash
+ docker build \
+   --build-arg VERSION=$(git describe --tags) \
+   --build-arg COMMIT=$(git rev-parse --short HEAD) \
+   -t myapp:latest .
+ &#96;&#96;&#96;
+ 
+ ## Handling HTTPS and Certificates
+ 
+ If your app makes HTTPS calls, you need CA certificates.
+ 
+ **Option 1: distroless (includes them)**
+ &#96;&#96;&#96;dockerfile
+ FROM gcr.io/distroless/static-debian12
+ &#96;&#96;&#96;
+ 
+ **Option 2: Copy from builder**
+ &#96;&#96;&#96;dockerfile
+ FROM scratch
+ COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
+ &#96;&#96;&#96;
+ 
+ **Option 3: alpine base**
+ &#96;&#96;&#96;dockerfile
+ FROM alpine:3.19
+ RUN apk add --no-cache ca-certificates
+ &#96;&#96;&#96;
+ 
+ ## Timezone Data
+ 
+ Go needs timezone data for &#96;time.LoadLocation()&#96;:
+ 
+ **Option 1: distroless (includes it)**
+ 
+ **Option 2: Embed in binary** (Go 1.15+)
+ &#96;&#96;&#96;go
+ import _ "time/tzdata"
+ &#96;&#96;&#96;
+ 
+ Adds ~500KB to binary but works everywhere.
+ 
+ **Option 3: Copy from builder**
+ &#96;&#96;&#96;dockerfile
+ COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo
+ &#96;&#96;&#96;
+ 
+ ## Layer Caching Strategy
+ 
+ Order your Dockerfile for maximum cache hits:
+ 
+ &#96;&#96;&#96;dockerfile
+ # 1. Base image (rarely changes)
+ FROM golang:1.22 AS builder
+ 
+ # 2. Dependencies (change occasionally)
+ COPY go.mod go.sum ./
+ RUN go mod download
+ 
+ # 3. Source code (changes frequently)
+ COPY . .
+ 
+ # 4. Build
+ RUN go build -o /app ./cmd/server
+ &#96;&#96;&#96;
+ 
+ If only your source changes, steps 1-2 are cached.
+ 
+ ## Comparing to .NET Dockerfiles
+ 
+ .NET self-contained:
+ &#96;&#96;&#96;dockerfile
+ FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
+ WORKDIR /src
+ COPY *.csproj ./
+ RUN dotnet restore
+ COPY . .
+ RUN dotnet publish -c Release -o /app --self-contained -r linux-x64
+ 
+ FROM mcr.microsoft.com/dotnet/runtime-deps:8.0
+ COPY --from=build /app .
+ ENTRYPOINT ["./MyApp"]
+ &#96;&#96;&#96;
+ 
+ Result: 200MB+ image
+ 
+ .NET AOT:
+ &#96;&#96;&#96;dockerfile
+ FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
+ WORKDIR /src
+ COPY . .
+ RUN dotnet publish -c Release -r linux-x64 -p:PublishAot=true -o /app
+ 
+ FROM mcr.microsoft.com/dotnet/runtime-deps:8.0
+ COPY --from=build /app .
+ ENTRYPOINT ["./MyApp"]
+ &#96;&#96;&#96;
+ 
+ Result: 50-80MB image (better, but still needs runtime-deps base)
+ 
+ Go:
+ &#96;&#96;&#96;dockerfile
+ FROM golang:1.22 AS build
+ COPY . .
+ RUN CGO_ENABLED=0 go build -o /app
+ 
+ FROM scratch
+ COPY --from=build /app /app
+ ENTRYPOINT ["/app"]
+ &#96;&#96;&#96;
+ 
+ Result: 10-15MB image
+ 
+ ## Docker Compose for Development
+ 
+ &#96;&#96;&#96;yaml
+ version: '3.8'
+ 
+ services:
+   app:
+     build: .
+     ports:
+       - "8080:8080"
+     environment:
+       - DATABASE_URL=postgres://postgres:secret@db:5432/myapp
+     depends_on:
+       - db
+ 
+   db:
+     image: postgres:16-alpine
+     environment:
+       POSTGRES_PASSWORD: secret
+       POSTGRES_DB: myapp
+     volumes:
+       - pgdata:/var/lib/postgresql/data
+ 
+ volumes:
+   pgdata:
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go + Docker is a perfect match.
+ 
+ **What Go does better:**
+ - Static binaries → scratch/distroless
+ - Small images by default
+ - No runtime to include
+ - Fast builds in containers
+ 
+ **What .NET does... differently:**
+ - Runtime-deps base required
+ - Larger images even with AOT
+ - More complex Dockerfiles
+ - But better Windows container support
+ 
+ **The verdict:**
+ If container size and simplicity matter, Go wins decisively. A 10MB image that starts instantly is operationally simpler than a 200MB image, especially at scale.
+ 
+ This is one of Go's genuine strengths. Embrace it.
+ 
+ ---
+ 
+ *Next up: AWS Lambda and Go—serverless without the cold start tax.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-lambda.md</summary>

**Chunk 1**
Lines added: 292, lines removed: 1

```diff
@@ -1,1 +1,292 @@
- 
+ +++
+ title = "AWS Lambda and Go: Cold Starts That Don't Hurt"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "aws", "lambda", "serverless", "csharp"]
+ +++
+ 
+ If you've run .NET on Lambda, you know the cold start pain. 3-5 seconds for a managed runtime. Even Native AOT helps but doesn't eliminate it.
+ 
+ Go on Lambda cold starts in ~100-200ms. Sometimes faster. It's not magic—it's the same static binary advantage, applied to serverless.
+ 
+ ## Go Lambda Basics
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "github.com/aws/aws-lambda-go/lambda"
+ )
+ 
+ type Request struct {
+     Name string &#96;json:"name"&#96;
+ }
+ 
+ type Response struct {
+     Message string &#96;json:"message"&#96;
+ }
+ 
+ func handler(ctx context.Context, req Request) (Response, error) {
+     return Response{
+         Message: "Hello, " + req.Name,
+     }, nil
+ }
+ 
+ func main() {
+     lambda.Start(handler)
+ }
+ &#96;&#96;&#96;
+ 
+ Build and deploy:
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o bootstrap main.go
+ zip function.zip bootstrap
+ aws lambda create-function \
+   --function-name my-function \
+   --runtime provided.al2023 \
+   --handler bootstrap \
+   --zip-file fileb://function.zip \
+   --role arn:aws:iam::123456789:role/lambda-role
+ &#96;&#96;&#96;
+ 
+ The binary must be named &#96;bootstrap&#96; for custom runtimes.
+ 
+ ## ARM64 for Better Performance
+ 
+ AWS Graviton2 processors offer better price-performance:
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bootstrap main.go
+ &#96;&#96;&#96;
+ 
+ Create the function with ARM:
+ 
+ &#96;&#96;&#96;bash
+ aws lambda create-function \
+   --function-name my-function \
+   --runtime provided.al2023 \
+   --architectures arm64 \
+   --handler bootstrap \
+   --zip-file fileb://function.zip \
+   --role arn:aws:iam::123456789:role/lambda-role
+ &#96;&#96;&#96;
+ 
+ ARM64 is typically ~20% cheaper and often faster for Go.
+ 
+ ## Cold Start Comparison
+ 
+ Rough numbers (highly variable, your mileage will vary):
+ 
+ | Runtime | Cold Start | Warm Invocation |
+ |---------|-----------|-----------------|
+ | Go (custom runtime) | 100-200ms | 1-5ms |
+ | .NET 8 Managed | 2-4 seconds | 5-20ms |
+ | .NET 8 Native AOT | 300-800ms | 3-10ms |
+ | Node.js | 200-400ms | 5-15ms |
+ | Python | 200-300ms | 10-30ms |
+ 
+ Go's cold start is competitive with Python and Node, but with the performance of a compiled language.
+ 
+ ## API Gateway Integration
+ 
+ For HTTP APIs:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "encoding/json"
+     "github.com/aws/aws-lambda-go/events"
+     "github.com/aws/aws-lambda-go/lambda"
+ )
+ 
+ func handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
+     name := req.QueryStringParameters["name"]
+     if name == "" {
+         name = "World"
+     }
+     
+     body, _ := json.Marshal(map[string]string{
+         "message": "Hello, " + name,
+     })
+     
+     return events.APIGatewayProxyResponse{
+         StatusCode: 200,
+         Headers:    map[string]string{"Content-Type": "application/json"},
+         Body:       string(body),
+     }, nil
+ }
+ 
+ func main() {
+     lambda.Start(handler)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Using HTTP Frameworks
+ 
+ Want to use your existing HTTP code? Use an adapter:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "net/http"
+     "github.com/aws/aws-lambda-go/lambda"
+     "github.com/awslabs/aws-lambda-go-api-proxy/httpadapter"
+ )
+ 
+ func main() {
+     mux := http.NewServeMux()
+     mux.HandleFunc("/hello", helloHandler)
+     mux.HandleFunc("/users", usersHandler)
+     
+     lambda.Start(httpadapter.New(mux).ProxyWithContext)
+ }
+ &#96;&#96;&#96;
+ 
+ Or with chi:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/awslabs/aws-lambda-go-api-proxy/chiadapter"
+ 
+ r := chi.NewRouter()
+ r.Get("/hello", helloHandler)
+ 
+ lambda.Start(chiadapter.New(r).ProxyWithContext)
+ &#96;&#96;&#96;
+ 
+ Your HTTP handlers work both locally and on Lambda.
+ 
+ ## Keeping Warm
+ 
+ If cold starts still matter, provision concurrency:
+ 
+ &#96;&#96;&#96;bash
+ aws lambda put-provisioned-concurrency-config \
+   --function-name my-function \
+   --qualifier prod \
+   --provisioned-concurrent-executions 5
+ &#96;&#96;&#96;
+ 
+ Keeps 5 instances warm. You pay for them, but no cold starts.
+ 
+ For Go, you rarely need this. 100ms cold starts are acceptable for most use cases.
+ 
+ ## SAM Template
+ 
+ &#96;&#96;&#96;yaml
+ AWSTemplateFormatVersion: '2010-09-09'
+ Transform: AWS::Serverless-2016-10-31
+ 
+ Globals:
+   Function:
+     Timeout: 30
+     MemorySize: 256
+     Runtime: provided.al2023
+     Architectures:
+       - arm64
+ 
+ Resources:
+   MyFunction:
+     Type: AWS::Serverless::Function
+     Properties:
+       CodeUri: ./
+       Handler: bootstrap
+       Events:
+         Api:
+           Type: Api
+           Properties:
+             Path: /hello
+             Method: get
+     Metadata:
+       BuildMethod: go1.x
+ &#96;&#96;&#96;
+ 
+ Build and deploy:
+ 
+ &#96;&#96;&#96;bash
+ sam build
+ sam deploy --guided
+ &#96;&#96;&#96;
+ 
+ ## Comparing to .NET Lambda
+ 
+ **.NET Managed Runtime:**
+ &#96;&#96;&#96;csharp
+ public class Function
+ {
+     public string Handler(string input, ILambdaContext context)
+     {
+         return $"Hello, {input}";
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Deploy as zip with .NET 8 runtime. Cold starts: 2-4 seconds.
+ 
+ **.NET Native AOT:**
+ Better cold starts (~500ms), but:
+ - Limited reflection
+ - Longer build times
+ - Larger deployment packages than Go
+ 
+ **Go Custom Runtime:**
+ - Fastest cold starts
+ - Smallest packages
+ - Full language features
+ - Simple deployment
+ 
+ ## Local Development
+ 
+ Test locally with SAM:
+ 
+ &#96;&#96;&#96;bash
+ sam local invoke MyFunction -e event.json
+ sam local start-api
+ &#96;&#96;&#96;
+ 
+ Or just run your Go code directly—it's a normal program:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     if os.Getenv("AWS_LAMBDA_FUNCTION_NAME") != "" {
+         lambda.Start(handler)
+     } else {
+         // Local development
+         http.HandleFunc("/", httpHandler)
+         http.ListenAndServe(":8080", nil)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go is excellent for Lambda.
+ 
+ **What Go does better:**
+ - Fastest cold starts of compiled languages
+ - Small deployment packages
+ - Simple deployment model
+ - ARM64 support trivial
+ - No runtime version management
+ 
+ **What .NET does better:**
+ - Richer AWS SDK (sometimes)
+ - Better IDE tooling for Lambda
+ - Managed runtime means no bootstrap binary
+ - .NET-specific integrations
+ 
+ **The verdict:**
+ If Lambda cold starts have frustrated you in .NET, Go is the answer. 100ms cold starts mean serverless actually feels instant.
+ 
+ The deployment model is simple: build a binary, zip it, upload. No runtime versions, no layer management, no framework configuration.
+ 
+ For latency-sensitive serverless workloads, Go is hard to beat.
+ 
+ ---
+ 
+ *Next up: Kubernetes and Go—health checks, graceful shutdown, and playing nice with orchestration.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-kubernetes.md</summary>

**Chunk 1**
Lines added: 386, lines removed: 1

```diff
@@ -1,1 +1,386 @@
- 
+ +++
+ title = "Kubernetes and Go: A Natural Fit"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "kubernetes", "containers", "csharp"]
+ +++
+ 
+ Kubernetes is written in Go. The CLI tools are Go. The ecosystem is Go. Running Go services on Kubernetes feels natural—the patterns align.
+ 
+ But there are things you need to get right: health checks, graceful shutdown, resource limits. Let's cover what Kubernetes expects and how Go delivers it.
+ 
+ ## Health Checks: Liveness and Readiness
+ 
+ Kubernetes uses probes to manage your containers:
+ 
+ - **Liveness**: Is the process alive? Restart if not.
+ - **Readiness**: Can it serve traffic? Remove from load balancer if not.
+ - **Startup**: Has it finished starting? (For slow-starting apps)
+ 
+ ### Implementing Health Endpoints
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "net/http"
+     "sync/atomic"
+ )
+ 
+ var ready atomic.Bool
+ 
+ func main() {
+     // Health endpoints
+     http.HandleFunc("/healthz", healthzHandler)   // liveness
+     http.HandleFunc("/readyz", readyzHandler)     // readiness
+     
+     // Your app routes
+     http.HandleFunc("/", appHandler)
+     
+     // Start background initialization
+     go func() {
+         initializeApp()
+         ready.Store(true)
+     }()
+     
+     http.ListenAndServe(":8080", nil)
+ }
+ 
+ func healthzHandler(w http.ResponseWriter, r *http.Request) {
+     // Liveness: can we respond at all?
+     w.WriteHeader(http.StatusOK)
+     w.Write([]byte("ok"))
+ }
+ 
+ func readyzHandler(w http.ResponseWriter, r *http.Request) {
+     // Readiness: are we ready to serve traffic?
+     if ready.Load() {
+         w.WriteHeader(http.StatusOK)
+         w.Write([]byte("ok"))
+     } else {
+         w.WriteHeader(http.StatusServiceUnavailable)
+         w.Write([]byte("not ready"))
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Kubernetes Manifest
+ 
+ &#96;&#96;&#96;yaml
+ apiVersion: apps/v1
+ kind: Deployment
+ metadata:
+   name: myapp
+ spec:
+   replicas: 3
+   selector:
+     matchLabels:
+       app: myapp
+   template:
+     metadata:
+       labels:
+         app: myapp
+     spec:
+       containers:
+       - name: myapp
+         image: myapp:latest
+         ports:
+         - containerPort: 8080
+         livenessProbe:
+           httpGet:
+             path: /healthz
+             port: 8080
+           initialDelaySeconds: 5
+           periodSeconds: 10
+         readinessProbe:
+           httpGet:
+             path: /readyz
+             port: 8080
+           initialDelaySeconds: 5
+           periodSeconds: 5
+         resources:
+           requests:
+             memory: "64Mi"
+             cpu: "100m"
+           limits:
+             memory: "128Mi"
+             cpu: "500m"
+ &#96;&#96;&#96;
+ 
+ ## Graceful Shutdown
+ 
+ When Kubernetes wants to stop your pod, it sends SIGTERM. You have &#96;terminationGracePeriodSeconds&#96; (default 30) to finish in-flight requests before SIGKILL.
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "log"
+     "net/http"
+     "os"
+     "os/signal"
+     "syscall"
+     "time"
+ )
+ 
+ func main() {
+     srv := &amp;http.Server{
+         Addr:    ":8080",
+         Handler: router(),
+     }
+     
+     // Start server in goroutine
+     go func() {
+         log.Printf("Starting server on %s", srv.Addr)
+         if err := srv.ListenAndServe(); err != http.ErrServerClosed {
+             log.Fatalf("Server error: %v", err)
+         }
+     }()
+     
+     // Wait for shutdown signal
+     quit := make(chan os.Signal, 1)
+     signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
+     &lt;-quit
+     
+     log.Println("Shutting down server...")
+     
+     // Give in-flight requests time to complete
+     ctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)
+     defer cancel()
+     
+     if err := srv.Shutdown(ctx); err != nil {
+         log.Fatalf("Server shutdown error: %v", err)
+     }
+     
+     log.Println("Server stopped")
+ }
+ &#96;&#96;&#96;
+ 
+ ### The Shutdown Sequence
+ 
+ 1. Kubernetes sends SIGTERM
+ 2. Kubernetes removes pod from Service endpoints (readiness fails)
+ 3. Your app stops accepting new connections
+ 4. In-flight requests complete (or timeout)
+ 5. If not done in grace period, SIGKILL
+ 
+ ### Coordinating with Readiness
+ 
+ Stop being ready before shutdown completes:
+ 
+ &#96;&#96;&#96;go
+ var (
+     ready    atomic.Bool
+     stopping atomic.Bool
+ )
+ 
+ func readyzHandler(w http.ResponseWriter, r *http.Request) {
+     if ready.Load() &amp;&amp; !stopping.Load() {
+         w.WriteHeader(http.StatusOK)
+     } else {
+         w.WriteHeader(http.StatusServiceUnavailable)
+     }
+ }
+ 
+ func main() {
+     // ... setup ...
+     
+     &lt;-quit
+     stopping.Store(true)  // Stop readiness immediately
+     
+     // Wait a moment for Kubernetes to update endpoints
+     time.Sleep(5 * time.Second)
+     
+     // Then shutdown
+     srv.Shutdown(ctx)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Resource Limits
+ 
+ Go respects container resource limits automatically since Go 1.19:
+ 
+ &#96;&#96;&#96;go
+ import "runtime"
+ 
+ func main() {
+     // GOMAXPROCS is set automatically based on CPU limits
+     log.Printf("GOMAXPROCS: %d", runtime.GOMAXPROCS(0))
+ }
+ &#96;&#96;&#96;
+ 
+ For memory, Go's GC works within limits, but can still OOM. Set appropriate limits:
+ 
+ &#96;&#96;&#96;yaml
+ resources:
+   requests:
+     memory: "64Mi"
+     cpu: "100m"
+   limits:
+     memory: "128Mi"
+     cpu: "500m"
+ &#96;&#96;&#96;
+ 
+ Go apps are typically memory-efficient. Start small, increase based on actual usage.
+ 
+ ## Configuration via ConfigMaps and Secrets
+ 
+ &#96;&#96;&#96;yaml
+ apiVersion: v1
+ kind: ConfigMap
+ metadata:
+   name: myapp-config
+ data:
+   LOG_LEVEL: "info"
+   MAX_CONNECTIONS: "100"
+ ---
+ apiVersion: v1
+ kind: Secret
+ metadata:
+   name: myapp-secrets
+ type: Opaque
+ stringData:
+   DATABASE_URL: "postgres://..."
+ ---
+ apiVersion: apps/v1
+ kind: Deployment
+ spec:
+   template:
+     spec:
+       containers:
+       - name: myapp
+         envFrom:
+         - configMapRef:
+             name: myapp-config
+         - secretRef:
+             name: myapp-secrets
+ &#96;&#96;&#96;
+ 
+ Your Go app reads environment variables:
+ 
+ &#96;&#96;&#96;go
+ logLevel := os.Getenv("LOG_LEVEL")
+ dbURL := os.Getenv("DATABASE_URL")
+ &#96;&#96;&#96;
+ 
+ ## A Complete Example
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "log/slog"
+     "net/http"
+     "os"
+     "os/signal"
+     "sync/atomic"
+     "syscall"
+     "time"
+ )
+ 
+ var ready atomic.Bool
+ 
+ func main() {
+     logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
+     slog.SetDefault(logger)
+     
+     mux := http.NewServeMux()
+     
+     // Health endpoints
+     mux.HandleFunc("GET /healthz", func(w http.ResponseWriter, r *http.Request) {
+         w.WriteHeader(http.StatusOK)
+     })
+     mux.HandleFunc("GET /readyz", func(w http.ResponseWriter, r *http.Request) {
+         if ready.Load() {
+             w.WriteHeader(http.StatusOK)
+         } else {
+             w.WriteHeader(http.StatusServiceUnavailable)
+         }
+     })
+     
+     // App routes
+     mux.HandleFunc("GET /", func(w http.ResponseWriter, r *http.Request) {
+         w.Write([]byte("Hello from Kubernetes!"))
+     })
+     
+     srv := &amp;http.Server{
+         Addr:    ":8080",
+         Handler: mux,
+     }
+     
+     // Start server
+     go func() {
+         slog.Info("starting server", "addr", srv.Addr)
+         if err := srv.ListenAndServe(); err != http.ErrServerClosed {
+             slog.Error("server error", "error", err)
+             os.Exit(1)
+         }
+     }()
+     
+     // Initialization (simulate startup work)
+     time.Sleep(2 * time.Second)
+     ready.Store(true)
+     slog.Info("ready to serve traffic")
+     
+     // Wait for shutdown
+     quit := make(chan os.Signal, 1)
+     signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
+     &lt;-quit
+     
+     slog.Info("shutdown signal received")
+     ready.Store(false)
+     
+     // Grace period for endpoint updates
+     time.Sleep(5 * time.Second)
+     
+     ctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)
+     defer cancel()
+     
+     if err := srv.Shutdown(ctx); err != nil {
+         slog.Error("shutdown error", "error", err)
+     }
+     
+     slog.Info("server stopped")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Comparing to .NET
+ 
+ | Aspect | .NET | Go |
+ |--------|------|-----|
+ | Health checks | &#96;IHealthCheck&#96; interface | HTTP handlers |
+ | Graceful shutdown | &#96;IHostedService&#96; lifecycle | Signal handling |
+ | Resource awareness | Manual GOMAXPROCS | Automatic (Go 1.19+) |
+ | Container size | 200MB+ | 10-15MB |
+ | Startup time | 1-2 seconds | &lt;100ms |
+ 
+ .NET has more framework support for health checks. Go requires manual implementation but it's trivial.
+ 
+ ## The Honest Take
+ 
+ Go and Kubernetes work well together—they're from the same ecosystem.
+ 
+ **What Go does well:**
+ - Fast startup (important for scaling)
+ - Small images (fast pulls)
+ - Low memory usage
+ - Automatic GOMAXPROCS
+ - Native signal handling
+ 
+ **What .NET does better:**
+ - &#96;IHealthCheck&#96; abstraction
+ - Richer hosted service lifecycle
+ - Better DI integration
+ - ASP.NET Core middleware patterns
+ 
+ **The verdict:**
+ For Kubernetes workloads, Go's operational characteristics are excellent. Fast startup means fast scaling. Small images mean fast deployment. Low resource usage means efficient clusters.
+ 
+ The patterns shown here—health endpoints, graceful shutdown, signal handling—are the same patterns you'd use in any language. Go just makes them explicit.
+ 
+ ---
+ 
+ *Next up: observability with OpenTelemetry—metrics, traces, and logs for production Go services.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-observability.md</summary>

**Chunk 1**
Lines added: 389, lines removed: 1

```diff
@@ -1,1 +1,389 @@
- 
+ +++
+ title = "Metrics, Traces, and Logs: The OpenTelemetry Way"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "observability", "opentelemetry", "csharp"]
+ +++
+ 
+ Observability in production means three things: metrics (what's happening), traces (how requests flow), and logs (what went wrong). OpenTelemetry unifies all three.
+ 
+ Go's OpenTelemetry support is mature—the project itself is Go-native. Let's instrument a Go service properly.
+ 
+ ## OpenTelemetry Setup
+ 
+ Add dependencies:
+ 
+ &#96;&#96;&#96;bash
+ go get go.opentelemetry.io/otel
+ go get go.opentelemetry.io/otel/sdk
+ go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp
+ go get go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp
+ go get go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp
+ &#96;&#96;&#96;
+ 
+ Initialize in main:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "log"
+     "time"
+     
+     "go.opentelemetry.io/otel"
+     "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
+     "go.opentelemetry.io/otel/sdk/resource"
+     sdktrace "go.opentelemetry.io/otel/sdk/trace"
+     semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
+ )
+ 
+ func initTracer(ctx context.Context) (*sdktrace.TracerProvider, error) {
+     exporter, err := otlptracehttp.New(ctx)
+     if err != nil {
+         return nil, err
+     }
+     
+     res, err := resource.New(ctx,
+         resource.WithAttributes(
+             semconv.ServiceName("myservice"),
+             semconv.ServiceVersion("1.0.0"),
+         ),
+     )
+     if err != nil {
+         return nil, err
+     }
+     
+     tp := sdktrace.NewTracerProvider(
+         sdktrace.WithBatcher(exporter),
+         sdktrace.WithResource(res),
+     )
+     
+     otel.SetTracerProvider(tp)
+     return tp, nil
+ }
+ 
+ func main() {
+     ctx := context.Background()
+     
+     tp, err := initTracer(ctx)
+     if err != nil {
+         log.Fatal(err)
+     }
+     defer tp.Shutdown(ctx)
+     
+     // Your app...
+ }
+ &#96;&#96;&#96;
+ 
+ ## Automatic HTTP Instrumentation
+ 
+ Wrap your HTTP handler:
+ 
+ &#96;&#96;&#96;go
+ import "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
+ 
+ func main() {
+     handler := http.HandlerFunc(myHandler)
+     wrappedHandler := otelhttp.NewHandler(handler, "my-server")
+     
+     http.ListenAndServe(":8080", wrappedHandler)
+ }
+ &#96;&#96;&#96;
+ 
+ Every request automatically creates a span with:
+ - HTTP method and path
+ - Status code
+ - Request duration
+ - Error information
+ 
+ ## Manual Spans
+ 
+ For business logic:
+ 
+ &#96;&#96;&#96;go
+ import "go.opentelemetry.io/otel"
+ 
+ var tracer = otel.Tracer("myservice")
+ 
+ func processOrder(ctx context.Context, orderID string) error {
+     ctx, span := tracer.Start(ctx, "processOrder")
+     defer span.End()
+     
+     span.SetAttributes(
+         attribute.String("order.id", orderID),
+     )
+     
+     // Process order...
+     if err := validateOrder(ctx, orderID); err != nil {
+         span.RecordError(err)
+         span.SetStatus(codes.Error, err.Error())
+         return err
+     }
+     
+     return nil
+ }
+ 
+ func validateOrder(ctx context.Context, orderID string) error {
+     ctx, span := tracer.Start(ctx, "validateOrder")
+     defer span.End()
+     
+     // Validation logic...
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ The context carries trace information. Child spans automatically link to parents.
+ 
+ ## Metrics
+ 
+ &#96;&#96;&#96;go
+ import (
+     "go.opentelemetry.io/otel/metric"
+     "go.opentelemetry.io/otel"
+ )
+ 
+ var (
+     meter = otel.Meter("myservice")
+     requestCounter metric.Int64Counter
+     requestDuration metric.Float64Histogram
+ )
+ 
+ func init() {
+     var err error
+     requestCounter, err = meter.Int64Counter("http_requests_total",
+         metric.WithDescription("Total HTTP requests"),
+     )
+     if err != nil {
+         log.Fatal(err)
+     }
+     
+     requestDuration, err = meter.Float64Histogram("http_request_duration_seconds",
+         metric.WithDescription("HTTP request duration"),
+     )
+     if err != nil {
+         log.Fatal(err)
+     }
+ }
+ 
+ func handler(w http.ResponseWriter, r *http.Request) {
+     start := time.Now()
+     
+     // Handle request...
+     
+     requestCounter.Add(r.Context(), 1,
+         metric.WithAttributes(
+             attribute.String("method", r.Method),
+             attribute.String("path", r.URL.Path),
+         ),
+     )
+     
+     requestDuration.Record(r.Context(), time.Since(start).Seconds(),
+         metric.WithAttributes(
+             attribute.String("method", r.Method),
+         ),
+     )
+ }
+ &#96;&#96;&#96;
+ 
+ ## Structured Logging with Trace Context
+ 
+ Connect logs to traces:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "log/slog"
+     "go.opentelemetry.io/otel/trace"
+ )
+ 
+ func handler(w http.ResponseWriter, r *http.Request) {
+     ctx := r.Context()
+     span := trace.SpanFromContext(ctx)
+     
+     logger := slog.Default().With(
+         "trace_id", span.SpanContext().TraceID().String(),
+         "span_id", span.SpanContext().SpanID().String(),
+     )
+     
+     logger.Info("processing request",
+         "method", r.Method,
+         "path", r.URL.Path,
+     )
+ }
+ &#96;&#96;&#96;
+ 
+ Now logs correlate with traces.
+ 
+ ## Database Instrumentation
+ 
+ For &#96;database/sql&#96;:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "github.com/XSAM/otelsql"
+     semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
+ )
+ 
+ func initDB() (*sql.DB, error) {
+     db, err := otelsql.Open("postgres", connString,
+         otelsql.WithAttributes(
+             semconv.DBSystemPostgreSQL,
+         ),
+     )
+     if err != nil {
+         return nil, err
+     }
+     
+     otelsql.RegisterDBStatsMetrics(db,
+         otelsql.WithAttributes(semconv.DBSystemPostgreSQL),
+     )
+     
+     return db, nil
+ }
+ &#96;&#96;&#96;
+ 
+ ## Complete Example
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import (
+     "context"
+     "log/slog"
+     "net/http"
+     "os"
+     "time"
+     
+     "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
+     "go.opentelemetry.io/otel"
+     "go.opentelemetry.io/otel/attribute"
+     "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
+     "go.opentelemetry.io/otel/sdk/resource"
+     sdktrace "go.opentelemetry.io/otel/sdk/trace"
+     semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
+     "go.opentelemetry.io/otel/trace"
+ )
+ 
+ var tracer = otel.Tracer("myservice")
+ 
+ func main() {
+     ctx := context.Background()
+     
+     // Setup tracing
+     tp, err := initTracer(ctx)
+     if err != nil {
+         slog.Error("failed to init tracer", "error", err)
+         os.Exit(1)
+     }
+     defer tp.Shutdown(ctx)
+     
+     // Routes
+     mux := http.NewServeMux()
+     mux.HandleFunc("GET /users/{id}", getUserHandler)
+     
+     // Wrap with OTel
+     handler := otelhttp.NewHandler(mux, "myservice")
+     
+     slog.Info("starting server", "addr", ":8080")
+     http.ListenAndServe(":8080", handler)
+ }
+ 
+ func getUserHandler(w http.ResponseWriter, r *http.Request) {
+     ctx := r.Context()
+     span := trace.SpanFromContext(ctx)
+     
+     userID := r.PathValue("id")
+     span.SetAttributes(attribute.String("user.id", userID))
+     
+     logger := slog.Default().With(
+         "trace_id", span.SpanContext().TraceID().String(),
+         "user_id", userID,
+     )
+     
+     user, err := fetchUser(ctx, userID)
+     if err != nil {
+         span.RecordError(err)
+         logger.Error("failed to fetch user", "error", err)
+         http.Error(w, "user not found", http.StatusNotFound)
+         return
+     }
+     
+     logger.Info("user fetched successfully")
+     json.NewEncoder(w).Encode(user)
+ }
+ 
+ func fetchUser(ctx context.Context, id string) (*User, error) {
+     ctx, span := tracer.Start(ctx, "fetchUser")
+     defer span.End()
+     
+     // Simulated database call
+     time.Sleep(10 * time.Millisecond)
+     
+     return &amp;User{ID: id, Name: "Alice"}, nil
+ }
+ &#96;&#96;&#96;
+ 
+ ## Comparing to .NET
+ 
+ | Aspect | .NET | Go |
+ |--------|------|-----|
+ | OTel SDK | Mature | Mature (Go-native) |
+ | Auto-instrumentation | Yes | Yes (via contrib) |
+ | ASP.NET integration | Built-in | Manual wrapping |
+ | DI integration | Built-in | Manual |
+ | Logging integration | ILogger + OTel | slog + manual |
+ 
+ .NET's integration is more automatic. Go requires more explicit setup but gives more control.
+ 
+ ## Exporters
+ 
+ Send to your observability backend:
+ 
+ **OTLP (Jaeger, Tempo, etc.):**
+ &#96;&#96;&#96;go
+ exporter, _ := otlptracehttp.New(ctx,
+     otlptracehttp.WithEndpoint("tempo:4318"),
+     otlptracehttp.WithInsecure(),
+ )
+ &#96;&#96;&#96;
+ 
+ **Prometheus (metrics):**
+ &#96;&#96;&#96;go
+ import "go.opentelemetry.io/otel/exporters/prometheus"
+ 
+ exporter, _ := prometheus.New()
+ http.Handle("/metrics", promhttp.Handler())
+ &#96;&#96;&#96;
+ 
+ **stdout (debugging):**
+ &#96;&#96;&#96;go
+ import "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
+ 
+ exporter, _ := stdouttrace.New(stdouttrace.WithPrettyPrint())
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's OpenTelemetry support is excellent—the project is Go-native.
+ 
+ **What Go does well:**
+ - OTel is Go-native
+ - Explicit instrumentation is clear
+ - Good contrib library coverage
+ - Low overhead
+ 
+ **What .NET does better:**
+ - More automatic instrumentation
+ - Better DI integration
+ - Richer ASP.NET Core support
+ - Activity API is mature
+ 
+ **The verdict:**
+ OpenTelemetry in Go requires more explicit setup than .NET's automatic instrumentation. But once configured, it works well.
+ 
+ The key patterns—wrap HTTP handlers, propagate context, create spans for significant operations—are the same in any language. Go just makes you write them out.
+ 
+ ---
+ 
+ *Next up: health checks and readiness probes—patterns that work in container orchestrators.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-health-checks.md</summary>

**Chunk 1**
Lines added: 323, lines removed: 1

```diff
@@ -1,1 +1,323 @@
- 
+ +++
+ title = "Health Checks and Readiness Probes"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "health-checks", "kubernetes", "csharp"]
+ +++
+ 
+ We touched on health checks in the Kubernetes post. Let's go deeper—proper health checks that actually tell orchestrators useful information.
+ 
+ ## The Three Probes
+ 
+ Kubernetes (and similar orchestrators) use three types of probes:
+ 
+ | Probe | Question | Failure Action |
+ |-------|----------|----------------|
+ | **Liveness** | Is the process alive? | Restart container |
+ | **Readiness** | Can it handle traffic? | Remove from load balancer |
+ | **Startup** | Has it finished starting? | Keep waiting |
+ 
+ Getting these right matters for reliability.
+ 
+ ## Liveness: Am I Alive?
+ 
+ Liveness should answer: "Is this process fundamentally broken?"
+ 
+ &#96;&#96;&#96;go
+ func livenessHandler(w http.ResponseWriter, r *http.Request) {
+     w.WriteHeader(http.StatusOK)
+     w.Write([]byte("ok"))
+ }
+ &#96;&#96;&#96;
+ 
+ That's it. If your process can respond, it's alive.
+ 
+ **Don't put in liveness:**
+ - Database connectivity checks
+ - External service checks
+ - Anything that might fail temporarily
+ 
+ Why? If your database is down and liveness fails, Kubernetes restarts your pod. But restarting won't fix the database. Now you're restart-looping instead of gracefully handling the outage.
+ 
+ Liveness = "Is my process fundamentally broken, like stuck in a deadlock?"
+ 
+ ## Readiness: Can I Serve Traffic?
+ 
+ Readiness should answer: "Should I receive requests right now?"
+ 
+ &#96;&#96;&#96;go
+ type HealthChecker struct {
+     db    *sql.DB
+     cache *redis.Client
+     ready atomic.Bool
+ }
+ 
+ func (h *HealthChecker) ReadinessHandler(w http.ResponseWriter, r *http.Request) {
+     if !h.ready.Load() {
+         http.Error(w, "not ready", http.StatusServiceUnavailable)
+         return
+     }
+     
+     // Check critical dependencies
+     ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
+     defer cancel()
+     
+     if err := h.db.PingContext(ctx); err != nil {
+         http.Error(w, "database unavailable", http.StatusServiceUnavailable)
+         return
+     }
+     
+     if err := h.cache.Ping(ctx).Err(); err != nil {
+         http.Error(w, "cache unavailable", http.StatusServiceUnavailable)
+         return
+     }
+     
+     w.WriteHeader(http.StatusOK)
+     w.Write([]byte("ok"))
+ }
+ &#96;&#96;&#96;
+ 
+ If readiness fails, Kubernetes removes the pod from the Service endpoints. Traffic goes elsewhere. The pod isn't restarted—it just doesn't receive requests until it's ready again.
+ 
+ ## Startup: Am I Done Initialising?
+ 
+ For apps with slow startup (loading ML models, warming caches, running migrations):
+ 
+ &#96;&#96;&#96;go
+ type App struct {
+     started atomic.Bool
+ }
+ 
+ func (a *App) StartupHandler(w http.ResponseWriter, r *http.Request) {
+     if a.started.Load() {
+         w.WriteHeader(http.StatusOK)
+         return
+     }
+     http.Error(w, "starting", http.StatusServiceUnavailable)
+ }
+ 
+ func (a *App) Initialize() {
+     // Slow startup work
+     loadMLModel()
+     warmCache()
+     runMigrations()
+     
+     a.started.Store(true)
+ }
+ &#96;&#96;&#96;
+ 
+ Kubernetes waits for startup probe to pass before checking liveness/readiness. Prevents premature restarts during slow initialization.
+ 
+ ## Detailed Health Response
+ 
+ For debugging, return details:
+ 
+ &#96;&#96;&#96;go
+ type HealthStatus struct {
+     Status     string            &#96;json:"status"&#96;
+     Checks     map[string]Check  &#96;json:"checks"&#96;
+     Version    string            &#96;json:"version,omitempty"&#96;
+     Uptime     string            &#96;json:"uptime,omitempty"&#96;
+ }
+ 
+ type Check struct {
+     Status  string &#96;json:"status"&#96;
+     Message string &#96;json:"message,omitempty"&#96;
+ }
+ 
+ func (h *HealthChecker) DetailedHealthHandler(w http.ResponseWriter, r *http.Request) {
+     status := HealthStatus{
+         Status:  "healthy",
+         Checks:  make(map[string]Check),
+         Version: version,
+         Uptime:  time.Since(startTime).String(),
+     }
+     
+     // Database check
+     ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
+     defer cancel()
+     
+     if err := h.db.PingContext(ctx); err != nil {
+         status.Checks["database"] = Check{Status: "unhealthy", Message: err.Error()}
+         status.Status = "unhealthy"
+     } else {
+         status.Checks["database"] = Check{Status: "healthy"}
+     }
+     
+     // Cache check
+     if err := h.cache.Ping(ctx).Err(); err != nil {
+         status.Checks["cache"] = Check{Status: "unhealthy", Message: err.Error()}
+         status.Status = "unhealthy"
+     } else {
+         status.Checks["cache"] = Check{Status: "healthy"}
+     }
+     
+     w.Header().Set("Content-Type", "application/json")
+     if status.Status == "healthy" {
+         w.WriteHeader(http.StatusOK)
+     } else {
+         w.WriteHeader(http.StatusServiceUnavailable)
+     }
+     json.NewEncoder(w).Encode(status)
+ }
+ &#96;&#96;&#96;
+ 
+ Response:
+ &#96;&#96;&#96;json
+ {
+   "status": "healthy",
+   "checks": {
+     "database": {"status": "healthy"},
+     "cache": {"status": "healthy"}
+   },
+   "version": "1.2.3",
+   "uptime": "4h32m15s"
+ }
+ &#96;&#96;&#96;
+ 
+ ## Graceful Degradation
+ 
+ Sometimes you can serve traffic even if a dependency is down:
+ 
+ &#96;&#96;&#96;go
+ func (h *HealthChecker) ReadinessHandler(w http.ResponseWriter, r *http.Request) {
+     ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
+     defer cancel()
+     
+     // Database is critical
+     if err := h.db.PingContext(ctx); err != nil {
+         http.Error(w, "database unavailable", http.StatusServiceUnavailable)
+         return
+     }
+     
+     // Cache is nice-to-have, log but don't fail readiness
+     if err := h.cache.Ping(ctx).Err(); err != nil {
+         slog.Warn("cache unavailable", "error", err)
+         // Don't fail readiness—we can operate without cache
+     }
+     
+     w.WriteHeader(http.StatusOK)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Comparing to .NET
+ 
+ .NET's health check system:
+ 
+ &#96;&#96;&#96;csharp
+ builder.Services.AddHealthChecks()
+     .AddDbContextCheck&lt;AppDbContext&gt;()
+     .AddRedis(redisConnectionString)
+     .AddCheck("custom", () =&gt; HealthCheckResult.Healthy());
+ 
+ app.MapHealthChecks("/healthz");
+ app.MapHealthChecks("/readyz", new HealthCheckOptions {
+     Predicate = check =&gt; check.Tags.Contains("ready")
+ });
+ &#96;&#96;&#96;
+ 
+ | Aspect | .NET | Go |
+ |--------|------|-----|
+ | Built-in framework | Yes (&#96;IHealthCheck&#96;) | No |
+ | Dependency injection | Automatic | Manual |
+ | Pre-built checks | Many (EF, Redis, etc.) | Few libraries |
+ | Configuration | Options pattern | Manual |
+ | UI available | Yes (HealthChecksUI) | No |
+ 
+ .NET's health check system is more sophisticated. Go requires manual implementation.
+ 
+ ## Health Check Libraries
+ 
+ Some Go libraries help:
+ 
+ **alexliesenfeld/health:**
+ &#96;&#96;&#96;go
+ checker := health.NewChecker(
+     health.WithCheck(health.Check{
+         Name:    "database",
+         Timeout: 2 * time.Second,
+         Check:   db.PingContext,
+     }),
+ )
+ 
+ http.Handle("/healthz", health.NewHandler(checker))
+ &#96;&#96;&#96;
+ 
+ **hellofresh/health-go:**
+ &#96;&#96;&#96;go
+ h, _ := health.New(health.WithChecks(
+     health.Config{
+         Name:  "database",
+         Check: func(ctx context.Context) error { return db.PingContext(ctx) },
+     },
+ ))
+ 
+ http.Handle("/healthz", h.Handler())
+ &#96;&#96;&#96;
+ 
+ But honestly, health checks are simple enough that most Go developers write them by hand.
+ 
+ ## Best Practices
+ 
+ 1. **Keep liveness simple**—don't check dependencies
+ 2. **Make readiness reflect reality**—check what matters for serving traffic
+ 3. **Use timeouts**—don't let health checks hang forever
+ 4. **Return quickly**—health checks shouldn't be expensive
+ 5. **Log failures**—debugging health issues needs information
+ 6. **Test health checks**—they're code, they can have bugs
+ 
+ ## Kubernetes Configuration
+ 
+ &#96;&#96;&#96;yaml
+ livenessProbe:
+   httpGet:
+     path: /healthz
+     port: 8080
+   initialDelaySeconds: 10
+   periodSeconds: 15
+   timeoutSeconds: 5
+   failureThreshold: 3
+ 
+ readinessProbe:
+   httpGet:
+     path: /readyz
+     port: 8080
+   initialDelaySeconds: 5
+   periodSeconds: 5
+   timeoutSeconds: 3
+   failureThreshold: 2
+ 
+ startupProbe:
+   httpGet:
+     path: /startupz
+     port: 8080
+   initialDelaySeconds: 0
+   periodSeconds: 5
+   timeoutSeconds: 3
+   failureThreshold: 30  # 30 * 5s = 2.5 minutes max startup
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Health checks aren't glamorous, but they're essential for production reliability.
+ 
+ **What Go does well:**
+ - Simple to implement
+ - Full control over logic
+ - Fast checks (no framework overhead)
+ 
+ **What .NET does better:**
+ - Built-in framework
+ - Pre-built checks for common dependencies
+ - UI for monitoring
+ - Better integration with DI
+ 
+ **The verdict:**
+ Go makes you write health checks yourself. That's fine—they're not complicated. The patterns are the same in any language: liveness for "am I stuck?", readiness for "can I serve traffic?".
+ 
+ Get these right and your services will be resilient. Get them wrong and you'll have restart loops and cascading failures.
+ 
+ ---
+ 
+ *Next up: GitHub Actions for Go—CI/CD with testing, linting, and releasing.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-github-actions.md</summary>

**Chunk 1**
Lines added: 403, lines removed: 1

```diff
@@ -1,1 +1,403 @@
- 
+ +++
+ title = "GitHub Actions for Go Projects"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "ci-cd", "github-actions", "csharp"]
+ +++
+ 
+ CI/CD for Go projects is refreshingly simple. Fast builds, built-in testing, cross-compilation—everything you need is in the standard toolchain.
+ 
+ Let's set up a proper GitHub Actions workflow.
+ 
+ ## Basic Workflow
+ 
+ &#96;.github/workflows/ci.yml&#96;:
+ 
+ &#96;&#96;&#96;yaml
+ name: CI
+ 
+ on:
+   push:
+     branches: [main]
+   pull_request:
+     branches: [main]
+ 
+ jobs:
+   test:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       
+       - name: Set up Go
+         uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       
+       - name: Download dependencies
+         run: go mod download
+       
+       - name: Test
+         run: go test -v ./...
+ &#96;&#96;&#96;
+ 
+ That's a working CI pipeline. Test on every push and PR.
+ 
+ ## Adding Linting
+ 
+ &#96;&#96;&#96;yaml
+ jobs:
+   lint:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       
+       - name: golangci-lint
+         uses: golangci/golangci-lint-action@v4
+         with:
+           version: latest
+ &#96;&#96;&#96;
+ 
+ The golangci-lint action handles caching and configuration.
+ 
+ ## Full CI Workflow
+ 
+ &#96;&#96;&#96;yaml
+ name: CI
+ 
+ on:
+   push:
+     branches: [main]
+   pull_request:
+     branches: [main]
+ 
+ jobs:
+   lint:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - uses: golangci/golangci-lint-action@v4
+         with:
+           version: latest
+ 
+   test:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - run: go test -v -race -coverprofile=coverage.out ./...
+       - name: Upload coverage
+         uses: codecov/codecov-action@v4
+         with:
+           files: coverage.out
+ 
+   build:
+     runs-on: ubuntu-latest
+     needs: [lint, test]
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - run: go build -v ./...
+ &#96;&#96;&#96;
+ 
+ Jobs run in parallel where possible. Build only runs after lint and test pass.
+ 
+ ## Cross-Platform Testing
+ 
+ Test on multiple OSes:
+ 
+ &#96;&#96;&#96;yaml
+ test:
+   strategy:
+     matrix:
+       os: [ubuntu-latest, macos-latest, windows-latest]
+       go: ['1.21', '1.22']
+   runs-on: ${{ matrix.os }}
+   steps:
+     - uses: actions/checkout@v4
+     - uses: actions/setup-go@v5
+       with:
+         go-version: ${{ matrix.go }}
+     - run: go test -v ./...
+ &#96;&#96;&#96;
+ 
+ ## Releasing with GoReleaser
+ 
+ GoReleaser automates release builds. Create &#96;.goreleaser.yaml&#96;:
+ 
+ &#96;&#96;&#96;yaml
+ version: 1
+ 
+ builds:
+   - env:
+       - CGO_ENABLED=0
+     goos:
+       - linux
+       - darwin
+       - windows
+     goarch:
+       - amd64
+       - arm64
+     ldflags:
+       - -s -w
+       - -X main.version={{.Version}}
+       - -X main.commit={{.Commit}}
+       - -X main.date={{.Date}}
+ 
+ archives:
+   - format: tar.gz
+     name_template: "{{ .ProjectName }}_{{ .Os }}_{{ .Arch }}"
+     format_overrides:
+       - goos: windows
+         format: zip
+ 
+ checksum:
+   name_template: 'checksums.txt'
+ 
+ changelog:
+   sort: asc
+   filters:
+     exclude:
+       - '^docs:'
+       - '^test:'
+ &#96;&#96;&#96;
+ 
+ Release workflow:
+ 
+ &#96;&#96;&#96;yaml
+ name: Release
+ 
+ on:
+   push:
+     tags:
+       - 'v*'
+ 
+ permissions:
+   contents: write
+ 
+ jobs:
+   release:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+         with:
+           fetch-depth: 0
+       
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       
+       - name: Run GoReleaser
+         uses: goreleaser/goreleaser-action@v5
+         with:
+           version: latest
+           args: release --clean
+         env:
+           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+ &#96;&#96;&#96;
+ 
+ Tag a release:
+ &#96;&#96;&#96;bash
+ git tag v1.0.0
+ git push origin v1.0.0
+ &#96;&#96;&#96;
+ 
+ GoReleaser builds binaries for all platforms, creates a GitHub release, and uploads artifacts.
+ 
+ ## Docker Image Publishing
+ 
+ &#96;&#96;&#96;yaml
+ name: Docker
+ 
+ on:
+   push:
+     tags:
+       - 'v*'
+ 
+ jobs:
+   docker:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       
+       - name: Set up Docker Buildx
+         uses: docker/setup-buildx-action@v3
+       
+       - name: Login to GitHub Container Registry
+         uses: docker/login-action@v3
+         with:
+           registry: ghcr.io
+           username: ${{ github.actor }}
+           password: ${{ secrets.GITHUB_TOKEN }}
+       
+       - name: Build and push
+         uses: docker/build-push-action@v5
+         with:
+           push: true
+           platforms: linux/amd64,linux/arm64
+           tags: |
+             ghcr.io/${{ github.repository }}:${{ github.ref_name }}
+             ghcr.io/${{ github.repository }}:latest
+           cache-from: type=gha
+           cache-to: type=gha,mode=max
+ &#96;&#96;&#96;
+ 
+ Multi-arch Docker images published to GitHub Container Registry.
+ 
+ ## Caching Dependencies
+ 
+ Go module caching is automatic with &#96;setup-go@v5&#96;:
+ 
+ &#96;&#96;&#96;yaml
+ - uses: actions/setup-go@v5
+   with:
+     go-version: '1.22'
+     cache: true  # enabled by default
+ &#96;&#96;&#96;
+ 
+ For more control:
+ 
+ &#96;&#96;&#96;yaml
+ - uses: actions/cache@v4
+   with:
+     path: |
+       ~/.cache/go-build
+       ~/go/pkg/mod
+     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+     restore-keys: |
+       ${{ runner.os }}-go-
+ &#96;&#96;&#96;
+ 
+ ## Comparing to .NET
+ 
+ | Aspect | .NET | Go |
+ |--------|------|-----|
+ | Build time | Moderate | Fast |
+ | Test runner | dotnet test | go test |
+ | Linting | dotnet format + analyzers | golangci-lint |
+ | Release tooling | Manual or custom | GoReleaser |
+ | Cross-compilation | Complex | Trivial |
+ | Docker build | Multi-stage | Multi-stage |
+ 
+ Go's faster builds mean faster CI. Cross-compilation means simpler release matrices.
+ 
+ ## Complete Workflow
+ 
+ Here's everything together:
+ 
+ &#96;&#96;&#96;yaml
+ name: CI/CD
+ 
+ on:
+   push:
+     branches: [main]
+     tags: ['v*']
+   pull_request:
+     branches: [main]
+ 
+ jobs:
+   lint:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - uses: golangci/golangci-lint-action@v4
+ 
+   test:
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - run: go test -v -race -coverprofile=coverage.out ./...
+       - uses: codecov/codecov-action@v4
+         with:
+           files: coverage.out
+ 
+   build:
+     runs-on: ubuntu-latest
+     needs: [lint, test]
+     steps:
+       - uses: actions/checkout@v4
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - run: go build -v ./cmd/...
+ 
+   release:
+     if: startsWith(github.ref, 'refs/tags/')
+     needs: [build]
+     runs-on: ubuntu-latest
+     permissions:
+       contents: write
+     steps:
+       - uses: actions/checkout@v4
+         with:
+           fetch-depth: 0
+       - uses: actions/setup-go@v5
+         with:
+           go-version: '1.22'
+       - uses: goreleaser/goreleaser-action@v5
+         with:
+           version: latest
+           args: release --clean
+         env:
+           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+ 
+   docker:
+     if: startsWith(github.ref, 'refs/tags/')
+     needs: [build]
+     runs-on: ubuntu-latest
+     steps:
+       - uses: actions/checkout@v4
+       - uses: docker/setup-buildx-action@v3
+       - uses: docker/login-action@v3
+         with:
+           registry: ghcr.io
+           username: ${{ github.actor }}
+           password: ${{ secrets.GITHUB_TOKEN }}
+       - uses: docker/build-push-action@v5
+         with:
+           push: true
+           platforms: linux/amd64,linux/arm64
+           tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go CI/CD is simple and fast.
+ 
+ **What Go does well:**
+ - Fast builds = fast feedback
+ - Built-in testing and coverage
+ - Cross-compilation is trivial
+ - GoReleaser is excellent
+ 
+ **What .NET does better:**
+ - Richer test output
+ - Better IDE integration
+ - More mature release tooling
+ - NuGet publishing is simpler
+ 
+ **The verdict:**
+ Setting up CI for Go is straightforward. The standard toolchain does most of what you need. GoReleaser handles releases elegantly.
+ 
+ If you're used to complex MSBuild configurations and NuGet publishing workflows, Go's simplicity is refreshing.
+ 
+ ---
+ 
+ *Next up: versioning your modules—semantic versioning, tags, and avoiding dependency hell.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-versioning.md</summary>

**Chunk 1**
Lines added: 289, lines removed: 1

```diff
@@ -1,1 +1,289 @@
- 
+ +++
+ title = "Versioning Your Modules"
+ date = "2025-01-05"
+ draft = false
+ tags = ["go", "dotnet", "versioning", "modules", "csharp"]
+ +++
+ 
+ Versioning in Go is simple in concept—semantic versioning with git tags—but has quirks that'll catch you if you're coming from NuGet's more flexible model.
+ 
+ Let's cover how to version your modules properly.
+ 
+ ## Basic Versioning
+ 
+ Go modules use semantic versioning: &#96;vMAJOR.MINOR.PATCH&#96;
+ 
+ &#96;&#96;&#96;
+ v1.0.0  - initial stable release
+ v1.1.0  - new features, backward compatible
+ v1.1.1  - bug fixes
+ v2.0.0  - breaking changes
+ &#96;&#96;&#96;
+ 
+ Version with git tags:
+ 
+ &#96;&#96;&#96;bash
+ git tag v1.0.0
+ git push origin v1.0.0
+ &#96;&#96;&#96;
+ 
+ That's it. No version numbers in code, no configuration files to update.
+ 
+ ## The Module Path and Major Versions
+ 
+ Here's Go's unique aspect: **major versions v2+ change the module path**.
+ 
+ &#96;&#96;&#96;go
+ // v1.x
+ module github.com/myname/mylib
+ 
+ // v2.x
+ module github.com/myname/mylib/v2
+ 
+ // v3.x
+ module github.com/myname/mylib/v3
+ &#96;&#96;&#96;
+ 
+ The import path changes too:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/myname/mylib"    // v1.x
+ import "github.com/myname/mylib/v2" // v2.x
+ &#96;&#96;&#96;
+ 
+ Why? So you can use both versions simultaneously:
+ 
+ &#96;&#96;&#96;go
+ import (
+     v1 "github.com/myname/mylib"
+     v2 "github.com/myname/mylib/v2"
+ )
+ &#96;&#96;&#96;
+ 
+ Different modules, different import paths, no conflict.
+ 
+ ## Creating v2
+ 
+ When you make breaking changes:
+ 
+ **Option 1: Major branch**
+ 
+ &#96;&#96;&#96;bash
+ git checkout -b v2
+ # Update go.mod
+ sed -i 's|module github.com/myname/mylib|module github.com/myname/mylib/v2|' go.mod
+ # Update internal imports
+ # Commit and tag
+ git tag v2.0.0
+ git push origin v2 v2.0.0
+ &#96;&#96;&#96;
+ 
+ **Option 2: Subdirectory**
+ 
+ &#96;&#96;&#96;
+ mylib/
+ ├── go.mod           # module github.com/myname/mylib (v1.x)
+ ├── v2/
+ │   ├── go.mod       # module github.com/myname/mylib/v2
+ │   └── ...
+ &#96;&#96;&#96;
+ 
+ Option 1 is more common for libraries. Option 2 works for monorepos.
+ 
+ ## Pre-release Versions
+ 
+ Use semver pre-release suffixes:
+ 
+ &#96;&#96;&#96;
+ v1.0.0-alpha.1
+ v1.0.0-beta.2
+ v1.0.0-rc.1
+ v1.0.0
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;bash
+ git tag v1.0.0-beta.1
+ git push origin v1.0.0-beta.1
+ &#96;&#96;&#96;
+ 
+ Pre-release versions aren't selected by default—users must request them explicitly:
+ 
+ &#96;&#96;&#96;bash
+ go get github.com/myname/mylib@v1.0.0-beta.1
+ &#96;&#96;&#96;
+ 
+ ## v0.x: The Wild West
+ 
+ Versions before v1.0.0 are considered unstable. Go allows breaking changes in minor versions:
+ 
+ &#96;&#96;&#96;
+ v0.1.0 -&gt; v0.2.0  # breaking changes allowed
+ v0.2.0 -&gt; v0.2.1  # should be backward compatible
+ &#96;&#96;&#96;
+ 
+ Stay in v0.x until your API is stable. Once you tag v1.0.0, you're making a stability commitment.
+ 
+ ## Minimum Version Selection
+ 
+ Go's dependency resolution differs from NuGet:
+ 
+ **NuGet**: Gets the *latest* version that satisfies all constraints
+ 
+ **Go**: Gets the *minimum* version that satisfies all constraints (Minimum Version Selection)
+ 
+ If you require &#96;v1.2.0&#96; and a dependency requires &#96;v1.1.0&#96;, Go uses &#96;v1.2.0&#96;—the minimum that satisfies both.
+ 
+ This makes builds reproducible. The same &#96;go.mod&#96; and &#96;go.sum&#96; always produce the same dependencies.
+ 
+ ## Updating Dependencies
+ 
+ &#96;&#96;&#96;bash
+ # Update a specific dependency
+ go get github.com/some/dep@v1.2.3
+ 
+ # Update to latest minor/patch
+ go get -u github.com/some/dep
+ 
+ # Update all dependencies
+ go get -u ./...
+ 
+ # Update to latest including major versions
+ go get github.com/some/dep@latest
+ &#96;&#96;&#96;
+ 
+ After updating:
+ 
+ &#96;&#96;&#96;bash
+ go mod tidy  # clean up go.mod and go.sum
+ &#96;&#96;&#96;
+ 
+ ## Comparing to NuGet
+ 
+ | Aspect | NuGet | Go Modules |
+ |--------|-------|------------|
+ | Version source | .nuspec/.csproj | Git tags |
+ | Version ranges | Yes (&#96;[1.0, 2.0)&#96;) | No (exact versions) |
+ | Resolution | Latest satisfying | Minimum satisfying |
+ | Major version path | Same package ID | Different module path |
+ | Lock file | packages.lock.json | go.sum (hashes only) |
+ | Pre-release | &#96;-alpha&#96;, &#96;-beta&#96; | Same |
+ | Central registry | nuget.org | No central registry |
+ 
+ ## Best Practices
+ 
+ ### 1. Don't Tag Until Stable
+ 
+ Stay on v0.x until you're confident in your API:
+ 
+ &#96;&#96;&#96;go
+ module github.com/myname/mylib
+ 
+ go 1.22
+ &#96;&#96;&#96;
+ 
+ Tag &#96;v0.1.0&#96;, &#96;v0.2.0&#96;, etc. Breaking changes are expected.
+ 
+ ### 2. Use Meaningful Tags
+ 
+ &#96;&#96;&#96;bash
+ # Good
+ git tag v1.2.3
+ 
+ # Bad - no 'v' prefix
+ git tag 1.2.3
+ &#96;&#96;&#96;
+ 
+ Go requires the &#96;v&#96; prefix.
+ 
+ ### 3. Document Breaking Changes
+ 
+ In your CHANGELOG:
+ 
+ &#96;&#96;&#96;markdown
+ ## v2.0.0 - 2025-01-05
+ 
+ ### Breaking Changes
+ - Removed deprecated &#96;OldFunction&#96;
+ - Changed &#96;Config&#96; struct fields
+ - Renamed &#96;Process&#96; to &#96;Execute&#96;
+ 
+ ### Migration Guide
+ See MIGRATION.md for upgrade instructions.
+ &#96;&#96;&#96;
+ 
+ ### 4. Use Retract for Broken Versions
+ 
+ If you publish a broken version, retract it:
+ 
+ &#96;&#96;&#96;go
+ // go.mod
+ module github.com/myname/mylib
+ 
+ go 1.22
+ 
+ retract (
+     v1.2.3 // Contains critical bug, use v1.2.4
+     [v1.0.0, v1.1.0] // Known issues in range
+ )
+ &#96;&#96;&#96;
+ 
+ Users are warned when they try to use retracted versions.
+ 
+ ### 5. Version Internal Tools Separately
+ 
+ If your repo has a library and a CLI:
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod           # module github.com/myname/myproject
+ ├── cmd/
+ │   └── mytool/
+ └── pkg/
+     └── mylib/
+ &#96;&#96;&#96;
+ 
+ Consider separate modules if they have different release cadences.
+ 
+ ## Releasing a Library
+ 
+ Checklist:
+ 
+ 1. **Update CHANGELOG**
+ 2. **Run tests**: &#96;go test ./...&#96;
+ 3. **Check for breaking changes**: API compatible?
+ 4. **Determine version**: major/minor/patch
+ 5. **Update go.mod** if major version change
+ 6. **Commit**: &#96;git commit -m "Release v1.2.3"&#96;
+ 7. **Tag**: &#96;git tag v1.2.3&#96;
+ 8. **Push**: &#96;git push origin main v1.2.3&#96;
+ 9. **Verify**: &#96;go get github.com/myname/mylib@v1.2.3&#96;
+ 
+ The Go module proxy indexes your tag automatically.
+ 
+ ## The Honest Take
+ 
+ Go's versioning is simpler but more rigid than NuGet's.
+ 
+ **What Go does well:**
+ - Git tags = source of truth
+ - Reproducible builds (MVS)
+ - v2+ as different paths is clever
+ - No version file to maintain
+ 
+ **What NuGet does better:**
+ - Version ranges for flexibility
+ - Same package ID across majors
+ - Central registry with search
+ - Richer metadata
+ 
+ **The verdict:**
+ If you're used to version ranges (&#96;[1.0,2.0)&#96;), Go's exact versioning feels restrictive. But it eliminates "works on my machine" dependency issues.
+ 
+ The major version path change (&#96;/v2&#96;) is controversial but ensures you can't accidentally break dependents with a major update.
+ 
+ Learn the patterns, version thoughtfully, and your users will thank you.
+ 
+ ---
+ 
+ *That wraps up Phase 3 on deployment and production. Go's operational story is strong: single binaries, tiny containers, fast builds, simple CI/CD. The tooling is less sophisticated than .NET's in places, but the simplicity makes up for it.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
      45

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 45 posts are done and the build passes! Let me give the user a complete summary of the series.</details></think>

---

All 9 Phase 3 posts done! **45 posts total** — the complete C# to Go series!

## C# to Go Series — Final Summary (45 posts)

### Phase 1: The Fundamentals (22 posts)

**Getting Oriented** (3)
1-3. Toolchain, go.mod, Phrasebook

**Types & Data** (5)
4-8. Structs, Visibility, Generics, Nil, Enums

**Control Flow & Error Handling** (3)
9-11. Errors, Panic/Recover, Switch

**Memory & Pointers** (3)
12-14. Pointers, Escape Analysis, Slices

**Concurrency** (5)
15-19. Goroutines, Channels, Select, Sync, Context

**Interfaces & Composition** (3)
20-22. Implicit Interfaces, Composition/Embedding, any/type assertions

---

### Phase 2: The Ecosystem (14 posts)

**Project Structure & Modules** (2)
23-24. Project Structure, Multi-Module Repos

**Testing** (3)
25-27. Built-in Testing, Mocking, Benchmarks/Profiling

**Common Patterns & Libraries** (6)
28-33. HTTP, JSON, Config, Logging (slog), database/sql, GORM

**Tooling** (3)
34-36. Linting/gofmt, go:generate, Debugging (Delve)

---

### Phase 3: Deployment & Production (9 posts) ← **COMPLETE**

**Building & Distributing** (2)
37. **"Single Binary Deploys: The Killer Feature"** — Cross-compilation, no runtime, ops will love you
38. **"Shrinking Binaries and Build Tags"** — ldflags, conditional compilation, build tags

**Containers & Cloud** (3)
39. **"Dockerfile for Go: Simpler Than You'd Think"** — Multi-stage, scratch, distroless (~10MB images)
40. **"AWS Lambda and Go: Cold Starts That Don't Hurt"** — 100-200ms cold starts vs .NET's 2-4 seconds
41. **"Kubernetes and Go: A Natural Fit"** — Health probes, graceful shutdown, resource limits

**Observability** (2)
42. **"Metrics, Traces, and Logs: The OpenTelemetry Way"** — Full OTel instrumentation
43. **"Health Checks and Readiness Probes"** — Liveness vs readiness vs startup

**CI/CD** (2)
44. **"GitHub Actions for Go Projects"** — Testing, linting, GoReleaser, Docker publishing
45. **"Versioning Your Modules"** — Semantic versioning, v2 paths, MVS vs NuGet

---

That's a comprehensive guide from "what is Go?" to "deploying to production with observability." 🎉

---

_**User (2025-12-31 01:06Z)**_

and finally, make sure oyu space thedates out particularly for the 6 months later post

Bonus: The Honest Bits

What I Actually Miss From C# — Features that haven't come to Go (and might never)
What I'll Never Go Back For — The Go features that ruined me for other languages
Six Months In: Was It Worth It? — A retrospective on the learning curve and where I landed

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the final 3 bonus posts, spacing out the dates. Looking at the existing dates:
- Phase 1-2 posts: late December 2024 to early January 2025
- Phase 3 posts: January 5, 2025

For the bonus "honest bits" section, I should space them out more to feel like a genuine reflection:
- "What I Actually Miss From C#" - maybe mid-January 2025
- "What I'll Never Go Back For" - late January 2025  
- "Six Months In" - should be 6 months after starting the journey (if we started in late December 2024, that would be June 2025)

Let me write these three posts with appropriate dates.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-what-i-miss.md</summary>

**Chunk 1**
Lines added: 228, lines removed: 1

```diff
@@ -1,1 +1,228 @@
- 
+ +++
+ title = "What I Actually Miss From C#"
+ date = "2025-01-15"
+ draft = false
+ tags = ["go", "dotnet", "reflection", "csharp"]
+ +++
+ 
+ I've been writing Go full-time for a couple of months now. I like it. I'm productive. But let's be honest: there are things I miss from C#. Not everything Go does differently is better, and pretending otherwise would be tribal nonsense.
+ 
+ Here's my genuine list of features I wish Go had—not complaints, just honest observations about trade-offs.
+ 
+ ## LINQ
+ 
+ God, I miss LINQ.
+ 
+ &#96;&#96;&#96;csharp
+ var activeUsers = users
+     .Where(u =&gt; u.IsActive)
+     .OrderBy(u =&gt; u.Name)
+     .Select(u =&gt; new { u.Id, u.Name })
+     .ToList();
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ var activeUsers []UserSummary
+ for _, u := range users {
+     if u.IsActive {
+         activeUsers = append(activeUsers, UserSummary{ID: u.ID, Name: u.Name})
+     }
+ }
+ sort.Slice(activeUsers, func(i, j int) bool {
+     return activeUsers[i].Name &lt; activeUsers[j].Name
+ })
+ &#96;&#96;&#96;
+ 
+ More lines. More manual work. No lazy evaluation. No composition.
+ 
+ Yes, there are libraries like &#96;lo&#96; that add LINQ-like functions:
+ 
+ &#96;&#96;&#96;go
+ activeUsers := lo.Filter(users, func(u User, _ int) bool {
+     return u.IsActive
+ })
+ &#96;&#96;&#96;
+ 
+ But it's not the same. LINQ is integrated into the language. It's type-safe. It composes elegantly. Go's approach works but lacks the expressiveness.
+ 
+ ## Nullable Reference Types
+ 
+ C# 8's nullable reference types are genuinely excellent:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = GetUser();
+ if (user != null)
+ {
+     Console.WriteLine(user.Name); // Compiler knows it's not null here
+ }
+ &#96;&#96;&#96;
+ 
+ Go has nil, and the compiler doesn't help you track it:
+ 
+ &#96;&#96;&#96;go
+ user := GetUser()
+ if user != nil {
+     fmt.Println(user.Name) // You remembered to check, compiler didn't care
+ }
+ &#96;&#96;&#96;
+ 
+ The number of nil pointer panics I've written in Go that C#'s nullable analysis would have caught... it's not zero.
+ 
+ ## Properties with Logic
+ 
+ Sometimes I want computed properties:
+ 
+ &#96;&#96;&#96;csharp
+ public class Rectangle
+ {
+     public double Width { get; set; }
+     public double Height { get; set; }
+     public double Area =&gt; Width * Height;  // clean
+ }
+ &#96;&#96;&#96;
+ 
+ Go:
+ 
+ &#96;&#96;&#96;go
+ type Rectangle struct {
+     Width  float64
+     Height float64
+ }
+ 
+ func (r Rectangle) Area() float64 {
+     return r.Width * r.Height
+ }
+ 
+ // Usage: rect.Area() not rect.Area
+ &#96;&#96;&#96;
+ 
+ The parentheses seem minor but they matter for readability. A computed value should look like accessing a value, not calling a function.
+ 
+ ## Async/Await for Simple Cases
+ 
+ Yes, goroutines are more powerful. Yes, no coloured functions is elegant. But sometimes I just want:
+ 
+ &#96;&#96;&#96;csharp
+ var user = await GetUserAsync(id);
+ var orders = await GetOrdersAsync(user.Id);
+ return await BuildSummaryAsync(user, orders);
+ &#96;&#96;&#96;
+ 
+ The sequential async flow is clean. In Go, this is just synchronous code (which is fine), but when you need to collect results from parallel operations, channels feel heavyweight compared to:
+ 
+ &#96;&#96;&#96;csharp
+ var results = await Task.WhenAll(tasks);
+ &#96;&#96;&#96;
+ 
+ ## Extension Methods
+ 
+ Adding methods to types you don't own:
+ 
+ &#96;&#96;&#96;csharp
+ public static string Truncate(this string s, int maxLength) =&gt;
+     s.Length &lt;= maxLength ? s : s[..maxLength] + "...";
+ 
+ // Usage
+ var short = longString.Truncate(100);
+ &#96;&#96;&#96;
+ 
+ Go has no extension methods. You write functions:
+ 
+ &#96;&#96;&#96;go
+ func Truncate(s string, maxLength int) string {
+     if len(s) &lt;= maxLength {
+         return s
+     }
+     return s[:maxLength] + "..."
+ }
+ 
+ // Usage
+ short := Truncate(longString, 100)
+ &#96;&#96;&#96;
+ 
+ Works, but doesn't chain as nicely. Discovery is harder too—you can't just type &#96;string.&#96; and see available operations.
+ 
+ ## Pattern Matching
+ 
+ C#'s pattern matching is wonderful:
+ 
+ &#96;&#96;&#96;csharp
+ var message = obj switch
+ {
+     int i when i &gt; 0 =&gt; $"positive: {i}",
+     int i =&gt; $"non-positive: {i}",
+     string s =&gt; $"string: {s}",
+     null =&gt; "null",
+     _ =&gt; "unknown"
+ };
+ &#96;&#96;&#96;
+ 
+ Go's type switches are good but not as powerful:
+ 
+ &#96;&#96;&#96;go
+ switch v := obj.(type) {
+ case int:
+     if v &gt; 0 {
+         message = fmt.Sprintf("positive: %d", v)
+     } else {
+         message = fmt.Sprintf("non-positive: %d", v)
+     }
+ case string:
+     message = fmt.Sprintf("string: %s", v)
+ // no null case, no default with value access
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;when&#96; guards and the expression form are genuinely missed.
+ 
+ ## Rich IDE Support
+ 
+ Rider and Visual Studio are exceptional. The refactoring tools, the code analysis, the debugging experience... Go tooling is good and improving, but it's not at the same level.
+ 
+ "Rename symbol across solution" in Rider is flawless. In gopls, it's usually fine but occasionally misses things.
+ 
+ ## Proper Enums
+ 
+ I covered this in an earlier post, but I still miss them:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status { Pending, Active, Completed }
+ Status.Pending.ToString()  // "Pending"
+ Enum.Parse&lt;Status&gt;("Active")  // Status.Active
+ &#96;&#96;&#96;
+ 
+ Go's &#96;const&#96; + &#96;iota&#96; requires so much boilerplate for basic enum functionality.
+ 
+ ## Generic Variance
+ 
+ &#96;IEnumerable&lt;Dog&gt;&#96; is assignable to &#96;IEnumerable&lt;Animal&gt;&#96; in C#. Go has no variance. A &#96;[]Dog&#96; is not a &#96;[]Animal&#96;. This comes up more often than you'd think when designing APIs.
+ 
+ ## What I Don't Miss
+ 
+ For balance, here's what I thought I'd miss but don't:
+ 
+ **Inheritance**: Embedding and interfaces cover everything I actually need.
+ 
+ **Exceptions**: Explicit error handling grew on me. It's more code but clearer.
+ 
+ **Heavyweight frameworks**: Building with minimal dependencies is refreshing.
+ 
+ **Complex configuration**: No more XML config files and DI containers to wire up.
+ 
+ **Slow startup**: Go starts instantly. .NET apps... don't always.
+ 
+ ## The Reality Check
+ 
+ None of these missing features make Go unusable. I'm productive. I ship code. The simplicity has real benefits that offset these gaps.
+ 
+ But when Go advocates say "you won't miss anything from C#," they're being tribal. These are real features that make real tasks easier. Go chose different trade-offs. Those trade-offs are sometimes worse for specific use cases.
+ 
+ Acknowledging that doesn't mean Go is bad. It means it's a tool with trade-offs, like every language.
+ 
+ ---
+ 
+ *Next up: the features I'll never go back for—the Go patterns that have genuinely ruined me for other languages.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-never-go-back.md</summary>

**Chunk 1**
Lines added: 164, lines removed: 1

```diff
@@ -1,1 +1,164 @@
- 
+ +++
+ title = "What I'll Never Go Back For"
+ date = "2025-02-01"
+ draft = false
+ tags = ["go", "dotnet", "reflection", "csharp"]
+ +++
+ 
+ Last time I talked about what I miss from C#. Now let's flip it: what has Go given me that I'd genuinely struggle to give up?
+ 
+ Some of these I expected to like. Others surprised me. All of them have changed how I think about software.
+ 
+ ## Fast Compilation
+ 
+ This sounds minor until you've lived it. &#96;go build&#96; takes seconds. For a large project, maybe 10-15 seconds. That's it.
+ 
+ Coming from .NET where build times can stretch into minutes for larger solutions, the fast feedback loop in Go is transformative. I run the compiler constantly. I try things. I iterate quickly.
+ 
+ When I go back to C# projects now, the build times feel painful in a way they didn't before.
+ 
+ ## Single Binary Deployment
+ 
+ I keep coming back to this because it's so operationally clean.
+ 
+ &#96;&#96;&#96;bash
+ scp myapp server:/usr/local/bin/
+ ssh server 'systemctl restart myapp'
+ &#96;&#96;&#96;
+ 
+ No runtime installation. No SDK version matching. No framework compatibility. Just a file that runs.
+ 
+ Every time I deploy a .NET app and deal with runtime versions or container size, I miss Go's simplicity.
+ 
+ ## Cross-Compilation
+ 
+ Building for Linux from my Mac:
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=amd64 go build -o myapp
+ &#96;&#96;&#96;
+ 
+ No Docker. No virtual machines. No cross-compiler toolchains. Just environment variables.
+ 
+ I now consider "can I easily build for all platforms?" when evaluating any tool. Go spoiled me.
+ 
+ ## Explicit Error Handling
+ 
+ I know, I know—I literally wrote a post about &#96;if err != nil&#96; being tedious. But here's the thing: after months of it, I've come to appreciate the explicitness.
+ 
+ Every line that can fail is marked. Every error is handled (or explicitly ignored). No hidden control flow. When something goes wrong, the error path is obvious.
+ 
+ Going back to exception-based code, I find myself thinking "wait, which of these lines can throw?" The implicit nature of exceptions, which I never questioned before, now feels like hidden complexity.
+ 
+ ## Goroutines and Channels
+ 
+ The concurrency model is genuinely excellent.
+ 
+ &#96;&#96;&#96;go
+ go processRequest(req)
+ &#96;&#96;&#96;
+ 
+ No &#96;Task.Run&#96;. No async/await colouring. No thread pool configuration. Just &#96;go&#96;.
+ 
+ And channels for communication:
+ 
+ &#96;&#96;&#96;go
+ results := make(chan Result, 10)
+ go worker(results)
+ for r := range results {
+     process(r)
+ }
+ &#96;&#96;&#96;
+ 
+ The producer-consumer pattern in one elegant construct.
+ 
+ I can spin up thousands of goroutines without thinking. In .NET, creating thousands of Tasks has overhead and complexity that makes me hesitate.
+ 
+ ## The &#96;defer&#96; Statement
+ 
+ Resource cleanup that reads top-to-bottom:
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open(name)
+ if err != nil {
+     return err
+ }
+ defer file.Close()  // cleanup declared right after acquisition
+ 
+ // Use file...
+ // Cleanup happens automatically when function returns
+ &#96;&#96;&#96;
+ 
+ Compare to:
+ 
+ &#96;&#96;&#96;csharp
+ using var file = File.OpenRead(name);
+ // or
+ try { } finally { file.Close(); }
+ &#96;&#96;&#96;
+ 
+ &#96;using&#96; is fine, but &#96;defer&#96; is more flexible—it works for any cleanup, not just &#96;IDisposable&#96;.
+ 
+ ## Implicit Interface Satisfaction
+ 
+ Defining an interface that existing types already implement:
+ 
+ &#96;&#96;&#96;go
+ type Stringer interface {
+     String() string
+ }
+ // fmt.Stringer already exists, many types implement it
+ // My new interface is satisfied by all of them, retroactively
+ &#96;&#96;&#96;
+ 
+ No modifying the original types. No adapters. Just "if you have these methods, you implement this interface."
+ 
+ When I design APIs now, I think in terms of small interfaces that might already be satisfied. It's a different design philosophy, and I prefer it.
+ 
+ ## gofmt: One True Format
+ 
+ No bikeshedding about formatting. Ever. &#96;gofmt&#96; decides, everyone uses it, discussions about tabs vs spaces simply don't happen.
+ 
+ The uniformity of Go codebases is remarkable. I can read anyone's code and it looks like my code, structurally. That matters for open source, for team collaboration, for just reading random code on GitHub.
+ 
+ I now find formatting debates in other languages exhausting. Just pick one and enforce it.
+ 
+ ## Context Propagation
+ 
+ Every function that does I/O takes &#96;context.Context&#96;. Cancellation propagates automatically. Request-scoped values flow through the call chain.
+ 
+ &#96;&#96;&#96;go
+ func HandleRequest(ctx context.Context, req Request) error {
+     // ctx carries cancellation, deadlines, request ID, user info...
+     return processWithDependencies(ctx, req)
+ }
+ &#96;&#96;&#96;
+ 
+ This pervasive context threading seemed tedious at first. Now it's indispensable. I always have cancellation. I always have request context. I never have to wonder "how do I get the current request ID here?"
+ 
+ ## Small Standard Library Surface
+ 
+ The Go standard library is focused. It does HTTP, JSON, SQL, crypto, and other fundamentals well. It doesn't try to do everything.
+ 
+ This forces you to understand what you're using. There's no kitchen-sink framework hiding complexity. You build with small, understandable pieces.
+ 
+ In .NET, the framework is vast. Great for discoverability, but you can go deep into features you don't understand. Go's smaller surface area means I actually know my tools.
+ 
+ ## What This Means
+ 
+ These aren't just features I like—they've changed how I think about software development:
+ 
+ - **Feedback loops matter**: Fast compilation isn't a nice-to-have.
+ - **Deployment simplicity compounds**: Single binaries eliminate entire categories of problems.
+ - **Explicit beats implicit**: I'd rather see the error handling than have it hidden.
+ - **Concurrency should be easy**: If it's hard, people won't use it correctly.
+ - **Consistency beats preference**: Team standards &gt; individual style.
+ 
+ Would I take a job writing C# again? Absolutely. It's a good language with a mature ecosystem.
+ 
+ Would I miss these Go features? Absolutely. Some of them every single day.
+ 
+ ---
+ 
+ *Next time: six months in—a proper retrospective on whether this journey was worth it.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-six-months.md</summary>

**Chunk 1**
Lines added: 157, lines removed: 1

```diff
@@ -1,1 +1,157 @@
- 
+ +++
+ title = "Six Months In: Was It Worth It?"
+ date = "2025-06-28"
+ draft = false
+ tags = ["go", "dotnet", "retrospective", "career", "csharp"]
+ +++
+ 
+ Six months ago, I started this series with a simple goal: document learning Go as an experienced C# developer. Not a tutorial—there are plenty of those—but an honest account of the transition.
+ 
+ Now, with half a year of production Go code behind me, it's time for a retrospective. Was it worth it? Would I do it again? What would I tell past-me?
+ 
+ ## The Learning Curve
+ 
+ **Weeks 1-2**: Syntax adjustment. Easy. Go is a small language.
+ 
+ **Weeks 3-4**: Fighting the language. Trying to write C# in Go. Wondering why there are no generics (there are now), no exceptions (by design), no classes (by design).
+ 
+ **Months 2-3**: Acceptance. Starting to see why Go makes its choices. Writing idiomatic code. Stopping fighting.
+ 
+ **Months 4-6**: Fluency. Thinking in Go. Actually preferring some of its approaches. Not reaching for C# patterns anymore.
+ 
+ The inflection point was around month two. That's when I stopped asking "why doesn't Go have X?" and started asking "how do Go developers solve this?"
+ 
+ ## What I Got Right
+ 
+ **Starting with real projects**: I didn't do tutorials. I built things I needed. That forced me to solve actual problems, not artificial exercises.
+ 
+ **Reading the standard library**: Go's stdlib is readable and idiomatic. I learned more from reading &#96;net/http&#96; source than from any guide.
+ 
+ **Accepting the constraints**: Once I stopped resisting (no inheritance, explicit errors, no LINQ), I could appreciate the benefits.
+ 
+ **Keeping notes**: This blog series was originally just my notes. Writing forced me to understand things properly.
+ 
+ ## What I Got Wrong
+ 
+ **Overusing channels**: Early on, I used channels for everything. Turns out, sometimes a mutex is simpler. "Share memory by communicating" isn't "always use channels."
+ 
+ **Fighting gofmt**: I tried to configure formatting. You can't. I wasted time before accepting the One True Format.
+ 
+ **Importing my architecture**: I tried to recreate C#-style layered architecture in Go. It felt wrong because it was wrong. Go projects structure differently.
+ 
+ **Ignoring the ecosystem**: I tried to stick to stdlib for too long. Libraries like &#96;chi&#96;, &#96;sqlx&#96;, and &#96;zerolog&#96; exist for good reasons. Use them.
+ 
+ ## The Productivity Question
+ 
+ Here's the honest answer: I'm about as productive in Go as I was in C#.
+ 
+ - For HTTP services, similar productivity
+ - For CLI tools, Go is faster (single binary, fast compilation)
+ - For complex business logic with lots of types, C# might be faster (LINQ, pattern matching, rich type system)
+ - For deployment and operations, Go is significantly simpler
+ 
+ The productivity isn't dramatically different. What's different is *what kind* of work is easy.
+ 
+ ## What I Build Now
+ 
+ Six months in, I naturally reach for Go when:
+ 
+ - Building microservices or APIs
+ - Writing CLI tools
+ - Creating Lambda functions
+ - Anything that needs cross-platform binaries
+ - Projects where deployment simplicity matters
+ 
+ I'd still use C# for:
+ 
+ - Complex domain modelling (richer type system)
+ - Windows-specific applications
+ - Teams that know .NET well
+ - Projects requiring mature ORMs or complex LINQ
+ 
+ ## The Things I Still Miss
+ 
+ Even after six months:
+ 
+ - **LINQ**. Every time I write a for loop to filter a slice.
+ - **Pattern matching**. When I have complex type dispatch.
+ - **IDE refactoring**. Rider's tools are unmatched.
+ - **Rich generics**. Go's generics are adequate, not great.
+ 
+ These aren't dealbreakers. But they're real gaps that don't disappear with familiarity.
+ 
+ ## The Things I Can't Give Up
+ 
+ Equally persistent:
+ 
+ - **Fast builds**. Going back to slow compilation feels painful.
+ - **Single binaries**. Deployment simplicity is addictive.
+ - **Explicit errors**. I now find exception-based code harder to reason about.
+ - **gofmt**. No formatting debates. Ever. Bliss.
+ 
+ ## Would I Do It Again?
+ 
+ Yes. Without hesitation.
+ 
+ Not because Go is objectively better than C#. It isn't, not in all dimensions. But because:
+ 
+ 1. **Learning a different paradigm expanded my thinking**. Go's constraints forced different solutions. Some of those solutions are better.
+ 
+ 2. **Professional flexibility increased**. I can now take Go or C# roles. More options is good.
+ 
+ 3. **It made me better at C# too**. Understanding Go's explicit error handling made me more careful in C#. Understanding Go's interface design influenced how I design C# interfaces.
+ 
+ 4. **It was fun**. Learning something new after years of expertise is energising.
+ 
+ ## Advice for C# Developers Considering Go
+ 
+ **Do it if:**
+ - You want to expand your thinking
+ - You're building services where deployment simplicity matters
+ - You're curious about different paradigms
+ - Your team or job requires it
+ 
+ **Don't expect:**
+ - Go to be better at everything
+ - The transition to be instant
+ - Your C# knowledge to transfer completely
+ - To never want C# features
+ 
+ **The mindset shift:**
+ - Go is simple, not primitive
+ - Constraints can be features
+ - Different isn't worse
+ - "Boring" code is often good code
+ 
+ ## Six Months vs Day One
+ 
+ | Aspect | Day One | Six Months |
+ |--------|---------|------------|
+ | Error handling | Tedious | Appreciated |
+ | No inheritance | Limiting | Liberating |
+ | Small stdlib | Lacking | Focused |
+ | gofmt | Annoying | Essential |
+ | Deployment | Nice | Can't go back |
+ | Productivity | Lower | Equivalent |
+ | Enjoyment | Frustration | Comfort |
+ 
+ ## The Final Word
+ 
+ Was it worth it?
+ 
+ For me, absolutely. The operational benefits alone (fast builds, single binaries, simple deployment) have saved more time than the learning curve cost. The expanded perspective has made me a better engineer.
+ 
+ But I want to be clear: this isn't a "Go is better than C#" conclusion. It's a "Go is *different* from C#, and understanding both makes you better" conclusion.
+ 
+ C# is an excellent language with a mature ecosystem. Go is an excellent language with different trade-offs. Knowing both lets you pick the right tool for each job.
+ 
+ If you've followed this series, I hope it's been useful. Not as a Go tutorial—there are better resources for that—but as an honest map of the terrain from someone who's walked it.
+ 
+ The learning curve is real. The frustrations are real. And so are the benefits.
+ 
+ Thanks for reading.
+ 
+ ---
+ 
+ *This concludes the C# to Go series. All 48 posts are available in the archive. If you found it useful, I'd love to hear about your own transition experiences. Find me on the usual channels.*
+ 
```

</details>

</tool-use>

---



---

<think><details><summary>Thought Process</summary>
All three bonus posts have been created with spaced out dates:
- "What I Actually Miss From C#" - January 15, 2025 (about 2 weeks after the deployment posts)
- "What I'll Never Go Back For" - February 1, 2025 (2 weeks later)
- "Six Months In: Was It Worth It?" - June 28, 2025 (6 months after the series started)

Let me verify the build works and count the total posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
      48

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 48 posts have been created. Let me provide a summary for the user about the bonus posts.</details></think>

---

Done! The three bonus posts have been created with dates spaced out to feel authentic to a real learning journey:

| Post | Date | Theme |
|------|------|-------|
| **What I Actually Miss From C#** | January 15, 2025 | Honest gaps: LINQ, nullable refs, properties, pattern matching, extension methods |
| **What I'll Never Go Back For** | February 1, 2025 | Go features that are now essential: fast builds, single binaries, goroutines, defer, gofmt |
| **Six Months In: Was It Worth It?** | June 28, 2025 | Full retrospective with learning curve timeline, productivity reality check, and advice |

The final post is dated **six months after the series started**, giving it that genuine "looking back" feel.

The series is now complete at **48 posts** covering:
- Phase 1: Fundamentals (toolchain, modules, phrasebook, types, control flow, memory, concurrency, interfaces)
- Phase 2: Ecosystem (project structure, testing, patterns, libraries, tooling)
- Phase 3: Deployment (building, containers, cloud, observability, CI/CD)
- Bonus: The honest bits (what's missed, what's kept, retrospective)

---

