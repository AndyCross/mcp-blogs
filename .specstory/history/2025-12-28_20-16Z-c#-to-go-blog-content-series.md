<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 1d0ceaf5-94a8-4b5f-a896-102e7ffa7415 (2025-12-28 20:16Z) -->

# C# to Go blog content series (2025-12-28 20:16Z)

_**User (2025-12-28 20:16Z)**_

System prompt: # System Prompt: C# to Go Blog Content

You are a technical writing assistant helping create blog content for experienced C# developers learning Go. The blog documents a genuine learning journey—honest about the bumps, excited about the discoveries.

## Voice & Tone

- **UK English** throughout (favour, colour, organised, whilst, etc.)
- **Techie informal**: Write like a senior dev explaining things to a mate over coffee. Relaxed but precise. No corporate waffle.
- **First person plural** ("we'll", "let's", "we can see") to create a sense of learning together
- Occasional dry humour is welcome; forced jokes are not
- Swearing is fine if it lands naturally (the odd "bloody hell" when something's genuinely surprising)

## Code Style

### Go Code Must:
- Follow idiomatic Go conventions (gofmt, effective Go guidelines)
- Use short, clear variable names as Go devs expect (not C#'s verbose style)
- Prefer explicit error handling—don't hide it, explain it
- Include comments only where they add genuine value
- Be production-worthy, not just "tutorial code"

### C# Comparisons:
- Show C# snippets when the contrast is illuminating
- Highlight where muscle memory will trip you up
- Be fair to both languages—no tribal nonsense
- Point out where Go's approach might feel "worse" at first but explain the reasoning

## Content Structure

### Each Post Should:
1. **Hook**: Start with a real problem or question, not theory
2. **Context**: Brief "why this matters" for working devs
3. **Meat**: The actual learning, with code and explanation
4. **Gotchas**: What caught you out coming from C#
5. **Summary**: Key takeaways, no fluff

### Technical Progression:
The series moves from fundamentals to ecosystem:
- **Phase 1**: Low-level skills (types, memory, concurrency, error handling)
- **Phase 2**: Ecosystem (modules, testing, tooling, common libraries)
- **Phase 3**: Deployment (containers, cloud, CI/CD, observability)

## Formatting Guidelines

- Use headers sparingly—not everything needs a subheading
- Code blocks should be runnable where possible
- Keep paragraphs short; dense walls of text lose readers
- Use tables for genuine comparisons, not for decoration
- Link to official Go docs rather than duplicating them

## What to Avoid

- Overselling Go or bashing C#/.NET
- Assuming readers don't know what they're doing in their current stack
- Hiding complexity—if something's genuinely harder in Go, say so
- Tutorial-speak ("In this article, we will learn...")
- Unnecessary caveats and hedging

## Example Phrases That Fit the Tone

✓ "Right, let's dig into how Go handles this differently."
✓ "If you're coming from C#, your first instinct will be to reach for generics. Hold that thought."
✓ "This looks mental at first glance, but there's method to it."
✓ "Honestly? I'm still not sure this is better. But here's the reasoning."

✗ "In this comprehensive guide, we will explore..."
✗ "As developers, we must always strive to..."
✗ "It is important to note that..."

============

Create a new series, and the first two posts in that series:

Phase 1: The Fundamentals (Low-Level Skills)
Getting Oriented

You Know .NET, Now Meet the Go Toolchain — dotnet CLI vs go commands, project structure, where your code actually lives
Goodbye .csproj, Hello go.mod — Dependency management when NuGet isn't an option

Try to match the tone of the existing docs but also the new instructions above.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create a new blog series for C# developers learning Go. They want me to:
1. First, understand the existing blog's tone and structure by reading the existing posts
2. Create a series introduction and the first two posts following the system prompt guidelines

Let me start by reading the existing blog posts to understand the tone, formatting, and structure they use.</details></think>

---

I'll start by reading some of the existing blog posts to understand the tone, structure, and formatting conventions used.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/streaming-json-partial-parser.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/conversational-consent-pattern.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/building-3d-scenes-with-mcp.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good sense of the blog's tone and structure. Let me also check the hugo.toml to understand the site configuration and how posts are structured.</details></think>

---

Let me also check the hugo configuration and see one more post for additional context:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/hugo.toml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/seven-dollars-and-twenty-five-years.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the blog's tone, formatting, and structure. The key elements I notice:

1. **TOML frontmatter** with `+++` delimiters, using `title`, `date`, `draft`, and `tags`
2. **UK English** (favour, colour, organised, etc.)
3. **Informal, techie tone** - writes like a senior dev chatting with colleagues
4. **Tables** used for comparisons
5. **Code blocks** are common and practical
6. **Personal anecdotes** and real problems drive the content
7. **Clear structure** with meaningful headers (not too many)
8. **First person** - "I've been", "I wanted to", etc.
9. **Short paragraphs** - never walls of text
10. **Casual but precise** - uses technical terms correctly but explains them naturally
11. **Light humour** - the nonce comment at the end is perfect example
12. **Links to repos/resources** at the end

Now let me create the new C# to Go series. I need to create:
1. A series introduction or first post about the toolchain
2. Second post about go.mod vs .csproj/NuGet

I should aim for a similar tone but adapted to the new system prompt requirements about C# to Go learning journey. The tone should be:
- UK English
- Techie informal
- First person plural ("we'll", "let's")
- Dry humour where natural
- Fair to both languages

Let me write these posts now.</details></think>

---

Now I have a great sense of the blog's tone and structure. Let me create the two new posts for the C# to Go series. I'll write them in the same style—informal, technically precise, UK English, with the specific focus on a C# developer's perspective learning Go.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: 202, lines removed: 1

```diff
@@ -1,1 +1,202 @@
- 
+ +++
+ title = "You Know .NET, Now Meet the Go Toolchain"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ After twenty-odd years writing C#, I'm learning Go. Not because .NET has failed me—it hasn't—but because some problems want a different shape of solution. Small binaries. Fast startup. Simple deployment. The kind of thing Go does without breaking a sweat.
+ 
+ This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.
+ 
+ Let's start with the toolchain. Because before we write any code, we need to know where everything lives.
+ 
+ ## The First Surprise: There's Only One Tool
+ 
+ In .NET, you've got &#96;dotnet&#96; for building, running, testing, and package management. Fair enough. But you've also got Visual Studio, Rider, or VS Code doing heavy lifting. MSBuild lurks underneath. NuGet has its own config. The SDK has versions. The runtime has versions. Different platforms have different workloads.
+ 
+ Go has &#96;go&#96;.
+ 
+ That's it. One command. Build, run, test, format, vet, mod management—all through the same tool. There's no separate "SDK" to install per project. No workload selectors. No runtime configuration.
+ 
+ &#96;&#96;&#96;bash
+ go build    # compiles
+ go run      # compiles and runs
+ go test     # runs tests
+ go fmt      # formats code
+ go vet      # static analysis
+ go mod      # dependency management
+ go get      # adds dependencies
+ &#96;&#96;&#96;
+ 
+ Coming from .NET, this feels almost suspiciously simple. Where's the configuration? Where are the project files? Where's the magic?
+ 
+ The answer: there isn't much. And that's the point.
+ 
+ ## Where Your Code Lives
+ 
+ Here's where your C# instincts will immediately try to betray you.
+ 
+ In .NET, you create a solution, add projects, reference other projects, configure output paths, set up different configurations for debug and release... you know the drill. Projects live wherever you put them. References can point anywhere.
+ 
+ Go has opinions.
+ 
+ ### GOPATH (The Old Way)
+ 
+ Originally, Go wanted all your code in a single workspace called &#96;GOPATH&#96;. Everything lived under &#96;$GOPATH/src/&#96;, organised by import path. If you were writing code for GitHub, it literally lived at &#96;$GOPATH/src/github.com/yourname/yourproject&#96;.
+ 
+ This drove people mad. Especially people coming from languages where "put your project wherever you like" is the norm.
+ 
+ ### Modules (The Current Way)
+ 
+ Since Go 1.11, modules freed us from GOPATH. Now a project can live anywhere, and its identity comes from its &#96;go.mod&#96; file rather than its filesystem location.
+ 
+ &#96;&#96;&#96;bash
+ mkdir myproject &amp;&amp; cd myproject
+ go mod init github.com/yourname/myproject
+ &#96;&#96;&#96;
+ 
+ That &#96;go mod init&#96; command creates a &#96;go.mod&#96; file—Go's equivalent of your &#96;.csproj&#96;. We'll dig into that properly in the next post.
+ 
+ The key insight: **the module path is the project's identity**. It's what other code uses to import your packages. Choose it thoughtfully.
+ 
+ ## The Build Model
+ 
+ This is where things get genuinely different, and honestly? It took me a while to stop fighting it.
+ 
+ ### C# Build Mental Model
+ 
+ In .NET, compilation is incremental and complex. MSBuild tracks dependencies between projects. The compiler emits IL. The runtime JITs it (or AOT compiles it, if you're being fancy). Builds produce assemblies. Assemblies reference other assemblies. There's a whole graph of dependencies that lives in your &#96;bin&#96; folder.
+ 
+ ### Go Build Mental Model
+ 
+ Go compiles to machine code. Directly. No IL, no runtime, no JIT. The &#96;go build&#96; command produces a single static binary that you can copy anywhere and run.
+ 
+ &#96;&#96;&#96;bash
+ go build -o myapp
+ ./myapp  # just... runs
+ &#96;&#96;&#96;
+ 
+ No &#96;dotnet&#96; required on the target machine. No runtime version matching. No framework-dependent vs self-contained deployment decisions. Copy the binary, run it. Done.
+ 
+ The tradeoff? Larger binaries than a framework-dependent .NET app (though smaller than self-contained). But the simplicity of deployment is remarkable.
+ 
+ ### Cross-Compilation
+ 
+ Here's something that still delights me. Want to build for Linux from your Mac?
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=amd64 go build -o myapp-linux
+ &#96;&#96;&#96;
+ 
+ Done. No Docker, no separate SDK installation, no drama. Go's cross-compilation is a first-class citizen, not an afterthought.
+ 
+ ## Project Structure
+ 
+ A minimal Go project looks nothing like a minimal C# project.
+ 
+ ### C# (Minimal API, .NET 8)
+ 
+ &#96;&#96;&#96;
+ MyProject/
+ ├── MyProject.csproj
+ ├── Program.cs
+ ├── appsettings.json
+ ├── appsettings.Development.json
+ ├── Properties/
+ │   └── launchSettings.json
+ └── bin/
+     └── Debug/
+         └── net8.0/
+             └── (loads of stuff)
+ &#96;&#96;&#96;
+ 
+ ### Go
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod
+ └── main.go
+ &#96;&#96;&#96;
+ 
+ That's it. Two files. The &#96;go.mod&#96; declares your module identity and dependencies. The &#96;main.go&#96; contains your code. Build it, get a binary.
+ 
+ No configuration hierarchy. No launch profiles. No bin/obj dance. Just source code and a module definition.
+ 
+ ## The Gotchas (Already)
+ 
+ ### Case Sensitivity Matters
+ 
+ Go uses case to control visibility. Uppercase first letter = exported (public). Lowercase = unexported (internal to the package).
+ 
+ &#96;&#96;&#96;go
+ func ProcessData() {}  // exported, other packages can call this
+ func processData() {}  // unexported, package-private
+ &#96;&#96;&#96;
+ 
+ Your C# brain will want to reach for &#96;public&#96; and &#96;private&#96; keywords. They don't exist in Go. Case *is* the visibility modifier.
+ 
+ ### No Implicit Main Package
+ 
+ In C#, top-level statements let you skip the ceremony. In Go, you always need:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ func main() {
+     // your code
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;package main&#96; declaration tells Go this is an executable. The &#96;main()&#96; function is the entry point. No variation. No magic. Every Go executable looks like this.
+ 
+ ### File Organisation Isn't Free
+ 
+ In C#, namespaces and folders are loosely coupled. You can have a file in &#96;Services/&#96; that declares &#96;namespace MyApp.Models&#96;. Weird, but legal.
+ 
+ In Go, packages are directories. Every &#96;.go&#96; file in a directory must have the same &#96;package&#96; declaration. Want a different package? Different directory. No exceptions.
+ 
+ This feels restrictive at first. Then you realise it makes codebases significantly easier to navigate. You always know what package a file belongs to—just look at where it lives.
+ 
+ ## What We Haven't Covered
+ 
+ This is just orientation. We haven't touched:
+ 
+ - **How &#96;go.mod&#96; actually works** (next post)
+ - **How packages and imports differ from namespaces**
+ - **The &#96;internal&#96; directory convention**
+ - **Testing conventions**
+ - **The standard library**
+ 
+ All coming. But first, I wanted to establish the basic geography. Where code lives. How it builds. What tools you actually use.
+ 
+ ## The Honest Assessment
+ 
+ After a few weeks with Go's toolchain, here's my take:
+ 
+ **Better than C#:**
+ - Simplicity. One tool, minimal configuration.
+ - Cross-compilation. Effortless.
+ - Build speed. It's genuinely fast.
+ - Deployment. Single binary, no runtime.
+ 
+ **Worse than C#:**
+ - IDE support. Go has good tooling, but it's not Rider/Visual Studio level.
+ - Refactoring. The tools exist, but they're less sophisticated.
+ - Debug experience. It's fine, but not the polished F5 experience you're used to.
+ 
+ **Different, neither better nor worse:**
+ - Project structure. Go's conventions feel strange, then liberating.
+ - Package system. We'll cover this properly, but it's a genuine paradigm shift.
+ 
+ The toolchain isn't trying to be .NET. It's not trying to be "simple .NET" or ".NET but faster". It's a different philosophy: less configuration, more convention, explicit over implicit.
+ 
+ That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.
+ 
+ But there's method to the explicitness. And honestly? I'm starting to appreciate it.
+ 
+ ---
+ 
+ *Next up: go.mod in depth—dependency management without NuGet, and why it's both simpler and more opinionated than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: 279, lines removed: 1

```diff
@@ -1,1 +1,279 @@
- 
+ +++
+ title = "Goodbye .csproj, Hello go.mod"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "dependencies", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ Right, let's talk about dependencies. In .NET land, we've got NuGet, &#96;.csproj&#96; files, &#96;PackageReference&#96; elements, version ranges, transitive dependencies, and &#96;packages.lock.json&#96; if we're being careful. It's a mature ecosystem with excellent tooling.
+ 
+ Go does things differently. There's no NuGet. There's no package registry at all, actually. And that sounds mental until you understand why—and discover it works rather well.
+ 
+ ## The go.mod File
+ 
+ Every Go module has a &#96;go.mod&#96; file at its root. Here's a real one:
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ 
+ go 1.22
+ 
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ 
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+     github.com/gabriel-vasile/mimetype v1.4.2 // indirect
+     // ... more indirect dependencies
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down.
+ 
+ ### Module Declaration
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ &#96;&#96;&#96;
+ 
+ This is your module's identity—its import path. When someone writes &#96;import "github.com/yourname/yourproject/pkg/whatever"&#96;, Go knows where to find it because of this declaration.
+ 
+ Unlike a &#96;.csproj&#96; where the assembly name is mostly internal, this path is *the* identifier. Choose it thoughtfully.
+ 
+ ### Go Version
+ 
+ &#96;&#96;&#96;go
+ go 1.22
+ &#96;&#96;&#96;
+ 
+ This declares the minimum Go version required. It's not exactly the same as &#96;&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#96;—you're not compiling for a specific runtime. You're just saying "this code uses features from Go 1.22, don't try to build it with something older."
+ 
+ ### Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ &#96;&#96;&#96;
+ 
+ Here's where it gets interesting. These are your direct dependencies—the packages you actually import in your code.
+ 
+ Notice the format: &#96;module-path version&#96;. The version uses semantic versioning prefixed with &#96;v&#96;. No version ranges. No floating versions. Exactly this version, every time.
+ 
+ ### Indirect Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+ )
+ &#96;&#96;&#96;
+ 
+ The &#96;// indirect&#96; comment marks transitive dependencies—packages that your dependencies need, but you don't import directly. Go tracks these explicitly in &#96;go.mod&#96;.
+ 
+ ## No Central Registry
+ 
+ Here's the thing that confused me coming from NuGet: Go doesn't have a package registry.
+ 
+ NuGet has nuget.org. npm has npmjs.com. Go has... URLs.
+ 
+ When you &#96;go get github.com/gin-gonic/gin&#96;, Go literally fetches from GitHub. The module path isn't an identifier that maps to a registry—it's a resolvable URL (with some clever translation rules).
+ 
+ This means:
+ - No registry account needed to publish
+ - No central point of failure
+ - Dependencies are wherever their code lives
+ 
+ But also:
+ - No central search (though pkg.go.dev indexes public modules)
+ - No private registry without extra setup
+ - Version discovery is... different
+ 
+ ## Adding Dependencies
+ 
+ Here's the workflow comparison:
+ 
+ ### In .NET
+ 
+ &#96;&#96;&#96;bash
+ dotnet add package Newtonsoft.Json --version 13.0.3
+ &#96;&#96;&#96;
+ 
+ Or edit your &#96;.csproj&#96;:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="Newtonsoft.Json" Version="13.0.3" /&gt;
+ &#96;&#96;&#96;
+ 
+ Then &#96;dotnet restore&#96;.
+ 
+ ### In Go
+ 
+ &#96;&#96;&#96;bash
+ go get github.com/gin-gonic/gin@v1.9.1
+ &#96;&#96;&#96;
+ 
+ Or just import it in your code:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/gin-gonic/gin"
+ &#96;&#96;&#96;
+ 
+ Then run &#96;go mod tidy&#96;. Go will fetch the dependency, resolve versions, and update &#96;go.mod&#96; automatically.
+ 
+ That &#96;go mod tidy&#96; command is your friend. It adds missing dependencies, removes unused ones, and generally keeps your &#96;go.mod&#96; clean. I run it roughly as often as I save files.
+ 
+ ## Version Selection
+ 
+ Go's approach to version selection is refreshingly simple, and it took me a while to appreciate it.
+ 
+ ### The Problem With Version Ranges
+ 
+ In NuGet, you might declare:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="SomeLib" Version="[1.0, 2.0)" /&gt;
+ &#96;&#96;&#96;
+ 
+ Meaning "any version from 1.0 up to but not including 2.0." The actual version you get depends on what's available, what other packages need, and the resolver's algorithm.
+ 
+ This flexibility is powerful but creates problems:
+ - Different machines might resolve different versions
+ - Lock files become essential
+ - "Works on my machine" is often a version resolution issue
+ 
+ ### Go's Minimum Version Selection
+ 
+ Go uses something called Minimum Version Selection (MVS). The idea: given all the version constraints, pick the *minimum* version that satisfies everything.
+ 
+ If you require &#96;v1.9.1&#96; and a dependency requires &#96;v1.8.0&#96; of the same module, Go picks &#96;v1.9.1&#96;—the minimum version that satisfies both.
+ 
+ No ranges. No "latest compatible." Just: here are the minimums everyone needs, let's use those.
+ 
+ The result? Given the same &#96;go.mod&#96; and &#96;go.sum&#96; files, you'll always get exactly the same versions. No lock file randomness. No surprising upgrades.
+ 
+ ### The go.sum File
+ 
+ Speaking of which—&#96;go.sum&#96; is Go's integrity file:
+ 
+ &#96;&#96;&#96;
+ github.com/gin-gonic/gin v1.9.1 h1:4idEAncQnU5...
+ github.com/gin-gonic/gin v1.9.1/go.mod h1:RdK04...
+ &#96;&#96;&#96;
+ 
+ It contains cryptographic hashes of every dependency. If a module's contents don't match the recorded hash, the build fails.
+ 
+ Commit this file. It's your guarantee of reproducible builds.
+ 
+ ## Updating Dependencies
+ 
+ The version-pinning approach means updates are explicit:
+ 
+ &#96;&#96;&#96;bash
+ # Update a specific dependency
+ go get github.com/gin-gonic/gin@v1.10.0
+ 
+ # Update all dependencies to latest minor/patch
+ go get -u ./...
+ 
+ # Update all dependencies to latest (including major)
+ go get -u=patch ./...
+ &#96;&#96;&#96;
+ 
+ There's no equivalent to NuGet's floating versions. When you want an update, you ask for it specifically. Some find this tedious; I find it clarifying.
+ 
+ ## Major Versions Are Different Modules
+ 
+ Here's where Go does something clever (and initially bewildering).
+ 
+ In semantic versioning, major version bumps signal breaking changes. &#96;v2.0.0&#96; might have a completely different API from &#96;v1.9.0&#96;.
+ 
+ Go handles this by treating major versions as *different modules*:
+ 
+ &#96;&#96;&#96;go
+ // v1.x
+ import "github.com/go-redis/redis/v8"
+ 
+ // v9.x (yes, they jumped)
+ import "github.com/redis/go-redis/v9"
+ &#96;&#96;&#96;
+ 
+ The import path includes the major version. &#96;v2&#96;, &#96;v3&#96;, etc. are literally different modules.
+ 
+ This means:
+ - You can use v1 and v2 of the same library simultaneously (different import paths)
+ - Breaking changes are impossible to accidentally adopt
+ - Library authors must maintain separate module paths for major versions
+ 
+ It's awkward at first. Then you realise you've never had a build broken by an accidental major version upgrade.
+ 
+ ## The Comparison
+ 
+ | Aspect | NuGet/.csproj | Go Modules |
+ |--------|---------------|------------|
+ | Registry | Central (nuget.org) | Distributed (any URL) |
+ | Version syntax | Ranges allowed | Exact versions only |
+ | Resolution | Complex algorithm | Minimum Version Selection |
+ | Lock file | Optional but recommended | go.sum (hashes only) |
+ | Private packages | Private feeds | Various options (GOPROXY) |
+ | Major versions | Same package ID | Different module paths |
+ 
+ ## What Actually Trips You Up
+ 
+ After a few weeks, here's what caught me out:
+ 
+ ### Import Path Confusion
+ 
+ Your IDE might autocomplete an import as &#96;github.com/gin-gonic/gin/v2&#96; when you wanted &#96;v1&#96;. Check your imports when things don't compile.
+ 
+ ### Forgetting go mod tidy
+ 
+ Add an import, wonder why it doesn't work, realise you never fetched the dependency. &#96;go mod tidy&#96;. Learn to love it.
+ 
+ ### Private Repositories
+ 
+ Public modules "just work." Private repos need GOPROXY configuration or GOPRIVATE settings. It's not hard, but it's not automatic either.
+ 
+ ### Vendor Directory
+ 
+ Go can vendor dependencies—copy them into a &#96;vendor/&#96; directory in your project. Some teams mandate this for reproducibility. If you see a vendor directory, know that &#96;go build&#96; will use it by default.
+ 
+ ## The Honest Take
+ 
+ **Things I like better than NuGet:**
+ 
+ - Reproducibility. Same inputs, same outputs, always.
+ - No central registry dependency. Dependencies are just code at URLs.
+ - Major version handling. Breaking changes are structurally isolated.
+ - Simplicity. One file, explicit versions, done.
+ 
+ **Things I miss from NuGet:**
+ 
+ - Proper package search. pkg.go.dev is decent but not nuget.org.
+ - Private feeds. Azure Artifacts, MyGet, etc. are more polished than GOPROXY setup.
+ - .NET's tooling. &#96;dotnet add package&#96; with tab completion is lovely.
+ - Version ranges. Sometimes I *want* "latest patch version" and Go says no.
+ 
+ **Things that are just different:**
+ 
+ - Import paths being URLs. It's not better or worse, just a different model.
+ - go.sum vs lock files. Similar goal, different mechanism.
+ - The vendor directory. Some love it, some ignore it entirely.
+ 
+ ## The Philosophy
+ 
+ There's a reason Go's dependency management feels different: it was designed later, learning from problems with other systems.
+ 
+ The Ruby and Node ecosystems taught us that flexible version resolution leads to "works on my machine" nightmares. Go said: fine, no flexibility. Exact versions always.
+ 
+ The npm left-pad incident taught us that central registries are single points of failure. Go said: fine, no central registry. Your dependencies are wherever their source code lives.
+ 
+ Whether you prefer this philosophy is personal. But understanding *why* Go made these choices helps you work with the system rather than fighting it.
+ 
+ ---
+ 
+ *Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
I've created both blog posts. Let me verify the hugo server can build these correctly by checking for any issues, and also make sure the frontmatter is correct for the existing blog structure.

Let me check if there's a `series` taxonomy configured in Hugo, since I added that to the frontmatter. Let me look at the hugo.toml and the theme configuration.</details></think>

---

I've created both posts. Let me verify the Hugo build works with these new files and check if the `series` taxonomy needs configuration:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The build worked cleanly without any errors. Good - the posts are valid Hugo content. However, I did add a `series` parameter to the frontmatter that might not be configured in the theme. Let me check if the theme handles series or if I should remove that metadata.</details></think>

---

The Hugo build passed cleanly. Let me check if the series taxonomy is configured, and if not, I'll remove it from the frontmatter to keep things clean:

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs" • 6 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./content/posts/dotnet-to-go-modules.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-modules.md` | `*Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*` | L278 |
| `./content/posts/dotnet-to-go-toolchain.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-toolchain.md` | `This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.` | L11 |
| `./content/posts/dotnet-to-go-toolchain.md` | `That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.` | L195 |
| `./themes/PaperMod/layouts/partials/templates/opengraph.html` | `\{{- range .GetTerms "series" \}}` | L64 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The PaperMod theme does have support for the series taxonomy, so the frontmatter is valid. However, looking at the theme being used (`stepdev` in hugo.toml), let me check if that theme also supports it, or if PaperMod is just a secondary theme included.

Actually looking back at the hugo.toml, the active theme is `stepdev`, not `PaperMod`. Let me check what that theme supports.</details></think>

---

The PaperMod theme has series support, but the active theme is `stepdev`. Let me check if that theme handles series, or if I should just use tags instead:

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs/themes/stepdev" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The stepdev theme doesn't have series support. The series frontmatter won't break anything, but it also won't do anything useful. I should remove it to keep the posts clean and consistent with the existing blog posts. Let me update both posts to remove the series line.</details></think>

---

The `stepdev` theme doesn't use the series taxonomy, so I'll remove that from the frontmatter to keep the posts clean:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "tooling", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "dependencies", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, I've removed the series frontmatter. Let me verify the build still works and then present the results to the user.</details></think>

---

Let me verify the build still works and show you the final posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5
```

```
Build successful
-rw-r--r--  1 andycross  staff   6770 Dec  7 07:09 content/posts/invisible-models-ios-3d-debugging.md
-rw-r--r--  1 andycross  staff   7161 Dec  3 07:03 content/posts/seven-dollars-and-twenty-five-years.md
-rw-r--r--  1 andycross  staff   8701 Dec 28 20:16 content/posts/streaming-json-partial-parser.md
-rw-r--r--  1 andycross  staff  25890 Dec  2 09:41 content/posts/three-js-scenes-from-conversation.md
-rw-r--r--  1 andycross  staff  14586 Dec 25 08:53 content/posts/worklet-crashes-ios-force-quit.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Hmm, the new posts don't show in that listing. Let me check the full list to make sure they're there.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md</summary>

```bash
ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md
```

```
-rw-r--r--  1 andycross  staff  9548 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff  8133 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The posts exist. The `-5` in my tail command just didn't show them because they alphabetically come before the ones shown. Let me show the user a preview of the blog locally.</details></think>

---

Both posts are created and the build passes. Here's what I've created:

## New Series: C# to Go

### Post 1: "You Know .NET, Now Meet the Go Toolchain"
`content/posts/dotnet-to-go-toolchain.md`

Covers:
- The single `go` command vs .NET's tooling ecosystem
- Where code lives (GOPATH history → modules)
- The build model differences (machine code vs IL/JIT)
- Cross-compilation
- Project structure comparison
- Early gotchas: case sensitivity, package declarations, file organisation

### Post 2: "Goodbye .csproj, Hello go.mod"  
`content/posts/dotnet-to-go-modules.md`

Covers:
- The `go.mod` file structure
- No central registry—dependencies are URLs
- Adding dependencies (`go get` vs `dotnet add package`)
- Minimum Version Selection vs NuGet's resolution algorithm
- The `go.sum` file
- Major versions as different modules
- Practical gotchas and honest comparison

Both posts follow the tone you specified:
- **UK English** throughout (organised, behaviour, colour)
- **Techie informal** voice with first-person plural
- **Fair to both languages**—no tribal nonsense
- **Starts with real problems**, not theory
- **Honest assessments** of what's better, worse, and just different
- **Tables for genuine comparisons**
- **Runnable code examples**

Want me to start the local Hugo server so you can preview them?

---

_**User (2025-12-28 20:16Z)**_

Nope, I want to start on the next ones:



Phase 2 Types & Data

Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the next 5 posts in the series, covering Phase 2: Types & Data. Let me create all five posts following the same tone and style as the first two posts and the existing blog content.

The posts are:
1. Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
2. Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
3. Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
4. The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
5. No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

I'll write all five posts now with the same tone: UK English, techie informal, first person plural, honest about both languages, starts with real problems.</details></think>

---

I'll create all five posts for Phase 2: Types & Data. Let me write them all now.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-structs.md</summary>

**Chunk 1**
Lines added: 276, lines removed: 1

```diff
@@ -1,1 +1,276 @@
- 
+ +++
+ title = "Your Class Is Now a Struct (And That's Fine)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Here's something that'll feel wrong for about a week: Go doesn't have classes. Not "Go has classes but calls them something else"—it genuinely doesn't have them. No inheritance. No class hierarchies. No &#96;virtual&#96; or &#96;override&#96;. No &#96;protected&#96;.
+ 
+ If you've spent years designing C# class hierarchies, this feels like having a limb removed. Then you start writing Go code and realise... you don't actually miss it that much.
+ 
+ Let's dig into why.
+ 
+ ## The Basic Translation
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     public string Name { get; set; }
+     public string Email { get; set; }
+     public DateTime CreatedAt { get; set; }
+     
+     public User(string name, string email)
+     {
+         Name = name;
+         Email = email;
+         CreatedAt = DateTime.UtcNow;
+     }
+     
+     public string DisplayName() =&gt; $"{Name} &lt;{Email}&gt;";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     CreatedAt time.Time
+ }
+ 
+ func NewUser(name, email string) User {
+     return User{
+         Name:      name,
+         Email:     email,
+         CreatedAt: time.Now().UTC(),
+     }
+ }
+ 
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ A few things to notice:
+ 
+ 1. **No constructor syntax**—&#96;NewUser&#96; is just a function. By convention, Go uses &#96;NewX&#96; functions, but there's nothing special about them.
+ 2. **Methods are declared separately**—that &#96;func (u User)&#96; syntax attaches a method to the type.
+ 3. **No access modifiers**—capitalisation controls visibility (covered in the next post).
+ 4. **Fields are just fields**—no properties, no getters/setters.
+ 
+ ## Value Semantics by Default
+ 
+ Here's the big one. In C#, classes are reference types. When you pass a &#96;User&#96; to a method, you're passing a reference. Modifications affect the original.
+ 
+ &#96;&#96;&#96;csharp
+ void UpdateEmail(User user)
+ {
+     user.Email = "new@example.com";  // modifies the original
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, structs are value types by default. Pass a struct, you're passing a copy.
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u User) {
+     u.Email = "new@example.com"  // modifies the copy, original unchanged
+ }
+ &#96;&#96;&#96;
+ 
+ If you want reference semantics, you use pointers explicitly:
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u *User) {
+     u.Email = "new@example.com"  // modifies the original via pointer
+ }
+ &#96;&#96;&#96;
+ 
+ This explicitness is jarring at first. In C#, the type itself determines whether you get value or reference semantics (&#96;struct&#96; vs &#96;class&#96;). In Go, the *calling convention* determines it. Same type, different behaviour depending on whether you use &#96;User&#96; or &#96;*User&#96;.
+ 
+ ### When to Use Pointers
+ 
+ The rule of thumb:
+ 
+ | Scenario | Use |
+ |----------|-----|
+ | Method modifies the receiver | &#96;*User&#96; (pointer receiver) |
+ | Struct is large | &#96;*User&#96; (avoid copy overhead) |
+ | You need nil to mean "absent" | &#96;*User&#96; (pointers can be nil) |
+ | Small, immutable data | &#96;User&#96; (value) |
+ | You want copy-on-pass safety | &#96;User&#96; (value) |
+ 
+ In practice, most methods use pointer receivers. It's more consistent, and you don't have to think about whether each method modifies state.
+ 
+ &#96;&#96;&#96;go
+ // Pointer receiver - conventional for most methods
+ func (u *User) UpdateEmail(email string) {
+     u.Email = email
+ }
+ 
+ // Value receiver - acceptable for pure getters on small structs
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Composition Over Inheritance
+ 
+ Go doesn't have inheritance. Full stop. No &#96;class Admin : User&#96;. No &#96;protected&#96; members. No &#96;virtual&#96; methods.
+ 
+ Instead, Go has embedding—a form of composition that feels almost like inheritance but isn't.
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+     Age  int
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ type Employee struct {
+     Person          // embedded - not a field name, just the type
+     EmployeeID string
+     Department string
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;Employee&#96; has all of &#96;Person&#96;'s fields and methods:
+ 
+ &#96;&#96;&#96;go
+ emp := Employee{
+     Person:     Person{Name: "Alice", Age: 30},
+     EmployeeID: "E123",
+     Department: "Engineering",
+ }
+ 
+ fmt.Println(emp.Name)    // "Alice" - promoted from Person
+ fmt.Println(emp.Greet()) // "Hello, I'm Alice" - method promoted too
+ &#96;&#96;&#96;
+ 
+ This *looks* like inheritance, but it's not:
+ 
+ - No polymorphism—you can't pass an &#96;Employee&#96; where a &#96;Person&#96; is expected
+ - No &#96;override&#96;—if &#96;Employee&#96; defines its own &#96;Greet()&#96;, it shadows &#96;Person.Greet()&#96;
+ - The embedded type is still accessible—&#96;emp.Person.Name&#96; works
+ 
+ ### When You'll Miss Inheritance
+ 
+ Let's be honest: sometimes you'll miss it.
+ 
+ **Template Method Pattern**—In C#, you'd have a base class with a &#96;virtual&#96; method that subclasses override. Go has no direct equivalent. You use interfaces and composition instead, which works but feels more verbose.
+ 
+ **Protected Members**—There's no "visible to derived types" concept. Everything is either exported (public) or unexported (package-private). For library design, this can be limiting.
+ 
+ **Deep Hierarchies**—If your C# design has &#96;Animal -&gt; Mammal -&gt; Dog -&gt; Labrador&#96;, Go will make you rethink that structure entirely. Usually for the better, but the rethinking takes effort.
+ 
+ ## Interfaces Are Implicit
+ 
+ Here's where Go gets genuinely interesting. Interfaces are satisfied implicitly—no &#96;implements&#96; keyword.
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IGreeter
+ {
+     string Greet();
+ }
+ 
+ public class Person : IGreeter  // explicit implementation
+ {
+     public string Name { get; set; }
+     public string Greet() =&gt; $"Hello, I'm {Name}";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Greeter interface {
+     Greet() string
+ }
+ 
+ type Person struct {
+     Name string
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ // Person now implements Greeter - no declaration needed
+ &#96;&#96;&#96;
+ 
+ If a type has the methods an interface requires, it implements that interface. Period. No ceremony.
+ 
+ This has profound implications:
+ 
+ 1. **You can define interfaces after the fact**—create an interface that existing types already satisfy
+ 2. **Small interfaces are encouraged**—the standard library is full of one-method interfaces
+ 3. **Testing is trivial**—any type with the right methods can be substituted
+ 
+ The &#96;io.Reader&#96; interface is the canonical example:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ &#96;&#96;&#96;
+ 
+ One method. But files, network connections, byte buffers, HTTP response bodies—they all implement it. Polymorphism without inheritance.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Classes | Go Structs |
+ |--------|-----------|------------|
+ | Reference/value | Reference by default | Value by default |
+ | Inheritance | Full class inheritance | Embedding (composition) |
+ | Interface implementation | Explicit (&#96;implements&#96;) | Implicit (duck typing) |
+ | Constructors | Special syntax | Convention (&#96;NewX&#96; functions) |
+ | Access modifiers | &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96; | Exported (capital) or unexported |
+ | Polymorphism | Inheritance + interfaces | Interfaces only |
+ | Method declaration | Inside class body | Separate, attached to type |
+ 
+ ## What I Actually Miss
+ 
+ After a few months, here's my honest assessment:
+ 
+ **Don't miss at all:**
+ - Complex inheritance hierarchies (they were usually a mistake anyway)
+ - The &#96;virtual&#96;/&#96;override&#96; dance
+ - Explicit interface implementation for conflicts
+ 
+ **Sometimes miss:**
+ - &#96;protected&#96; for carefully designed extension points
+ - Abstract classes with partial implementations
+ - The template method pattern (can be done in Go, just clunkier)
+ 
+ **Actively prefer Go's approach:**
+ - Implicit interface satisfaction
+ - Explicit value vs reference choice at call site
+ - Composition via embedding
+ - Small, focused interfaces
+ 
+ The shift from "design your class hierarchy upfront" to "compose small pieces and let interfaces emerge" takes adjustment. But it tends to produce simpler code.
+ 
+ ## The Practical Bit
+ 
+ If you're converting C# code to Go, here's the process I use:
+ 
+ 1. **Start with structs for data**—no methods yet, just fields
+ 2. **Add methods as needed**—use pointer receivers by default
+ 3. **Extract interfaces late**—when you need polymorphism, create the smallest interface that works
+ 4. **Embed for code reuse**—not "inheritance", just "I want those fields and methods too"
+ 5. **Resist the urge to build hierarchies**—if you're thinking "base class", stop and reconsider
+ 
+ The code ends up flatter. More types, shallower relationships. It's different, not worse.
+ 
+ ---
+ 
+ *Next up: visibility and the death of properties—why Go uses capitalisation instead of access modifiers, and why you'll stop missing getters and setters faster than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-visibility.md</summary>

**Chunk 1**
Lines added: 299, lines removed: 1

```diff
@@ -1,1 +1,299 @@
- 
+ +++
+ title = "Where Did My Properties Go?"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Coming from C#, one of the first things you'll notice is that Go structs look... naked. Where are the &#96;{ get; set; }&#96; blocks? Where's &#96;private&#96; and &#96;public&#96;? How do you encapsulate anything?
+ 
+ The answer involves capitalisation, a complete absence of properties, and a philosophy that might make you uncomfortable before it makes you productive.
+ 
+ ## Visibility via Capitalisation
+ 
+ Go has exactly two visibility levels:
+ 
+ - **Exported** (capital first letter): visible outside the package
+ - **Unexported** (lowercase first letter): visible only within the package
+ 
+ That's it. No &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96;. Just case.
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ type User struct {
+     Name  string    // Exported - other packages can access
+     Email string    // Exported
+     hash  string    // unexported - only this package can access
+ }
+ 
+ func (u *User) SetPassword(password string) {
+     u.hash = hashPassword(password)  // can access hash internally
+ }
+ 
+ func hashPassword(p string) string {  // unexported function
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ From another package:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import "myapp/user"
+ 
+ func main() {
+     u := user.User{Name: "Alice", Email: "alice@example.com"}
+     u.SetPassword("secret")  // works - SetPassword is exported
+     
+     // u.hash = "something"  // won't compile - hash is unexported
+ }
+ &#96;&#96;&#96;
+ 
+ ### The Mental Adjustment
+ 
+ In C#, visibility is per-member and you have fine-grained control. In Go, the package is the unit of encapsulation.
+ 
+ | C# | Go Equivalent |
+ |----|---------------|
+ | &#96;public&#96; | Capitalised name |
+ | &#96;private&#96; | Lowercase name |
+ | &#96;protected&#96; | Doesn't exist |
+ | &#96;internal&#96; | Lowercase (package = assembly, roughly) |
+ | &#96;private protected&#96; | Doesn't exist |
+ 
+ The lack of &#96;protected&#96; is the big one. There's no "visible to derived types" because there are no derived types. Embedding doesn't grant special access—embedded types can only access their own unexported members.
+ 
+ ## No Properties, Just Fields
+ 
+ Here's the controversial bit. Go doesn't have properties. No getters. No setters. Just fields.
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     private string _email;
+     
+     public string Email
+     {
+         get =&gt; _email;
+         set
+         {
+             ValidateEmail(value);
+             _email = value.ToLowerInvariant();
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the idiomatic approach is... don't do that:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Email string
+ }
+ &#96;&#96;&#96;
+ 
+ Wait, what about validation? What about normalisation?
+ 
+ Go's answer: if you need to do something when a value changes, make a method for it:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     email string  // unexported
+ }
+ 
+ func (u *User) Email() string {
+     return u.email
+ }
+ 
+ func (u *User) SetEmail(email string) error {
+     if !isValidEmail(email) {
+         return errors.New("invalid email")
+     }
+     u.email = strings.ToLower(email)
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is more verbose than C# properties. Undeniably. You write more code.
+ 
+ But here's the thing: now the call site makes it obvious that something's happening.
+ 
+ &#96;&#96;&#96;go
+ // Caller knows this might fail
+ err := user.SetEmail("alice@example.com")
+ 
+ // vs a property that silently transforms or might panic
+ user.Email = "alice@example.com"  // what does this actually do?
+ &#96;&#96;&#96;
+ 
+ ### When to Use Bare Fields
+ 
+ The Go community's guidance is: **export fields when they're truly just data**.
+ 
+ &#96;&#96;&#96;go
+ // Config is just data, exported fields are fine
+ type Config struct {
+     Host     string
+     Port     int
+     Timeout  time.Duration
+     Debug    bool
+ }
+ 
+ // User has invariants to maintain, unexport fields + methods
+ type User struct {
+     id        int64
+     email     string
+     createdAt time.Time
+ }
+ &#96;&#96;&#96;
+ 
+ This feels wrong to C# developers who've been taught that bare fields are always bad. But Go's standard library is full of exported fields:
+ 
+ &#96;&#96;&#96;go
+ // From net/http
+ type Request struct {
+     Method string
+     URL    *url.URL
+     Header Header
+     Body   io.ReadCloser
+     // ... many more exported fields
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;http.Request&#96; struct has exported fields because that's what makes sense. You read and modify them directly. No ceremony.
+ 
+ ## The "Getter/Setter" Convention
+ 
+ When you do need accessor methods, Go has a naming convention that'll trip you up:
+ 
+ &#96;&#96;&#96;go
+ // C# instinct - WRONG in Go
+ func (u *User) GetEmail() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ 
+ // Go convention - CORRECT
+ func (u *User) Email() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ &#96;&#96;&#96;
+ 
+ Notice: the getter is just &#96;Email()&#96;, not &#96;GetEmail()&#96;. The setter keeps the &#96;Set&#96; prefix.
+ 
+ This feels inconsistent until you see it in use:
+ 
+ &#96;&#96;&#96;go
+ email := user.Email()          // reads like accessing a value
+ user.SetEmail("new@example.com")  // reads like an action
+ &#96;&#96;&#96;
+ 
+ The asymmetry is intentional. Getting a value should feel like accessing a value. Setting a value should look like you're doing something.
+ 
+ ## The Package as Encapsulation Boundary
+ 
+ Here's where Go's model actually shines: the package is the natural unit of encapsulation.
+ 
+ In C#, you often have one class per file, and you think about encapsulation at the class level. You might have &#96;internal&#96; methods that are really just for one other class in the same assembly.
+ 
+ In Go, all files in a package share the same namespace. Unexported identifiers are visible across all files in the package:
+ 
+ &#96;&#96;&#96;go
+ // user/user.go
+ package user
+ 
+ type User struct {
+     email string
+ }
+ 
+ // user/validation.go  
+ package user
+ 
+ func validateUser(u *User) error {
+     // Can access u.email - same package
+     if u.email == "" {
+         return errors.New("email required")
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This encourages small, focused packages where the implementation details can be shared freely within the package boundary, but the public API is carefully controlled.
+ 
+ ### The &#96;internal&#96; Directory
+ 
+ Go has one more visibility mechanism: the &#96;internal&#96; directory convention.
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── internal/
+ │   └── auth/
+ │       └── token.go    // only importable by myproject and its children
+ ├── api/
+ │   └── handler.go      // can import internal/auth
+ └── main.go             // can import internal/auth
+ &#96;&#96;&#96;
+ 
+ Packages under &#96;internal/&#96; can only be imported by packages rooted at the parent of &#96;internal&#96;. This gives you "internal to this module" visibility without language keywords.
+ 
+ ## Struct Tags
+ 
+ One thing C# attributes do that Go handles differently: metadata on fields. Go uses struct tags:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID        int64     &#96;json:"id" db:"user_id"&#96;
+     Email     string    &#96;json:"email" db:"email" validate:"required,email"&#96;
+     CreatedAt time.Time &#96;json:"created_at" db:"created_at"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ These are just strings—the runtime and libraries parse them by convention. The &#96;json&#96; package looks for &#96;json:&#96; tags. Database libraries look for &#96;db:&#96; tags. Validation libraries look for &#96;validate:&#96; tags.
+ 
+ It's less type-safe than C# attributes (no compile-time checking of tag names), but it's simple and works.
+ 
+ ## The Honest Take
+ 
+ After months of Go, here's where I've landed:
+ 
+ **Things I like better than C#:**
+ 
+ - **Simplicity of the model**. Two visibility levels, no exceptions.
+ - **Package-level encapsulation**. Encourages cohesive packages.
+ - **Explicit methods over magic properties**. Call sites are clear about what's happening.
+ - **The &#96;internal&#96; convention**. Solves the "internal to this module" case elegantly.
+ 
+ **Things I miss from C#:**
+ 
+ - **&#96;protected&#96; for library extension**. Sometimes you want "derived types only" access.
+ - **Computed properties**. &#96;user.FullName&#96; is nicer than &#96;user.FullName()&#96; when it's genuinely just a computed value.
+ - **Init-only setters**. Go has no equivalent to &#96;init&#96; for construction-time-only setting.
+ - **Attributes**. Struct tags work but aren't type-safe.
+ 
+ **Things that are just different:**
+ 
+ - **Capitalisation visibility**. Weird for a week, then invisible.
+ - **No &#96;get&#96;/&#96;set&#96; syntax**. More typing, but more explicit.
+ - **Fields vs properties**. Go trusts you to know when bare fields are appropriate.
+ 
+ ## Practical Advice
+ 
+ 1. **Start with exported fields for DTOs**. Structs that just carry data (configs, API responses, database rows) don't need method accessors.
+ 
+ 2. **Use unexported fields when invariants matter**. If setting a value could break something, make it unexported and provide methods.
+ 
+ 3. **Name getters without &#96;Get&#96;**. It's &#96;Email()&#96;, not &#96;GetEmail()&#96;.
+ 
+ 4. **Return errors from setters that validate**. Don't panic, don't silently fail.
+ 
+ 5. **Keep packages small and focused**. The package boundary is your encapsulation tool—make packages that are cohesive enough that sharing unexported identifiers makes sense.
+ 
+ 6. **Use &#96;internal/&#96; for module-private packages**. Better than making everything unexported in a shared package.
+ 
+ The shift from "everything should have properties" to "fields are fine, methods when needed" takes time. But once you stop fighting it, Go code ends up pleasantly straightforward.
+ 
+ ---
+ 
+ *Next up: generics in Go—what we got in Go 1.18, where the gaps are, and why you'll need to adjust your expectations if you're used to C#'s mature generics.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generics.md</summary>

**Chunk 1**
Lines added: 331, lines removed: 1

```diff
@@ -1,1 +1,331 @@
- 
+ +++
+ title = "Generics: Late to the Party"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "generics", "csharp"]
+ +++
+ 
+ Go shipped generics in version 1.18 (March 2022). C# has had them since 2.0 (November 2005). That's a seventeen-year head start, and it shows.
+ 
+ If you're coming from C# expecting the same power and flexibility, you'll be disappointed. Go's generics are deliberately constrained—they solve the common cases but won't let you build the same abstractions you're used to.
+ 
+ Let's look at what we've got, what's missing, and whether that matters.
+ 
+ ## The Basic Syntax
+ 
+ A generic function in Go:
+ 
+ &#96;&#96;&#96;go
+ func Map[T, U any](items []T, f func(T) U) []U {
+     result := make([]U, len(items))
+     for i, item := range items {
+         result[i] = f(item)
+     }
+     return result
+ }
+ 
+ // Usage
+ numbers := []int{1, 2, 3, 4}
+ squared := Map(numbers, func(n int) int { return n * n })
+ &#96;&#96;&#96;
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public static IEnumerable&lt;U&gt; Map&lt;T, U&gt;(IEnumerable&lt;T&gt; items, Func&lt;T, U&gt; f)
+ {
+     foreach (var item in items)
+         yield return f(item);
+ }
+ 
+ // Usage  
+ var numbers = new[] { 1, 2, 3, 4 };
+ var squared = Map(numbers, n =&gt; n * n);
+ &#96;&#96;&#96;
+ 
+ The syntax is different but the concept is familiar. Type parameters go in square brackets in Go (&#96;[T, U any]&#96;) rather than angle brackets (&#96;&lt;T, U&gt;&#96;). The &#96;any&#96; is a constraint—more on that shortly.
+ 
+ ## Constraints
+ 
+ Here's where Go's approach diverges. In C#, you constrain type parameters with &#96;where&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ public T Max&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;
+ {
+     return a.CompareTo(b) &gt; 0 ? a : b;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, constraints are interfaces:
+ 
+ &#96;&#96;&#96;go
+ func Max[T cmp.Ordered](a, b T) T {
+     if a &gt; b {
+         return a
+     }
+     return b
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;cmp.Ordered&#96; constraint (from the standard library) allows the &#96;&gt;&#96; operator. Without it, Go wouldn't know that &#96;T&#96; supports comparison.
+ 
+ ### Built-in Constraints
+ 
+ Go provides some standard constraints in the &#96;constraints&#96; and &#96;cmp&#96; packages:
+ 
+ | Constraint | What it allows |
+ |-----------|----------------|
+ | &#96;any&#96; | Any type (alias for &#96;interface{}&#96;) |
+ | &#96;comparable&#96; | Types that support &#96;==&#96; and &#96;!=&#96; |
+ | &#96;cmp.Ordered&#96; | Types that support &#96;&lt;&#96;, &#96;&gt;&#96;, &#96;&lt;=&#96;, &#96;&gt;=&#96; |
+ | &#96;constraints.Integer&#96; | All integer types |
+ | &#96;constraints.Float&#96; | All float types |
+ | &#96;constraints.Signed&#96; | Signed integers |
+ | &#96;constraints.Unsigned&#96; | Unsigned integers |
+ 
+ ### Custom Constraints
+ 
+ You can define your own constraints as interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Number interface {
+     ~int | ~int64 | ~float64
+ }
+ 
+ func Sum[T Number](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ That &#96;~int&#96; syntax means "any type whose underlying type is int". This lets you include type aliases and defined types, not just the primitive itself.
+ 
+ ## Generic Types
+ 
+ Generic structs work as you'd expect:
+ 
+ &#96;&#96;&#96;go
+ type Stack[T any] struct {
+     items []T
+ }
+ 
+ func (s *Stack[T]) Push(item T) {
+     s.items = append(s.items, item)
+ }
+ 
+ func (s *Stack[T]) Pop() (T, bool) {
+     if len(s.items) == 0 {
+         var zero T
+         return zero, false
+     }
+     item := s.items[len(s.items)-1]
+     s.items = s.items[:len(s.items)-1]
+     return item, true
+ }
+ 
+ // Usage
+ stack := &amp;Stack[string]{}
+ stack.Push("hello")
+ value, ok := stack.Pop()
+ &#96;&#96;&#96;
+ 
+ ## Where the Gaps Hurt
+ 
+ Right, here's the honest bit. Go's generics are limited in ways that'll frustrate you coming from C#.
+ 
+ ### No Generic Methods on Non-Generic Types
+ 
+ In C#, you can do this:
+ 
+ &#96;&#96;&#96;csharp
+ public class Converter
+ {
+     public T Convert&lt;T&gt;(string value) { ... }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, you can't add a generic method to a non-generic type. This doesn't compile:
+ 
+ &#96;&#96;&#96;go
+ type Converter struct{}
+ 
+ // ERROR: method must have no type parameters
+ func (c Converter) Convert[T any](value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ You have to use a generic function instead:
+ 
+ &#96;&#96;&#96;go
+ func Convert[T any](c Converter, value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ It works, but it's clunkier and doesn't chain as nicely.
+ 
+ ### No Specialisation
+ 
+ C# lets you specialise behaviour based on type arguments (with runtime checks or partial specialisation). Go doesn't. You can't do:
+ 
+ &#96;&#96;&#96;go
+ func Process[T any](item T) {
+     // Can't check "if T is string, do this"
+     // Can't have different implementations for different T
+ }
+ &#96;&#96;&#96;
+ 
+ Everything must work uniformly for all types that satisfy the constraint.
+ 
+ ### No Variance
+ 
+ C# has covariance (&#96;out T&#96;) and contravariance (&#96;in T&#96;) for generic interfaces. Go has neither. A &#96;Stack[Dog]&#96; is not a &#96;Stack[Animal]&#96;, even if &#96;Dog&#96; implements &#96;Animal&#96;. Ever.
+ 
+ ### No Arithmetic Constraints (Sort Of)
+ 
+ Want to write a generic sum function? You need to constrain to types that support &#96;+&#96;:
+ 
+ &#96;&#96;&#96;go
+ func Sum[T constraints.Integer | constraints.Float](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ This works, but you can't easily extend it to custom numeric types. The constraint system is based on underlying types, not operators.
+ 
+ ### No Default Type Arguments
+ 
+ C# has:
+ 
+ &#96;&#96;&#96;csharp
+ public class Cache&lt;TKey, TValue, TSerializer = JsonSerializer&gt; { }
+ &#96;&#96;&#96;
+ 
+ Go doesn't. Every type parameter must be specified at use sites (though type inference helps for functions).
+ 
+ ## The Standard Library's Generics
+ 
+ Go 1.21+ added generic functions to the standard library. These are genuinely useful:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "maps"
+     "slices"
+ )
+ 
+ // Slices
+ numbers := []int{3, 1, 4, 1, 5, 9}
+ slices.Sort(numbers)
+ found := slices.Contains(numbers, 4)
+ maxVal := slices.Max(numbers)
+ 
+ // Maps  
+ m := map[string]int{"a": 1, "b": 2}
+ keys := maps.Keys(m)    // iterator over keys
+ values := maps.Values(m) // iterator over values
+ maps.Clone(m)           // shallow copy
+ &#96;&#96;&#96;
+ 
+ Before generics, you'd write these loops by hand every time. Now they're type-safe and reusable.
+ 
+ ## When You'll Feel the Gaps
+ 
+ **Building Fluent APIs**
+ 
+ In C#, you might build a fluent configuration API with generic methods:
+ 
+ &#96;&#96;&#96;csharp
+ builder
+     .WithOption&lt;ConnectionOptions&gt;(opts =&gt; opts.Timeout = 30)
+     .WithOption&lt;RetryOptions&gt;(opts =&gt; opts.MaxRetries = 3)
+     .Build();
+ &#96;&#96;&#96;
+ 
+ This pattern is harder in Go because you can't have generic methods. You'd need a different approach—probably top-level functions or a less fluent API.
+ 
+ **Repository Patterns**
+ 
+ The classic &#96;IRepository&lt;T&gt;&#96; with &#96;Find&lt;TKey&gt;&#96; is awkward:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work - can't have generic method
+ type Repository[T any] interface {
+     Find[K comparable](id K) (T, error)  // ERROR
+ }
+ 
+ // You'd need this instead
+ type Repository[T any, K comparable] interface {
+     Find(id K) (T, error)
+ }
+ &#96;&#96;&#96;
+ 
+ Two type parameters instead of one, threaded through everything.
+ 
+ **LINQ-style Operations**
+ 
+ C# LINQ chains beautifully with generic extension methods:
+ 
+ &#96;&#96;&#96;csharp
+ items.Where(x =&gt; x.Active).Select(x =&gt; x.Name).OrderBy(x =&gt; x).ToList();
+ &#96;&#96;&#96;
+ 
+ Go has no extension methods. You'd write:
+ 
+ &#96;&#96;&#96;go
+ result := slices.Sorted(
+     slices.Collect(
+         Map(
+             Filter(items, func(x Item) bool { return x.Active }),
+             func(x Item) string { return x.Name },
+         ),
+     ),
+ )
+ &#96;&#96;&#96;
+ 
+ Functional, but not as elegant.
+ 
+ ## The Practical Advice
+ 
+ After working with Go's generics, here's how I use them:
+ 
+ **Do use generics for:**
+ - Data structures (stacks, queues, trees, caches)
+ - Collection utilities (map, filter, reduce)
+ - Type-safe wrappers around &#96;interface{}&#96;
+ - Eliminating repetitive code across similar types
+ 
+ **Don't use generics for:**
+ - Everything. Go's non-generic code is often clearer.
+ - Patterns that require generic methods (rethink the design)
+ - Complex type relationships (the constraint syntax gets unwieldy)
+ 
+ **Accept these limitations:**
+ - Write more concrete types, fewer abstractions
+ - Use interfaces for polymorphism, generics for type safety
+ - Sometimes duplicate code is clearer than a generic contortion
+ 
+ ## The Honest Assessment
+ 
+ | Aspect | C# Generics | Go Generics |
+ |--------|------------|-------------|
+ | Maturity | 20 years | 3 years |
+ | Generic methods | Yes | Only on generic types |
+ | Variance | Full (in/out) | None |
+ | Constraints | Rich (interfaces, new(), class, struct) | Interfaces only |
+ | Specialisation | Partial (with runtime checks) | None |
+ | Standard library | Extensive | Growing |
+ 
+ Go's generics are *good enough* for most real-world needs. They eliminate the pre-1.18 pain of &#96;interface{}&#96; everywhere or code generation. But they're not trying to match C#'s power.
+ 
+ The Go team explicitly chose to ship a simpler system first, with room to expand. Whether the gaps will be filled or the community will adapt around them remains to be seen.
+ 
+ For now? Lower your expectations, use generics where they help, and don't twist yourself into knots trying to replicate C# patterns that don't translate well.
+ 
+ ---
+ 
+ *Next up: nil in Go versus nullable reference types in C#—two different approaches to the billion dollar mistake, and why both languages still get caught out.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-nil.md</summary>

**Chunk 1**
Lines added: 312, lines removed: 1

```diff
@@ -1,1 +1,312 @@
- 
+ +++
+ title = "The Million Dollar Mistake, Differently"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "nil", "csharp"]
+ +++
+ 
+ Tony Hoare called null references his "billion dollar mistake." Both C# and Go inherited some form of this mistake, but they've evolved to handle it differently. Neither solution is perfect.
+ 
+ If you're coming from C# 8+ with nullable reference types enabled, Go's approach will feel like stepping backwards. And in some ways, it is. But there's nuance here.
+ 
+ ## The C# Journey
+ 
+ C# started with null everywhere. Any reference type could be null, always. This gave us decades of &#96;NullReferenceException&#96; at runtime.
+ 
+ Then came nullable reference types (NRT) in C# 8:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ 
+ public class User
+ {
+     public string Name { get; set; }        // Non-nullable - compiler warns if null
+     public string? MiddleName { get; set; } // Nullable - explicitly marked
+ }
+ 
+ public void Process(User user)
+ {
+     Console.WriteLine(user.Name.Length);    // Safe - compiler knows it's not null
+     Console.WriteLine(user.MiddleName.Length); // Warning! Might be null
+     
+     // Must check first
+     if (user.MiddleName != null)
+     {
+         Console.WriteLine(user.MiddleName.Length); // Now safe
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler tracks nullability and warns you. It's not perfect—it's still a warning system, not a guarantee—but it catches loads of bugs at compile time.
+ 
+ ## Go's Approach: Everything Is Potentially Nil (But Different)
+ 
+ Go has &#96;nil&#96;, and it works differently depending on the type. Here's the landscape:
+ 
+ | Type | Can be nil? | Zero value |
+ |------|-------------|------------|
+ | Pointers (&#96;*T&#96;) | Yes | &#96;nil&#96; |
+ | Slices | Yes | &#96;nil&#96; (but usable!) |
+ | Maps | Yes | &#96;nil&#96; (but NOT usable for writes) |
+ | Channels | Yes | &#96;nil&#96; |
+ | Interfaces | Yes | &#96;nil&#96; |
+ | Functions | Yes | &#96;nil&#96; |
+ | Structs | No | Zero struct |
+ | Primitives | No | 0, "", false, etc. |
+ 
+ Let's dig into the weird bits.
+ 
+ ### Nil Slices Are Fine
+ 
+ This is the first surprise. A nil slice is usable:
+ 
+ &#96;&#96;&#96;go
+ var s []int    // nil slice
+ len(s)         // 0 - works fine
+ cap(s)         // 0 - works fine
+ s = append(s, 1, 2, 3)  // works fine! Now s is [1, 2, 3]
+ 
+ for _, v := range s { } // works even when nil (iterates zero times)
+ &#96;&#96;&#96;
+ 
+ A nil slice isn't "no slice"—it's an empty slice with no backing array. Most operations work. This is intentional and idiomatic.
+ 
+ ### Nil Maps Are NOT Fine
+ 
+ But a nil map will bite you:
+ 
+ &#96;&#96;&#96;go
+ var m map[string]int  // nil map
+ 
+ v := m["key"]         // works! Returns zero value (0)
+ _, ok := m["key"]     // works! ok is false
+ 
+ m["key"] = 1          // PANIC: assignment to entry in nil map
+ &#96;&#96;&#96;
+ 
+ Reading from a nil map works (returns zero values). Writing to a nil map panics. This inconsistency catches everyone at least once.
+ 
+ Always initialise maps:
+ 
+ &#96;&#96;&#96;go
+ m := make(map[string]int)
+ // or
+ m := map[string]int{}
+ &#96;&#96;&#96;
+ 
+ ### The Interface Nil Trap
+ 
+ This one is genuinely confusing. An interface can be nil in two ways:
+ 
+ &#96;&#96;&#96;go
+ type Writer interface {
+     Write([]byte) (int, error)
+ }
+ 
+ var w Writer = nil     // nil interface - both type and value are nil
+ fmt.Println(w == nil)  // true
+ 
+ var buf *bytes.Buffer = nil  // nil pointer
+ var w2 Writer = buf          // interface with nil concrete value
+ fmt.Println(w2 == nil)       // FALSE!
+ &#96;&#96;&#96;
+ 
+ Wait, what?
+ 
+ An interface value is nil only if both its type and value are nil. If you assign a nil pointer to an interface, the interface has a type (the pointer type) but a nil value. It's not a nil interface.
+ 
+ This causes bugs like:
+ 
+ &#96;&#96;&#96;go
+ func process(w Writer) {
+     if w != nil {
+         w.Write(data)  // might panic! w could be non-nil interface with nil value
+     }
+ }
+ 
+ var buf *bytes.Buffer = nil
+ process(buf)  // passes the nil check, then panics
+ &#96;&#96;&#96;
+ 
+ The fix is to either check the concrete type too, or (better) never assign nil pointers to interfaces.
+ 
+ ## Zero Values as Nullability
+ 
+ Go's approach to handling "absent" values is the zero value:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     Age       int
+     CreatedAt time.Time
+ }
+ 
+ var u User
+ // u is now {Name: "", Email: "", Age: 0, CreatedAt: zero time}
+ &#96;&#96;&#96;
+ 
+ Every field has a defined zero value. There's no "unset" state—just "set to zero."
+ 
+ This works well for many cases:
+ 
+ &#96;&#96;&#96;go
+ // Empty string often means "not set"
+ if user.Email == "" {
+     // No email provided
+ }
+ 
+ // But what if 0 is a valid age?
+ if user.Age == 0 {
+     // Is this "not set" or "newborn"?
+ }
+ &#96;&#96;&#96;
+ 
+ When you need to distinguish "not set" from "zero value," you have options:
+ 
+ ### Option 1: Pointers
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name  string
+     Age   *int  // nil means not set, *int value means set
+ }
+ 
+ func (u User) HasAge() bool {
+     return u.Age != nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is the closest to C#'s &#96;int?&#96;. But you pay the pointer indirection cost and the nil-checking overhead.
+ 
+ ### Option 2: The "ok" Pattern
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     name    string
+     nameSet bool
+ }
+ 
+ func (u User) Name() (string, bool) {
+     return u.name, u.nameSet
+ }
+ &#96;&#96;&#96;
+ 
+ Explicit, but verbose.
+ 
+ ### Option 3: Wrapper Types
+ 
+ &#96;&#96;&#96;go
+ import "database/sql"
+ 
+ type User struct {
+     Name sql.NullString
+     Age  sql.NullInt64
+ }
+ 
+ if user.Name.Valid {
+     fmt.Println(user.Name.String)
+ }
+ &#96;&#96;&#96;
+ 
+ The standard library has these for database interop. They're clunky but explicit.
+ 
+ ## Error Handling and Nil
+ 
+ Go's error handling interacts with nil constantly:
+ 
+ &#96;&#96;&#96;go
+ func LoadUser(id string) (*User, error) {
+     // ...
+ }
+ 
+ user, err := LoadUser("123")
+ if err != nil {
+     return nil, err
+ }
+ // Use user - we know it's not nil because no error
+ &#96;&#96;&#96;
+ 
+ The convention is: if &#96;err != nil&#96;, don't trust the other return values. If &#96;err == nil&#96;, the values should be valid.
+ 
+ But this is convention, not enforcement. Nothing stops you from writing:
+ 
+ &#96;&#96;&#96;go
+ return nil, nil  // No user, no error - bad practice!
+ &#96;&#96;&#96;
+ 
+ The compiler won't save you from this. Code review and convention do.
+ 
+ ## What I Miss from C#
+ 
+ **Compile-time nullability tracking.** C#'s NRT warns you when you dereference something that might be null. Go just lets you do it.
+ 
+ **The null-conditional operators.** &#96;user?.Profile?.Address?.City&#96; in C# is a single expression. In Go:
+ 
+ &#96;&#96;&#96;go
+ var city string
+ if user != nil &amp;&amp; user.Profile != nil &amp;&amp; user.Profile.Address != nil {
+     city = user.Profile.Address.City
+ }
+ &#96;&#96;&#96;
+ 
+ **Null-coalescing.** &#96;name ?? "Unknown"&#96; vs:
+ 
+ &#96;&#96;&#96;go
+ name := user.Name
+ if name == "" {
+     name = "Unknown"
+ }
+ &#96;&#96;&#96;
+ 
+ Go 1.22 added some helpers, but nothing as clean.
+ 
+ ## What Go Does Well
+ 
+ **Zero values are useful defaults.** A zero &#96;sync.Mutex&#96; works. A zero &#96;bytes.Buffer&#96; works. You don't need constructor ceremonies for basic types.
+ 
+ **No null reference exceptions.** You get panics on nil pointer dereference, but nil slices, nil channels (blocks forever), and nil maps (read) don't crash.
+ 
+ **Explicit pointer semantics.** When something can be nil, it's a pointer. Value types can't be nil. The type tells you what to expect.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# (with NRT) | Go |
+ |--------|---------------|-----|
+ | Compile-time null tracking | Yes (warnings) | No |
+ | Runtime null safety | NullReferenceException | Panic on nil dereference |
+ | Nullable value types | &#96;int?&#96; / &#96;Nullable&lt;T&gt;&#96; | &#96;*int&#96; or wrapper types |
+ | Zero values | Default to null/zero | Always well-defined |
+ | Null-conditional | &#96;?.&#96;, &#96;??&#96; | Manual checks |
+ | Interface nil trap | No equivalent problem | Yes - be careful |
+ 
+ ## Practical Advice
+ 
+ 1. **Initialise maps eagerly.** Don't leave them nil.
+ 
+ 2. **Never assign nil pointers to interfaces.** Return the zero interface instead:
+    &#96;&#96;&#96;go
+    // Bad
+    var buf *bytes.Buffer = nil
+    return buf
+    
+    // Good
+    return nil
+    &#96;&#96;&#96;
+ 
+ 3. **Use pointers for optional fields sparingly.** Often the zero value is fine for "not set."
+ 
+ 4. **Follow the error convention.** If returning an error, either return good values or nil values, not a mix.
+ 
+ 5. **Check nil before method calls on pointer receivers.** Go lets you call methods on nil receivers, which can work or panic depending on the implementation.
+ 
+ 6. **Accept that the compiler won't catch null dereferences.** Tests and careful coding are your only defence.
+ 
+ The lack of NRT-style static analysis is Go's weakest area compared to modern C#. Tools like &#96;staticcheck&#96; help, but they're not built into the language.
+ 
+ You'll write more nil checks. You'll occasionally miss one. That's the trade-off for Go's simplicity.
+ 
+ ---
+ 
+ *Next up: Go's approach to enums—const blocks, iota, and why you'll miss real enums more than you expected to.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-enums.md</summary>

**Chunk 1**
Lines added: 440, lines removed: 1

```diff
@@ -1,1 +1,440 @@
- 
+ +++
+ title = "No Enums? No Problem (Sort Of)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "enums", "csharp"]
+ +++
+ 
+ Go doesn't have enums. Not "Go has something enum-like"—it genuinely doesn't have a dedicated enum construct. What it has instead is constants, a clever auto-incrementing keyword called &#96;iota&#96;, and convention.
+ 
+ For simple cases, this works fine. For anything more complex, you'll miss C#'s enums more than you expect.
+ 
+ ## The Basic Pattern
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status
+ {
+     Pending,
+     Active,
+     Completed,
+     Cancelled
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down:
+ 
+ 1. **Define a new type** based on an underlying type (usually &#96;int&#96;)
+ 2. **Create a const block** with values of that type
+ 3. **Use &#96;iota&#96;** to auto-increment values (0, 1, 2, 3...)
+ 
+ The &#96;iota&#96; keyword resets to 0 at each &#96;const&#96; block and increments for each line. It's surprisingly powerful:
+ 
+ &#96;&#96;&#96;go
+ // Skip zero (useful when zero should mean "unset")
+ const (
+     _ Status = iota  // 0 - discarded
+     StatusPending    // 1
+     StatusActive     // 2
+     StatusCompleted  // 3
+     StatusCancelled  // 4
+ )
+ 
+ // Bit flags
+ const (
+     FlagRead  = 1 &lt;&lt; iota  // 1
+     FlagWrite              // 2
+     FlagExec               // 4
+ )
+ 
+ // Custom formula
+ const (
+     KB = 1 &lt;&lt; (10 * (iota + 1))  // 1024
+     MB                           // 1048576
+     GB                           // 1073741824
+ )
+ &#96;&#96;&#96;
+ 
+ ## What's Missing
+ 
+ ### No Exhaustive Switch
+ 
+ In C#, if you switch on an enum and miss a case, the compiler can warn you:
+ 
+ &#96;&#96;&#96;csharp
+ Status status = GetStatus();
+ switch (status)
+ {
+     case Status.Pending: // ...
+     case Status.Active:  // ...
+     // Missing Completed and Cancelled - compiler warning (with newer analyzers)
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the compiler doesn't care:
+ 
+ &#96;&#96;&#96;go
+ var status Status = getStatus()
+ switch status {
+ case StatusPending:
+     // ...
+ case StatusActive:
+     // ...
+ // Missing cases? Compiler doesn't notice.
+ }
+ &#96;&#96;&#96;
+ 
+ You can use linters like &#96;exhaustive&#96; to catch this, but it's not built in.
+ 
+ ### No Name Resolution
+ 
+ C#'s enums have built-in stringification:
+ 
+ &#96;&#96;&#96;csharp
+ Status.Active.ToString()  // "Active"
+ Enum.Parse&lt;Status&gt;("Active")  // Status.Active
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just integers. No automatic name mapping:
+ 
+ &#96;&#96;&#96;go
+ fmt.Println(StatusActive)  // prints "1" - not useful
+ 
+ // You have to implement String() yourself
+ func (s Status) String() string {
+     switch s {
+     case StatusPending:
+         return "Pending"
+     case StatusActive:
+         return "Active"
+     case StatusCompleted:
+         return "Completed"
+     case StatusCancelled:
+         return "Cancelled"
+     default:
+         return fmt.Sprintf("Status(%d)", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This gets tedious. Tools like &#96;stringer&#96; can generate these methods, but it's an extra build step.
+ 
+ ### No Type Safety (Not Really)
+ 
+ C#'s enums prevent you from using arbitrary values:
+ 
+ &#96;&#96;&#96;csharp
+ Status s = (Status)999;  // Compiles but feels wrong
+ // Modern analyzers can warn about this
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just typed integers. Any int can be cast:
+ 
+ &#96;&#96;&#96;go
+ var s Status = 999  // Perfectly valid, no warning
+ &#96;&#96;&#96;
+ 
+ Nothing stops you from creating invalid values. The type gives you some protection (can't accidentally pass an &#96;int&#96; where &#96;Status&#96; is expected), but it's weak.
+ 
+ ### No Flag Enums with Utility Methods
+ 
+ C#'s &#96;[Flags]&#96; attribute gives you &#96;HasFlag&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ [Flags]
+ public enum Permissions
+ {
+     None = 0,
+     Read = 1,
+     Write = 2,
+     Execute = 4
+ }
+ 
+ var perms = Permissions.Read | Permissions.Write;
+ perms.HasFlag(Permissions.Read)  // true
+ &#96;&#96;&#96;
+ 
+ Go gives you nothing. You do bit manipulation manually:
+ 
+ &#96;&#96;&#96;go
+ const (
+     PermissionNone = 0
+     PermissionRead = 1 &lt;&lt; iota
+     PermissionWrite
+     PermissionExecute
+ )
+ 
+ perms := PermissionRead | PermissionWrite
+ hasRead := perms&amp;PermissionRead != 0  // manual check
+ &#96;&#96;&#96;
+ 
+ Not hard, but not helpful either.
+ 
+ ## Making It Better
+ 
+ Here's how the Go community works around these limitations:
+ 
+ ### The Stringer Tool
+ 
+ Generate &#96;String()&#96; methods automatically:
+ 
+ &#96;&#96;&#96;bash
+ go install golang.org/x/tools/cmd/stringer@latest
+ &#96;&#96;&#96;
+ 
+ Add a generate directive:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=Status
+ 
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Run &#96;go generate ./...&#96; and you get a &#96;status_string.go&#96; file with the &#96;String()&#96; method implemented.
+ 
+ ### Validation Methods
+ 
+ Add explicit validation:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) IsValid() bool {
+     switch s {
+     case StatusPending, StatusActive, StatusCompleted, StatusCancelled:
+         return true
+     default:
+         return false
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Slice of All Values
+ 
+ Useful for iteration and testing:
+ 
+ &#96;&#96;&#96;go
+ var AllStatuses = []Status{
+     StatusPending,
+     StatusActive,
+     StatusCompleted,
+     StatusCancelled,
+ }
+ 
+ func (s Status) IsValid() bool {
+     return slices.Contains(AllStatuses, s)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parse Functions
+ 
+ For deserialisation:
+ 
+ &#96;&#96;&#96;go
+ func ParseStatus(s string) (Status, error) {
+     switch s {
+     case "Pending", "pending":
+         return StatusPending, nil
+     case "Active", "active":
+         return StatusActive, nil
+     case "Completed", "completed":
+         return StatusCompleted, nil
+     case "Cancelled", "cancelled":
+         return StatusCancelled, nil
+     default:
+         return 0, fmt.Errorf("unknown status: %s", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### JSON Marshalling
+ 
+ By default, Go's JSON marshaller uses the integer value. You probably want the string:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     parsed, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = parsed
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ ## A Complete "Enum" Implementation
+ 
+ Here's what a production-ready Go "enum" looks like:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota + 1  // start at 1, 0 means "unset"
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ 
+ var statusNames = map[Status]string{
+     StatusPending:   "Pending",
+     StatusActive:    "Active",
+     StatusCompleted: "Completed",
+     StatusCancelled: "Cancelled",
+ }
+ 
+ var statusValues = map[string]Status{
+     "Pending":   StatusPending,
+     "Active":    StatusActive,
+     "Completed": StatusCompleted,
+     "Cancelled": StatusCancelled,
+ }
+ 
+ func (s Status) String() string {
+     if name, ok := statusNames[s]; ok {
+         return name
+     }
+     return fmt.Sprintf("Status(%d)", s)
+ }
+ 
+ func ParseStatus(s string) (Status, error) {
+     if v, ok := statusValues[s]; ok {
+         return v, nil
+     }
+     return 0, fmt.Errorf("invalid status: %q", s)
+ }
+ 
+ func (s Status) IsValid() bool {
+     _, ok := statusNames[s]
+     return ok
+ }
+ 
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     v, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = v
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Compare that to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status { Pending, Active, Completed, Cancelled }
+ &#96;&#96;&#96;
+ 
+ Yeah.
+ 
+ ## The Honest Assessment
+ 
+ | Feature | C# Enum | Go "Enum" |
+ |---------|---------|-----------|
+ | Declaration | One line | Const block |
+ | Type safety | Strong | Weak (any int assignable) |
+ | String conversion | Built-in | Manual or generated |
+ | Parsing | Built-in | Manual |
+ | Exhaustive switch | Analyzers available | External linter |
+ | Flag support | &#96;[Flags]&#96; + &#96;HasFlag&#96; | Manual bit ops |
+ | JSON serialisation | Configurable | Manual implementation |
+ | Iteration over values | &#96;Enum.GetValues&#96; | Manual slice |
+ 
+ Go's approach is simpler in concept but more work in practice. For a type you use once, it's fine. For a type used throughout a codebase with JSON APIs, database columns, and validation requirements, you'll write a lot of boilerplate.
+ 
+ ## When to Reach for Alternatives
+ 
+ **String constants instead of int enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status string
+ 
+ const (
+     StatusPending   Status = "pending"
+     StatusActive    Status = "active"
+     StatusCompleted Status = "completed"
+     StatusCancelled Status = "cancelled"
+ )
+ &#96;&#96;&#96;
+ 
+ Pros: Natural JSON serialisation, readable in logs/databases.
+ Cons: More memory, slower comparison, still no exhaustive switch checking.
+ 
+ **Third-party enum packages:**
+ 
+ Libraries like &#96;go-enum&#96; generate all the boilerplate. Worth considering for large projects.
+ 
+ **Interface-based enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status interface {
+     status()  // unexported marker method
+     String() string
+ }
+ 
+ type statusPending struct{}
+ func (statusPending) status() {}
+ func (statusPending) String() string { return "Pending" }
+ 
+ var StatusPending Status = statusPending{}
+ &#96;&#96;&#96;
+ 
+ Type-safe (can't create arbitrary values), but verbose and unusual.
+ 
+ ## Practical Advice
+ 
+ 1. **Use &#96;stringer&#96; for any enum in production code.** The manual &#96;String()&#96; method will fall out of sync.
+ 
+ 2. **Start const values at 1 if zero means "unset."** Or use an explicit &#96;StatusUnknown = 0&#96; value.
+ 
+ 3. **Always add an &#96;IsValid()&#96; method.** Check it at system boundaries (API inputs, database reads).
+ 
+ 4. **Use string-based enums for external APIs.** They're more forgiving and self-documenting.
+ 
+ 5. **Accept the boilerplate.** Fighting it is pointless. Copy-paste or generate.
+ 
+ 6. **Use the &#96;exhaustive&#96; linter.** It's the only way to get switch statement coverage warnings.
+ 
+ Go's lack of proper enums is one of its genuine weaknesses. The workarounds work, but they're workarounds. Every Go developer I know has a personal template or snippet for "proper" enum implementation.
+ 
+ Maybe we'll get real enums eventually. Until then, embrace &#96;iota&#96; and keep your boilerplate consistent.
+ 
+ ---
+ 
+ *That wraps up Phase 2 on types and data. Next we'll move into Phase 3: Functions, Methods, and Interfaces—where Go's composition-over-inheritance philosophy really starts to show its strengths.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
All five posts are written. Let me verify the Hugo build passes with all of them.</details></think>

---

Let me verify the Hugo build passes with all the new posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
-rw-r--r--  1 andycross  staff  10096 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   8877 Dec 28 20:24 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8502 Dec 28 20:25 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8749 Dec 28 20:23 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9254 Dec 28 20:23 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All seven posts are now created and the build passes. Let me summarize what was created for the user.</details></think>

---

All five Phase 2 posts are created and the Hugo build passes. Here's the complete series so far:

## C# to Go Series

### Phase 1: Getting Oriented (2 posts)
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model, cross-compilation
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection, go.sum

### Phase 2: Types & Data (5 posts)
3. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, pointers, embedding vs inheritance, implicit interfaces
4. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields vs accessors, the `internal/` convention, struct tags
5. **"Generics: Late to the Party"** — What Go 1.18+ provides, constraints, what's missing (variance, generic methods, specialisation)
6. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap, zero values as defaults
7. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, what's missing (exhaustive switch, String()), stringer tool, workarounds

Each post follows the established tone:
- UK English throughout
- First person plural for learning together
- Fair comparisons (not bashing C# or overselling Go)
- Tables for genuine comparisons
- Runnable code examples
- Honest "what I miss" and "what I prefer" sections
- Practical advice sections

Ready for Phase 3 when you are?

---

_**User (2025-12-29 06:27Z)**_

We need to enhance one of the earlier posts, or inject a new one, which helps understand two key things

1) arrays are slices, dictionaries are maps ---- what are the key terminology changes that trip you up coming from c#
2) what are the new operators that you have to get ready for (:= for instance) 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to either enhance an existing post or create a new one that covers:
1. Terminology changes (arrays→slices, Dictionary→map, etc.)
2. New operators (:=, etc.)

Looking at the current series structure:
- Phase 1: Toolchain, Modules
- Phase 2: Structs, Visibility, Generics, Nil, Enums

This content feels like it should come early - it's foundational "getting oriented" material. It could either:
1. Be injected into the first post (toolchain)
2. Become a new post between Phase 1 and Phase 2

I think a new post makes more sense - this is substantial enough content to stand alone, and it's really about "the basics that trip you up" before you even get to types in depth. It could be titled something like "The Phrasebook: C# to Go Terminology and Syntax".

Let me create a new post that fits between the toolchain/modules posts and the types posts. This should cover:

Terminology:
- array → slice (and actual arrays exist but are rare)
- List<T> → slice
- Dictionary<K,V> → map
- namespace → package
- null → nil
- class → struct
- interface (explicit) → interface (implicit)
- property → field + methods
- var → var (but also :=)
- async/await → goroutines/channels
- event → channels
- LINQ → no equivalent (loops or generics)
- exception → error
- try/catch → if err != nil
- using → defer
- lock → sync.Mutex
- foreach → for range
- out/ref → pointers

Operators:
- := short variable declaration
- & address-of (like C#)
- * dereference (like C#)
- <- channel send/receive
- ... variadic and slice unpacking
- range keyword in for loops
- _ blank identifier
- := vs = 


- make() and new() are crucial memory allocation functions in Go

I'll explore make() and new() as key memory allocation mechanisms. make() is specifically for creating slices, maps, and channels, initializing their internal data structures. new() allocates memory for a type and returns a pointer, zeroing out the memory. These functions handle different memory initialization scenarios, providing precise control over how Go allocates and prepares memory for various data structures.</details></think>

---

Good call—this foundational "translation" content should come early in the series. I'll create a new post that slots in between the toolchain posts and the types posts. It's substantial enough to stand alone as a "phrasebook" reference.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-phrasebook.md</summary>

**Chunk 1**
Lines added: 424, lines removed: 1

```diff
@@ -1,1 +1,424 @@
- 
+ +++
+ title = "The Phrasebook: C# Concepts in Go Terms"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "syntax", "csharp"]
+ +++
+ 
+ Before we get into the weeds of types and patterns, let's establish some vocabulary. Go uses different names for familiar concepts, and has operators you've never seen. This post is a reference—skim it now, bookmark it for later.
+ 
+ ## The Terminology Swap
+ 
+ Your C# brain thinks in certain words. Here's the translation:
+ 
+ | C# Term | Go Term | Notes |
+ |---------|---------|-------|
+ | &#96;List&lt;T&gt;&#96; | slice | Dynamic array, the workhorse collection |
+ | &#96;T[]&#96; (array) | slice (usually) | Go has arrays, but you'll rarely use them |
+ | &#96;Dictionary&lt;K,V&gt;&#96; | map | &#96;map[string]int&#96; instead of &#96;Dictionary&lt;string, int&gt;&#96; |
+ | namespace | package | But packages are directories, not hierarchies |
+ | &#96;null&#96; | &#96;nil&#96; | Same concept, different spelling |
+ | class | struct | No inheritance, but methods work |
+ | property | field (+ methods) | No get/set syntax |
+ | &#96;var&#96; | &#96;var&#96; or &#96;:=&#96; | Two ways to declare variables |
+ | &#96;async&#96;/&#96;await&#96; | goroutines + channels | Completely different model |
+ | exception | error | Errors are values, not control flow |
+ | &#96;try&#96;/&#96;catch&#96; | &#96;if err != nil&#96; | Explicit checking, no unwinding |
+ | &#96;using&#96; | &#96;defer&#96; | Cleanup runs at function exit |
+ | &#96;lock&#96; | &#96;sync.Mutex&#96; | Manual lock/unlock |
+ | &#96;foreach&#96; | &#96;for range&#96; | Single construct for iteration |
+ | &#96;out&#96;/&#96;ref&#96; | pointers | Explicit &#96;*&#96; and &#96;&amp;&#96; |
+ | LINQ | nothing built-in | Loops, or generics since 1.18 |
+ | extension methods | nothing | Define functions, not methods |
+ | partial class | nothing | All code in the package shares scope |
+ | static class | package-level functions | No class, just functions |
+ 
+ ### Arrays vs Slices
+ 
+ This one catches everyone. In C#, "array" means a fixed-size, contiguous block:
+ 
+ &#96;&#96;&#96;csharp
+ int[] numbers = new int[5];  // fixed size 5
+ &#96;&#96;&#96;
+ 
+ In Go, this is also called an array—but you almost never use them directly:
+ 
+ &#96;&#96;&#96;go
+ var numbers [5]int  // array - fixed size, rarely used
+ &#96;&#96;&#96;
+ 
+ What you use instead is a **slice**—a dynamic view over an array:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}  // slice - this is what you want
+ numbers = append(numbers, 6)     // grows automatically
+ &#96;&#96;&#96;
+ 
+ Think of slices as &#96;List&lt;T&gt;&#96; that happens to have array-like syntax. They grow, shrink, and pass by reference (sort of—the header is copied, but the backing array is shared).
+ 
+ **The rule:** if you're reaching for an array in Go, you probably want a slice.
+ 
+ ### Maps
+ 
+ &#96;Dictionary&lt;K, V&gt;&#96; becomes &#96;map[K]V&#96;. The syntax is inside-out:
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ var scores = new Dictionary&lt;string, int&gt;
+ {
+     ["Alice"] = 100,
+     ["Bob"] = 85
+ };
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go
+ scores := map[string]int{
+     "Alice": 100,
+     "Bob":   85,
+ }
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - Maps must be initialised before use (nil maps panic on write)
+ - Missing keys return the zero value
+ - Use the two-value form to check existence: &#96;val, ok := m[key]&#96;
+ 
+ &#96;&#96;&#96;go
+ score, exists := scores["Charlie"]
+ if !exists {
+     fmt.Println("Charlie not found")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Operators You Haven't Met
+ 
+ Go has several operators and constructs that don't exist in C#. Here's your cheat sheet.
+ 
+ ### &#96;:=&#96; Short Variable Declaration
+ 
+ This is the one you'll use constantly:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ var name string = "Alice"
+ name := "Alice"  // type inferred, shorter
+ &#96;&#96;&#96;
+ 
+ The &#96;:=&#96; operator declares AND assigns. It only works inside functions, and only for new variables.
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ name := "Bob"    // ERROR: no new variables on left side
+ name = "Bob"     // OK: just assignment, no declaration
+ &#96;&#96;&#96;
+ 
+ **The gotcha:** &#96;:=&#96; in an inner scope creates a new variable that shadows the outer one:
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ if true {
+     name := "Bob"  // new variable, shadows outer 'name'
+     fmt.Println(name)  // "Bob"
+ }
+ fmt.Println(name)  // "Alice" - outer unchanged!
+ &#96;&#96;&#96;
+ 
+ This is a common source of bugs. Use &#96;=&#96; for assignment when the variable already exists.
+ 
+ ### &#96;_&#96; Blank Identifier
+ 
+ The underscore discards a value. You'll use it constantly because Go requires you to use all declared variables:
+ 
+ &#96;&#96;&#96;go
+ // Ignore the index in a range loop
+ for _, value := range items {
+     fmt.Println(value)
+ }
+ 
+ // Ignore an unwanted return value
+ _, err := doSomething()
+ 
+ // Ignore the second return value (existence check)
+ value, _ := myMap[key]  // don't care if it exists
+ 
+ // Interface compliance check (compile-time)
+ var _ io.Reader = (*MyType)(nil)
+ &#96;&#96;&#96;
+ 
+ ### &#96;&lt;-&#96; Channel Operator
+ 
+ Channels are Go's concurrency primitive. The &#96;&lt;-&#96; operator sends and receives:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ 
+ go func() {
+     ch &lt;- 42  // send 42 into the channel
+ }()
+ 
+ value := &lt;-ch  // receive from the channel
+ fmt.Println(value)  // 42
+ &#96;&#96;&#96;
+ 
+ The arrow points in the direction of data flow. Send: &#96;ch &lt;- value&#96;. Receive: &#96;value := &lt;-ch&#96;.
+ 
+ ### &#96;...&#96; Variadic and Spread
+ 
+ Two related uses for the ellipsis:
+ 
+ **Variadic parameters** (like C#'s &#96;params&#96;):
+ 
+ &#96;&#96;&#96;go
+ func Sum(numbers ...int) int {
+     total := 0
+     for _, n := range numbers {
+         total += n
+     }
+     return total
+ }
+ 
+ Sum(1, 2, 3)  // works
+ Sum(1, 2, 3, 4, 5)  // also works
+ &#96;&#96;&#96;
+ 
+ **Spreading a slice** into variadic arguments:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}
+ Sum(numbers...)  // unpacks the slice
+ &#96;&#96;&#96;
+ 
+ ### &#96;&amp;&#96; and &#96;*&#96; (Pointers)
+ 
+ These exist in C# but you probably haven't used them much. In Go, they're everywhere:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x   // p is *int, points to x
+ *p = 100  // dereference: x is now 100
+ &#96;&#96;&#96;
+ 
+ More commonly, you'll see them with structs:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ u := User{Name: "Alice"}
+ ptr := &amp;u           // *User
+ ptr.Name = "Bob"    // Go auto-dereferences for field access
+ &#96;&#96;&#96;
+ 
+ ### &#96;make()&#96; and &#96;new()&#96;
+ 
+ Two built-in functions for creating things:
+ 
+ **&#96;make()&#96;** is for slices, maps, and channels—types that need initialisation:
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 0, 10)     // slice with length 0, capacity 10
+ m := make(map[string]int)   // initialised map (not nil!)
+ ch := make(chan int)        // unbuffered channel
+ ch := make(chan int, 10)    // buffered channel, capacity 10
+ &#96;&#96;&#96;
+ 
+ **&#96;new()&#96;** allocates and returns a pointer to the zero value:
+ 
+ &#96;&#96;&#96;go
+ p := new(User)  // *User, pointing to User{}
+ &#96;&#96;&#96;
+ 
+ In practice, you'll use &#96;make()&#96; often and &#96;new()&#96; rarely. The composite literal with &#96;&amp;&#96; is more common:
+ 
+ &#96;&#96;&#96;go
+ p := &amp;User{Name: "Alice"}  // equivalent to new + field assignment
+ &#96;&#96;&#96;
+ 
+ ## The &#96;for&#96; Loop (It's the Only One)
+ 
+ Go has one loop construct: &#96;for&#96;. It does everything.
+ 
+ &#96;&#96;&#96;go
+ // Traditional for loop (like C#)
+ for i := 0; i &lt; 10; i++ {
+     fmt.Println(i)
+ }
+ 
+ // While loop (condition only)
+ for condition {
+     // ...
+ }
+ 
+ // Infinite loop
+ for {
+     // break to exit
+ }
+ 
+ // Range over slice (like foreach)
+ for index, value := range items {
+     fmt.Println(index, value)
+ }
+ 
+ // Range over map
+ for key, value := range myMap {
+     fmt.Println(key, value)
+ }
+ 
+ // Range over string (gives runes, not bytes)
+ for index, char := range "hello" {
+     fmt.Printf("%d: %c\n", index, char)
+ }
+ 
+ // Range over channel
+ for msg := range messages {
+     fmt.Println(msg)  // until channel is closed
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;_&#96; to ignore index or value:
+ 
+ &#96;&#96;&#96;go
+ for _, value := range items { }  // ignore index
+ for index := range items { }     // ignore value (just omit it)
+ &#96;&#96;&#96;
+ 
+ ## &#96;defer&#96; Instead of &#96;using&#96;
+ 
+ C#'s &#96;using&#96; statement disposes resources at block exit:
+ 
+ &#96;&#96;&#96;csharp
+ using var file = File.OpenRead("data.txt");
+ // file is disposed when scope exits
+ &#96;&#96;&#96;
+ 
+ Go's &#96;defer&#96; schedules a function call to run when the *function* exits:
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()  // runs when this function returns
+ 
+ // use file...
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - &#96;defer&#96; runs at function exit, not block exit
+ - Multiple defers run in LIFO order (last defer runs first)
+ - Deferred calls capture their arguments when the defer statement executes
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     defer fmt.Println("first")
+     defer fmt.Println("second")
+     defer fmt.Println("third")
+ }
+ // Output: third, second, first
+ &#96;&#96;&#96;
+ 
+ ## Error Handling: &#96;if err != nil&#96;
+ 
+ This is the biggest mental shift. No exceptions, no try/catch. Errors are values.
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return fmt.Errorf("failed to open: %w", err)
+ }
+ defer file.Close()
+ 
+ data, err := io.ReadAll(file)
+ if err != nil {
+     return fmt.Errorf("failed to read: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ You'll write &#96;if err != nil&#96; hundreds of times. It's verbose. It's explicit. It works.
+ 
+ The &#96;%w&#96; verb wraps errors, preserving the chain for later inspection with &#96;errors.Is()&#96; and &#96;errors.As()&#96;.
+ 
+ ## Multiple Return Values
+ 
+ Go functions can return multiple values. This is how errors are returned:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (float64, error) {
+     if b == 0 {
+         return 0, errors.New("division by zero")
+     }
+     return a / b, nil
+ }
+ 
+ result, err := Divide(10, 2)
+ if err != nil {
+     // handle error
+ }
+ &#96;&#96;&#96;
+ 
+ You can also use named return values:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (result float64, err error) {
+     if b == 0 {
+         err = errors.New("division by zero")
+         return  // returns named values
+     }
+     result = a / b
+     return
+ }
+ &#96;&#96;&#96;
+ 
+ Named returns are sometimes clearer, sometimes not. Use your judgement.
+ 
+ ## Type Assertions and Switches
+ 
+ When you have an &#96;interface{}&#96; (or &#96;any&#96;) and need the concrete type:
+ 
+ &#96;&#96;&#96;go
+ // Type assertion
+ value := something.(string)  // panics if not string
+ 
+ // Safe type assertion
+ value, ok := something.(string)
+ if !ok {
+     // not a string
+ }
+ 
+ // Type switch
+ switch v := something.(type) {
+ case string:
+     fmt.Println("string:", v)
+ case int:
+     fmt.Println("int:", v)
+ default:
+     fmt.Println("unknown type")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Quick Reference Card
+ 
+ Keep this handy until it's automatic:
+ 
+ | When you want to... | C# | Go |
+ |---------------------|-----|-----|
+ | Declare and assign | &#96;var x = 5;&#96; | &#96;x := 5&#96; |
+ | Declare without assign | &#96;int x;&#96; | &#96;var x int&#96; |
+ | Create a list | &#96;new List&lt;int&gt;()&#96; | &#96;[]int{}&#96; or &#96;make([]int, 0)&#96; |
+ | Create a dictionary | &#96;new Dictionary&lt;K,V&gt;()&#96; | &#96;make(map[K]V)&#96; |
+ | Append to list | &#96;list.Add(x)&#96; | &#96;slice = append(slice, x)&#96; |
+ | Get dictionary value | &#96;dict[key]&#96; | &#96;val := m[key]&#96; or &#96;val, ok := m[key]&#96; |
+ | Check key exists | &#96;dict.ContainsKey(k)&#96; | &#96;_, ok := m[k]&#96; |
+ | Iterate collection | &#96;foreach (var x in items)&#96; | &#96;for _, x := range items&#96; |
+ | Null check | &#96;if (x == null)&#96; | &#96;if x == nil&#96; |
+ | String format | &#96;$"Hello {name}"&#96; | &#96;fmt.Sprintf("Hello %s", name)&#96; |
+ | Error handling | &#96;try { } catch { }&#96; | &#96;if err != nil { }&#96; |
+ | Cleanup | &#96;using var x = ...&#96; | &#96;defer x.Close()&#96; |
+ | Async | &#96;await Task.Run(...)&#96; | &#96;go func() { }()&#96; |
+ 
+ ---
+ 
+ *This post is a reference, not a deep dive. We'll cover structs, visibility, and the type system properly in the next posts. But now you've got the vocabulary and the operators—the rest should make more sense.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, let me verify the build works.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
       8

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 8 posts now exist and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

Build passes. Here's the updated series structure with the new post slotted in:

## C# to Go Series (8 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection
3. **"The Phrasebook: C# Concepts in Go Terms"** ← **NEW** — Terminology swap (slice, map, nil), new operators (`:=`, `_`, `<-`, `...`), `for range`, `defer`, error handling basics, quick reference card

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields, struct tags
6. **"Generics: Late to the Party"** — What Go 1.18+ provides versus C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, stringer, workarounds

The Phrasebook post covers:
- **Terminology:** array→slice, Dictionary→map, null→nil, foreach→for range, using→defer, try/catch→if err != nil
- **New operators:** `:=` (short declaration), `_` (blank identifier), `<-` (channels), `...` (variadic/spread), `&`/`*` (pointers)
- **Built-ins:** `make()` vs `new()`, the single `for` loop, `defer` semantics
- **Quick reference card** at the end for bookmarking

The date is set to 2024-12-28 (same as the first two posts) so it'll sort appropriately. Ready for Phase 3 whenever you are!

---

_**User (2025-12-29 06:27Z)**_

ok the next phase now, phase 3 - Control Flow & Error Handling

if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create Phase 3: Control Flow & Error Handling with 3 posts:

1. if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
2. Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
3. The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

Let me write all three posts following the same tone and style.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-errors.md</summary>

**Chunk 1**
Lines added: 374, lines removed: 1

```diff
@@ -1,1 +1,374 @@
- 
+ +++
+ title = "if err != nil: Your New Reality"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ Let's address the elephant in the room. You're going to write &#96;if err != nil&#96; hundreds of times. Thousands, probably. And for the first week, you're going to hate it.
+ 
+ Coming from C#, where exceptions handle the sad path invisibly, Go's explicit error handling feels like a step backwards. It's verbose. It's repetitive. It clutters your code with what looks like boilerplate.
+ 
+ Then something shifts. You start to see what you're gaining. Let's work through that shift.
+ 
+ ## Why No Exceptions?
+ 
+ C# uses exceptions for error handling:
+ 
+ &#96;&#96;&#96;csharp
+ try
+ {
+     var data = await File.ReadAllTextAsync("config.json");
+     var config = JsonSerializer.Deserialize&lt;Config&gt;(data);
+     await database.Connect(config.ConnectionString);
+ }
+ catch (FileNotFoundException)
+ {
+     logger.Error("Config file missing");
+ }
+ catch (JsonException ex)
+ {
+     logger.Error($"Invalid config: {ex.Message}");
+ }
+ catch (Exception ex)
+ {
+     logger.Error($"Unexpected error: {ex.Message}");
+     throw;
+ }
+ &#96;&#96;&#96;
+ 
+ This looks clean. The happy path is uncluttered. Errors are handled elsewhere.
+ 
+ But there's a hidden cost: **you can't see which lines can fail**. Any line might throw. Any function you call might throw. The &#96;catch&#96; block is disconnected from the code that caused the problem.
+ 
+ Go takes the opposite view: **errors are values, returned like any other value**:
+ 
+ &#96;&#96;&#96;go
+ data, err := os.ReadFile("config.json")
+ if err != nil {
+     return fmt.Errorf("reading config: %w", err)
+ }
+ 
+ var config Config
+ if err := json.Unmarshal(data, &amp;config); err != nil {
+     return fmt.Errorf("parsing config: %w", err)
+ }
+ 
+ if err := database.Connect(config.ConnectionString); err != nil {
+     return fmt.Errorf("connecting to database: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ Verbose? Yes. But look at what you can see:
+ 
+ - Every line that can fail is marked with &#96;err :=&#96; or &#96;, err&#96;
+ - You know exactly what error each block handles
+ - The handling is right next to the call that produced the error
+ - No hidden control flow—the code does what it looks like it does
+ 
+ ## The Error Interface
+ 
+ In Go, &#96;error&#96; is just an interface:
+ 
+ &#96;&#96;&#96;go
+ type error interface {
+     Error() string
+ }
+ &#96;&#96;&#96;
+ 
+ Anything with an &#96;Error()&#96; method is an error. This is intentionally simple.
+ 
+ Creating errors:
+ 
+ &#96;&#96;&#96;go
+ import "errors"
+ 
+ // Simple error
+ err := errors.New("something went wrong")
+ 
+ // Formatted error
+ err := fmt.Errorf("failed to load user %d: %w", userID, originalErr)
+ &#96;&#96;&#96;
+ 
+ That &#96;%w&#96; verb is important—it wraps the original error, preserving the chain.
+ 
+ ## The Pattern You'll Write Forever
+ 
+ Here's the basic pattern:
+ 
+ &#96;&#96;&#96;go
+ result, err := doSomething()
+ if err != nil {
+     return fmt.Errorf("doing something: %w", err)
+ }
+ // use result
+ &#96;&#96;&#96;
+ 
+ Variations:
+ 
+ &#96;&#96;&#96;go
+ // When there's no result to use
+ if err := doSomething(); err != nil {
+     return err
+ }
+ 
+ // When you want to handle specific errors
+ if err := doSomething(); err != nil {
+     if errors.Is(err, ErrNotFound) {
+         return defaultValue, nil  // handle gracefully
+     }
+     return zero, err  // propagate others
+ }
+ 
+ // When you need to clean up on error
+ file, err := os.Create("output.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()
+ 
+ if err := writeData(file); err != nil {
+     os.Remove("output.txt")  // clean up partial file
+     return fmt.Errorf("writing data: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Wrapping Errors Properly
+ 
+ Go 1.13 introduced error wrapping. Use it:
+ 
+ &#96;&#96;&#96;go
+ // BAD: loses the original error
+ if err != nil {
+     return errors.New("failed to connect")
+ }
+ 
+ // BAD: concatenates as string, loses error chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %s", err)
+ }
+ 
+ // GOOD: wraps the error, preserves the chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;%w&#96; verb creates a chain that can be inspected:
+ 
+ &#96;&#96;&#96;go
+ if errors.Is(err, sql.ErrNoRows) {
+     // somewhere in the chain, there's a sql.ErrNoRows
+ }
+ 
+ var pathErr *os.PathError
+ if errors.As(err, &amp;pathErr) {
+     // somewhere in the chain, there's a *os.PathError
+     fmt.Println(pathErr.Path)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Sentinel Errors
+ 
+ For errors that callers need to check, define package-level sentinel errors:
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ var (
+     ErrNotFound     = errors.New("user not found")
+     ErrInvalidEmail = errors.New("invalid email address")
+     ErrDuplicate    = errors.New("user already exists")
+ )
+ 
+ func Find(id string) (*User, error) {
+     // ...
+     if notFound {
+         return nil, ErrNotFound
+     }
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can check:
+ 
+ &#96;&#96;&#96;go
+ user, err := user.Find("123")
+ if errors.Is(err, user.ErrNotFound) {
+     // handle not found specifically
+ }
+ &#96;&#96;&#96;
+ 
+ ## Custom Error Types
+ 
+ When you need more context, create a custom error type:
+ 
+ &#96;&#96;&#96;go
+ type ValidationError struct {
+     Field   string
+     Message string
+ }
+ 
+ func (e *ValidationError) Error() string {
+     return fmt.Sprintf("%s: %s", e.Field, e.Message)
+ }
+ 
+ func ValidateUser(u *User) error {
+     if u.Email == "" {
+         return &amp;ValidationError{Field: "email", Message: "required"}
+     }
+     if !strings.Contains(u.Email, "@") {
+         return &amp;ValidationError{Field: "email", Message: "invalid format"}
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can extract details:
+ 
+ &#96;&#96;&#96;go
+ if err := ValidateUser(u); err != nil {
+     var valErr *ValidationError
+     if errors.As(err, &amp;valErr) {
+         fmt.Printf("Validation failed on %s: %s\n", valErr.Field, valErr.Message)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## Strategies That Help
+ 
+ ### Early Returns
+ 
+ Embrace early returns. Don't nest error handling:
+ 
+ &#96;&#96;&#96;go
+ // BAD: nested, hard to follow
+ func process() error {
+     data, err := loadData()
+     if err == nil {
+         parsed, err := parseData(data)
+         if err == nil {
+             result, err := transform(parsed)
+             if err == nil {
+                 return save(result)
+             } else {
+                 return err
+             }
+         } else {
+             return err
+         }
+     } else {
+         return err
+     }
+ }
+ 
+ // GOOD: flat, obvious
+ func process() error {
+     data, err := loadData()
+     if err != nil {
+         return fmt.Errorf("loading: %w", err)
+     }
+     
+     parsed, err := parseData(data)
+     if err != nil {
+         return fmt.Errorf("parsing: %w", err)
+     }
+     
+     result, err := transform(parsed)
+     if err != nil {
+         return fmt.Errorf("transforming: %w", err)
+     }
+     
+     return save(result)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Naming Consistency
+ 
+ Keep error variable names consistent within a function:
+ 
+ &#96;&#96;&#96;go
+ // Use 'err' for the standard error variable
+ data, err := load()
+ if err != nil { ... }
+ 
+ result, err := process(data)  // reuse 'err'
+ if err != nil { ... }
+ 
+ // Use descriptive names when you have multiple errors in scope
+ loadErr := load()
+ processErr := process()
+ if loadErr != nil || processErr != nil { ... }
+ &#96;&#96;&#96;
+ 
+ ### The "Must" Pattern
+ 
+ For initialisation code where errors are truly unrecoverable:
+ 
+ &#96;&#96;&#96;go
+ var templates = template.Must(template.ParseGlob("templates/*.html"))
+ var config = MustLoadConfig("config.yaml")
+ 
+ func MustLoadConfig(path string) Config {
+     cfg, err := LoadConfig(path)
+     if err != nil {
+         panic(fmt.Sprintf("loading config: %v", err))
+     }
+     return cfg
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;Must&#96; functions sparingly—only for program setup where failure means "can't start."
+ 
+ ## What You're Actually Getting
+ 
+ After the initial frustration wears off, here's what explicit errors give you:
+ 
+ **Visible failure points.** Every line that can fail is marked. No surprises.
+ 
+ **Local reasoning.** You handle errors where they occur. No tracing back through call stacks.
+ 
+ **No performance penalty.** Error returns are just values—no stack unwinding, no runtime cost.
+ 
+ **Forced consideration.** You can't ignore errors accidentally. (Well, you can with &#96;_&#96;, but it's deliberate.)
+ 
+ **Simpler debugging.** When something fails, the error message tells you exactly what happened at each level.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Exceptions | Go Errors |
+ |--------|--------------|-----------|
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;throw&#96; | &#96;if err != nil&#96; |
+ | Control flow | Non-local jump | Normal return |
+ | Performance | Cost on throw | No overhead |
+ | Visibility | Hidden failure points | Explicit everywhere |
+ | Ignoring errors | Silent (dangerous) | Requires explicit &#96;_&#96; |
+ | Stack traces | Automatic | Manual (or wrap carefully) |
+ | Recovery | &#96;catch&#96; blocks | Caller decides |
+ 
+ ## The Honest Take
+ 
+ **Things I like better than C#:**
+ 
+ - You can see which calls can fail
+ - Error handling is local and explicit
+ - No surprise exceptions from deep in the stack
+ - Errors are values—you can store, compare, wrap them
+ 
+ **Things I miss from C#:**
+ 
+ - The happy path being uncluttered
+ - Automatic stack traces
+ - &#96;finally&#96; blocks (defer is close but not identical)
+ - Not writing the same three lines a thousand times
+ 
+ **The verdict:**
+ 
+ Go's approach is more verbose but more honest. Once you accept that error handling is part of your code—not something that happens off to the side—the verbosity starts to feel appropriate.
+ 
+ You're not writing boilerplate. You're writing error handling. It just happens to look the same every time because handling errors correctly *is* repetitive.
+ 
+ ---
+ 
+ *Next up: panic and recover—Go's actual exception mechanism, why it exists, and why using it for normal errors will get you judged.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-panic.md</summary>

**Chunk 1**
Lines added: 316, lines removed: 1

```diff
@@ -1,1 +1,316 @@
- 
+ +++
+ title = "Panic and Recover: The Emergency Exit"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ So Go doesn't have exceptions. Except... it kind of does. They're called &#96;panic&#96; and &#96;recover&#96;, and they work almost exactly like throw and catch.
+ 
+ Here's the thing: if you use them like exceptions, other Go developers will judge you. Harshly. Let's understand why they exist, when to use them, and why the judgment is (mostly) deserved.
+ 
+ ## What Panic Does
+ 
+ &#96;panic&#96; stops normal execution and begins unwinding the stack:
+ 
+ &#96;&#96;&#96;go
+ func divide(a, b int) int {
+     if b == 0 {
+         panic("division by zero")
+     }
+     return a / b
+ }
+ 
+ func main() {
+     result := divide(10, 0)  // panics here
+     fmt.Println(result)      // never reached
+ }
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ panic: division by zero
+ 
+ goroutine 1 [running]:
+ main.divide(...)
+         /app/main.go:7
+ main.main()
+         /app/main.go:12
+ exit status 2
+ &#96;&#96;&#96;
+ 
+ Sound familiar? It's an unhandled exception with a stack trace.
+ 
+ Deferred functions still run during a panic:
+ 
+ &#96;&#96;&#96;go
+ func riskyOperation() {
+     defer fmt.Println("cleanup runs")  // this executes
+     panic("oh no")
+     fmt.Println("never reached")
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Recover Does
+ 
+ &#96;recover&#96; catches a panic. It only works inside a deferred function:
+ 
+ &#96;&#96;&#96;go
+ func safeOperation() (err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             err = fmt.Errorf("recovered from panic: %v", r)
+         }
+     }()
+     
+     riskyOperation()  // might panic
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ If &#96;riskyOperation&#96; panics, &#96;recover()&#96; catches it and we convert it to an error. The function returns normally instead of crashing.
+ 
+ This is literally try/catch:
+ 
+ &#96;&#96;&#96;csharp
+ // C# equivalent
+ try
+ {
+     RiskyOperation();
+ }
+ catch (Exception ex)
+ {
+     return new Error($"recovered from exception: {ex.Message}");
+ }
+ &#96;&#96;&#96;
+ 
+ ## Why Go Developers Judge You
+ 
+ So if panic/recover is just exceptions by another name, why not use them that way?
+ 
+ Because Go's error philosophy is that **errors are expected, panics are not**.
+ 
+ - Errors are things that can reasonably happen: file not found, network timeout, invalid input
+ - Panics are things that *shouldn't* happen: nil pointer dereference, index out of bounds, programmer bugs
+ 
+ When you use panic for normal errors, you're saying "this should never happen" when what you mean is "I didn't want to write &#96;if err != nil&#96;."
+ 
+ The community has strong opinions about this:
+ 
+ &#96;&#96;&#96;go
+ // This will get you judged
+ func ParseConfig(path string) Config {
+     data, err := os.ReadFile(path)
+     if err != nil {
+         panic(err)  // NO - missing file is a normal error
+     }
+     // ...
+ }
+ 
+ // This is fine
+ func MustParseConfig(path string) Config {
+     // "Must" in the name signals this panics
+     // Only use at startup where failure = can't run
+ }
+ &#96;&#96;&#96;
+ 
+ ## When Panic Is Appropriate
+ 
+ Despite the judgment, there are legitimate uses:
+ 
+ ### 1. Truly Unrecoverable Programmer Errors
+ 
+ &#96;&#96;&#96;go
+ func processItem(item *Item) {
+     if item == nil {
+         panic("processItem called with nil item")
+     }
+     // This is a programming error - the caller screwed up
+     // Not a runtime condition we should handle gracefully
+ }
+ &#96;&#96;&#96;
+ 
+ ### 2. Initialisation Failures
+ 
+ &#96;&#96;&#96;go
+ var db = mustConnect()
+ 
+ func mustConnect() *sql.DB {
+     db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
+     if err != nil {
+         panic(fmt.Sprintf("database connection failed: %v", err))
+     }
+     return db
+ }
+ &#96;&#96;&#96;
+ 
+ If the program can't start without a database, panicking at init is reasonable. There's nothing useful to do with the error.
+ 
+ ### 3. The "Must" Convention
+ 
+ Standard library examples:
+ 
+ &#96;&#96;&#96;go
+ // template.Must panics if parsing fails
+ var templates = template.Must(template.ParseGlob("*.html"))
+ 
+ // regexp.MustCompile panics if pattern is invalid
+ var emailRegex = regexp.MustCompile(&#96;^[a-z]+@[a-z]+\.[a-z]+$&#96;)
+ &#96;&#96;&#96;
+ 
+ The &#96;Must&#96; prefix tells callers "this panics on error—only use with compile-time constant inputs."
+ 
+ ### 4. Deep Recursion Bailout
+ 
+ Sometimes you're deep in recursion and unwinding through error returns is painful:
+ 
+ &#96;&#96;&#96;go
+ func parse(tokens []Token) (result AST, err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             if parseErr, ok := r.(parseError); ok {
+                 err = parseErr
+             } else {
+                 panic(r)  // re-panic if it's not our error
+             }
+         }
+     }()
+     
+     return parseExpression(tokens), nil
+ }
+ 
+ func parseExpression(tokens []Token) AST {
+     // Deep recursive descent
+     // ...
+     if somethingWrong {
+         panic(parseError{msg: "unexpected token", pos: pos})
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This is controversial but accepted in parsers and similar deep-recursion scenarios. Note that the panic is recovered at the boundary and converted to an error.
+ 
+ ## The Boundary Pattern
+ 
+ The key pattern: **never let panics escape your package**.
+ 
+ If your code might panic (or call code that might panic), recover at the boundary:
+ 
+ &#96;&#96;&#96;go
+ // Public API - never panics
+ func (s *Service) ProcessRequest(req Request) (Response, error) {
+     defer func() {
+         if r := recover(); r != nil {
+             // Log, maybe alert
+             log.Printf("panic in ProcessRequest: %v", r)
+         }
+     }()
+     
+     return s.doProcess(req)  // internal, might panic
+ }
+ &#96;&#96;&#96;
+ 
+ HTTP handlers often do this:
+ 
+ &#96;&#96;&#96;go
+ func recoveryMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         defer func() {
+             if err := recover(); err != nil {
+                 log.Printf("panic: %v\n%s", err, debug.Stack())
+                 http.Error(w, "Internal Server Error", 500)
+             }
+         }()
+         next.ServeHTTP(w, r)
+     })
+ }
+ &#96;&#96;&#96;
+ 
+ A panic in a handler becomes a 500 response, not a crashed server.
+ 
+ ## Panic Values
+ 
+ Unlike C# where you throw &#96;Exception&#96; objects, you can panic with any value:
+ 
+ &#96;&#96;&#96;go
+ panic("a string")
+ panic(42)
+ panic(errors.New("an error"))
+ panic(MyCustomType{})
+ &#96;&#96;&#96;
+ 
+ When recovering, you get an &#96;interface{}&#96;:
+ 
+ &#96;&#96;&#96;go
+ if r := recover(); r != nil {
+     switch v := r.(type) {
+     case error:
+         log.Printf("error: %v", v)
+     case string:
+         log.Printf("string: %s", v)
+     default:
+         log.Printf("unknown: %v", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Best practice: panic with &#96;error&#96; values or strings. Makes recovery predictable.
+ 
+ ## Comparison with C#
+ 
+ | Aspect | C# Exceptions | Go Panic/Recover |
+ |--------|---------------|------------------|
+ | Normal errors | Often used | Strongly discouraged |
+ | Programmer bugs | Appropriate | Appropriate |
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;finally&#96; | &#96;defer&#96;/&#96;recover&#96; |
+ | Stack traces | Automatic | Available via &#96;debug.Stack()&#96; |
+ | Filtering | Catch by type | Check recovered value |
+ | Re-throwing | &#96;throw;&#96; | &#96;panic(r)&#96; |
+ | Custom types | Exception subclasses | Any type (usually error) |
+ | Cultural norm | Expected | Emergency only |
+ 
+ ## The Test Exception
+ 
+ One place where panic is universally accepted: tests.
+ 
+ &#96;&#96;&#96;go
+ func TestSomething(t *testing.T) {
+     result := process(input)
+     
+     if result != expected {
+         t.Fatalf("got %v, want %v", result, expected)  // this panics
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;t.Fatal&#96; and &#96;t.Fatalf&#96; panic to abort the test. This is fine—tests are the one place where "stop everything" is the right response to failure.
+ 
+ ## The Honest Take
+ 
+ **When I use panic:**
+ - &#96;Must&#96; functions for startup initialisation
+ - Genuinely impossible conditions (defensive programming)
+ - Test assertions via &#96;t.Fatal&#96;
+ 
+ **When I don't use panic:**
+ - File not found
+ - Network errors
+ - Invalid user input
+ - Anything that can reasonably happen at runtime
+ 
+ **The rule I follow:**
+ If I'm tempted to panic, I ask: "Is this a bug in my program, or is this something that could happen in production?" Bugs can panic. Production conditions should return errors.
+ 
+ ## What About Performance?
+ 
+ One argument for panic: "it's faster because you don't have to check errors at every level."
+ 
+ This is technically true but practically irrelevant. Error checking is a comparison and conditional jump. The performance difference is unmeasurable in real code.
+ 
+ Don't let performance justify panic. If you're that performance-sensitive, you're probably not writing Go anyway.
+ 
+ ---
+ 
+ *Coming up: Go's switch statement—more powerful than C#'s, with type switching, expression cases, and some surprises around fallthrough.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-switch.md</summary>

**Chunk 1**
Lines added: 432, lines removed: 1

```diff
@@ -1,1 +1,432 @@
- 
+ +++
+ title = "The switch Statement You Always Wanted"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "control-flow", "csharp"]
+ +++
+ 
+ C#'s switch statement has evolved a lot over the years. Pattern matching, switch expressions, when guards—it's become genuinely powerful. But Go's switch has some tricks that'll make you wish C# worked this way.
+ 
+ Let's look at what Go's switch can do, including the bits that'll trip you up.
+ 
+ ## Basic Switch: No Fallthrough by Default
+ 
+ First surprise: Go switches don't fall through by default.
+ 
+ &#96;&#96;&#96;csharp
+ // C# - falls through if you forget break (historically)
+ switch (day)
+ {
+     case "Monday":
+         Console.WriteLine("Start of week");
+         break;  // required!
+     case "Friday":
+         Console.WriteLine("End of week");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go - no break needed, no fallthrough
+ switch day {
+ case "Monday":
+     fmt.Println("Start of week")
+     // automatically breaks here
+ case "Friday":
+     fmt.Println("End of week")
+ }
+ &#96;&#96;&#96;
+ 
+ This is a genuine improvement. The C# pattern of requiring &#96;break&#96; after every case was a source of bugs for decades. Go's default—exit after each case—matches what you almost always want.
+ 
+ ## Multiple Values Per Case
+ 
+ Want the same code for multiple cases? In C#:
+ 
+ &#96;&#96;&#96;csharp
+ switch (day)
+ {
+     case "Saturday":
+     case "Sunday":
+         Console.WriteLine("Weekend");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Cleaner. Multiple values in one case clause, comma-separated.
+ 
+ ## No Expression Required
+ 
+ Here's something C# can't do. Go's switch doesn't need an expression:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case hour &lt; 12:
+     fmt.Println("Good morning")
+ case hour &lt; 17:
+     fmt.Println("Good afternoon")
+ default:
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ This is equivalent to an if-else chain but often more readable:
+ 
+ &#96;&#96;&#96;go
+ // Equivalent, but more verbose
+ if hour &lt; 12 {
+     fmt.Println("Good morning")
+ } else if hour &lt; 17 {
+     fmt.Println("Good afternoon")
+ } else {
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ I use expressionless switch constantly. It's particularly good for range checks and complex conditions.
+ 
+ ## Fallthrough (When You Actually Want It)
+ 
+ Sometimes you genuinely need fallthrough. Go has a &#96;fallthrough&#96; keyword:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Thursday":
+     fmt.Println("Almost Friday")
+     fallthrough
+ case "Friday":
+     fmt.Println("Weekend soon!")
+ }
+ 
+ // Thursday prints both lines
+ // Friday prints just "Weekend soon!"
+ &#96;&#96;&#96;
+ 
+ Important: &#96;fallthrough&#96; must be the last statement in a case, and it falls into the next case unconditionally—it doesn't re-evaluate the case expression.
+ 
+ &#96;&#96;&#96;go
+ // This is usually wrong
+ switch x {
+ case 1:
+     fallthrough  // falls into case 2 even if x != 2
+ case 2:
+     doSomething()
+ }
+ &#96;&#96;&#96;
+ 
+ In practice, I rarely use &#96;fallthrough&#96;. Multiple values per case covers most needs.
+ 
+ ## Type Switches
+ 
+ This is where Go's switch shines. You can switch on type:
+ 
+ &#96;&#96;&#96;go
+ func describe(i interface{}) {
+     switch v := i.(type) {
+     case int:
+         fmt.Printf("Integer: %d\n", v)
+     case string:
+         fmt.Printf("String: %s\n", v)
+     case bool:
+         fmt.Printf("Boolean: %t\n", v)
+     case []int:
+         fmt.Printf("Slice of ints: %v\n", v)
+     default:
+         fmt.Printf("Unknown type: %T\n", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;v := i.(type)&#96; syntax extracts both the type (for the case matching) and the value (as the correctly typed &#96;v&#96;).
+ 
+ C# has pattern matching now which does something similar:
+ 
+ &#96;&#96;&#96;csharp
+ static void Describe(object o)
+ {
+     switch (o)
+     {
+         case int i:
+             Console.WriteLine($"Integer: {i}");
+             break;
+         case string s:
+             Console.WriteLine($"String: {s}");
+             break;
+         // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Go got there first, and the syntax is arguable cleaner.
+ 
+ ### Multiple Types Per Case
+ 
+ &#96;&#96;&#96;go
+ switch v := i.(type) {
+ case int, int32, int64:
+     fmt.Println("Some kind of integer")
+     // Note: v is interface{} here, not a specific int type
+ case string, []byte:
+     fmt.Println("String-like")
+ default:
+     fmt.Printf("Type: %T\n", v)
+ }
+ &#96;&#96;&#96;
+ 
+ When you match multiple types, &#96;v&#96; has type &#96;interface{}&#96; because the compiler can't know which type matched.
+ 
+ ## Initialisation Statements
+ 
+ Like &#96;if&#96;, you can have an initialisation statement:
+ 
+ &#96;&#96;&#96;go
+ switch os := runtime.GOOS; os {
+ case "darwin":
+     fmt.Println("macOS")
+ case "linux":
+     fmt.Println("Linux")
+ default:
+     fmt.Printf("Other: %s\n", os)
+ }
+ // os is not visible here
+ &#96;&#96;&#96;
+ 
+ Keeps the variable scoped to where it's used.
+ 
+ ## Comparing to C#'s Switch Expressions
+ 
+ C# 8 added switch expressions, which are excellent:
+ 
+ &#96;&#96;&#96;csharp
+ var message = day switch
+ {
+     "Monday" =&gt; "Start of week",
+     "Friday" =&gt; "End of week",
+     "Saturday" or "Sunday" =&gt; "Weekend",
+     _ =&gt; "Midweek"
+ };
+ &#96;&#96;&#96;
+ 
+ Go doesn't have switch expressions—switch is always a statement, not an expression. You can't do:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work in Go
+ message := switch day {
+ case "Monday":
+     "Start of week"
+ // ...
+ }
+ &#96;&#96;&#96;
+ 
+ You have to use a variable:
+ 
+ &#96;&#96;&#96;go
+ var message string
+ switch day {
+ case "Monday":
+     message = "Start of week"
+ case "Friday":
+     message = "End of week"
+ case "Saturday", "Sunday":
+     message = "Weekend"
+ default:
+     message = "Midweek"
+ }
+ &#96;&#96;&#96;
+ 
+ This is one area where C# is genuinely more elegant.
+ 
+ ## When Guards (Sort Of)
+ 
+ C# has &#96;when&#96; guards in pattern matching:
+ 
+ &#96;&#96;&#96;csharp
+ switch (response)
+ {
+     case HttpResponse { StatusCode: var code } when code &gt;= 400:
+         HandleError(code);
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ Go doesn't have &#96;when&#96;, but expressionless switch achieves similar things:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case response.StatusCode &gt;= 500:
+     handleServerError(response)
+ case response.StatusCode &gt;= 400:
+     handleClientError(response)
+ case response.StatusCode &gt;= 200:
+     handleSuccess(response)
+ }
+ &#96;&#96;&#96;
+ 
+ Not quite as powerful as full pattern matching, but covers most cases.
+ 
+ ## The Default Case
+ 
+ Go's &#96;default&#96; case can appear anywhere (not just at the end):
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ default:
+     fmt.Println("Weekday")
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Convention says put it last, but Go doesn't enforce it.
+ 
+ ## Switching on Errors
+ 
+ A common pattern for error handling:
+ 
+ &#96;&#96;&#96;go
+ err := doSomething()
+ switch {
+ case err == nil:
+     // success
+ case errors.Is(err, ErrNotFound):
+     // handle not found
+ case errors.Is(err, ErrPermissionDenied):
+     // handle permission error
+ default:
+     // unknown error
+     return err
+ }
+ &#96;&#96;&#96;
+ 
+ Sometimes cleaner than a chain of if-else-if.
+ 
+ ## The Comparison
+ 
+ | Feature | C# | Go |
+ |---------|-----|-----|
+ | Break required | No (modern) | No |
+ | Fallthrough | By omitting break (legacy) | &#96;fallthrough&#96; keyword |
+ | Multiple values | &#96;case a, b:&#96; (older) or &#96;case a or b:&#96; | &#96;case a, b:&#96; |
+ | Expression switch | Yes (switch expression) | No (statement only) |
+ | Type switching | Pattern matching | &#96;switch v := x.(type)&#96; |
+ | No expression | No | Yes (&#96;switch { case cond: }&#96;) |
+ | When guards | Yes | No (use expressionless switch) |
+ | Init statement | No | Yes |
+ 
+ ## Practical Patterns
+ 
+ ### State Machine
+ 
+ &#96;&#96;&#96;go
+ type State int
+ 
+ const (
+     StateIdle State = iota
+     StateRunning
+     StatePaused
+     StateStopped
+ )
+ 
+ func (s *Machine) handleEvent(event Event) {
+     switch s.state {
+     case StateIdle:
+         switch event {
+         case EventStart:
+             s.state = StateRunning
+         default:
+             // ignore
+         }
+     case StateRunning:
+         switch event {
+         case EventPause:
+             s.state = StatePaused
+         case EventStop:
+             s.state = StateStopped
+         }
+     // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Command Dispatch
+ 
+ &#96;&#96;&#96;go
+ func handleCommand(cmd string, args []string) error {
+     switch cmd {
+     case "list":
+         return listItems()
+     case "add":
+         if len(args) &lt; 1 {
+             return errors.New("add requires an item name")
+         }
+         return addItem(args[0])
+     case "remove":
+         if len(args) &lt; 1 {
+             return errors.New("remove requires an item name")
+         }
+         return removeItem(args[0])
+     default:
+         return fmt.Errorf("unknown command: %s", cmd)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parsing JSON with Type Switch
+ 
+ &#96;&#96;&#96;go
+ func processValue(v interface{}) {
+     switch val := v.(type) {
+     case map[string]interface{}:
+         for k, v := range val {
+             fmt.Printf("Object key: %s\n", k)
+             processValue(v)  // recurse
+         }
+     case []interface{}:
+         for i, item := range val {
+             fmt.Printf("Array index: %d\n", i)
+             processValue(item)  // recurse
+         }
+     case string:
+         fmt.Printf("String: %s\n", val)
+     case float64:  // JSON numbers are float64
+         fmt.Printf("Number: %f\n", val)
+     case bool:
+         fmt.Printf("Boolean: %t\n", val)
+     case nil:
+         fmt.Println("Null")
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's switch is one of the language's better features:
+ 
+ **Things I like:**
+ - No fallthrough by default (prevents bugs)
+ - Expressionless switch for complex conditions
+ - Type switches for working with interfaces
+ - Multiple values per case
+ - Init statements for scoping
+ 
+ **Things C# does better:**
+ - Switch expressions (returning values directly)
+ - Pattern matching with &#96;when&#96; guards
+ - Recursive patterns (&#96;case Person { Age: &gt; 18 }&#96;)
+ 
+ **The verdict:**
+ Go's switch is simpler and covers the common cases elegantly. C#'s switch has more features for complex matching. Use what each language gives you.
+ 
+ ---
+ 
+ *That wraps up Phase 3 on control flow and error handling. Next we'll move into concurrency—goroutines, channels, and why Go's approach to parallelism is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the Hugo build passes with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      11
---
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 11 posts are now created and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Phase 3 posts are done. Here's the complete series (11 posts now):

## C# to Go Series

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet
3. **"The Phrasebook: C# Concepts in Go Terms"** — Terminology swap, operators, quick reference

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields
6. **"Generics: Late to the Party"** — Go 1.18+ vs C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, workarounds

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"** — Why no exceptions, error wrapping, sentinel errors, custom error types, strategies for living with explicit errors
10. **"Panic and Recover: The Emergency Exit"** — When panic is acceptable (`Must` pattern, init, programmer bugs), the boundary pattern, why you'll get judged for using it like exceptions
11. **"The switch Statement You Always Wanted"** — No fallthrough by default, expressionless switch, type switches, comparing to C#'s pattern matching

The Phase 3 posts cover:
- The philosophical shift from exceptions to explicit error values
- `errors.Is()` and `errors.As()` for error inspection
- The `%w` verb for error wrapping
- Panic/recover mechanics and when they're appropriate
- Go's switch being genuinely better in some ways (no break needed, type switches, expressionless form)
- Where C# is still ahead (switch expressions, pattern matching with when guards)

Ready for Phase 4 (concurrency?) whenever you are!

---

_**User (2025-12-29 10:33Z)**_

The next three posts are below, let's go write them! Add a little more snark to these ones, not over the top but be a little cynical because this section is where dotnet is reallllly good



Memory & Pointers

Pointers Without the Pain — What C# hides that Go makes explicit, and why it's less scary than C++
Stack vs Heap: Go's Escape Analysis — You know ref and Span<T>, now meet Go's approach to allocation
Slices Are Not Arrays (And Neither Is List<T>) — Capacity, length, backing arrays, and the gotchas that will bite you

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants three more posts for Phase 4: Memory & Pointers, and they want me to add a bit more snark/cynicism because this is an area where .NET is really strong. So I should be fair but acknowledge that .NET's memory management and abstractions are genuinely excellent, and Go's explicit approach has trade-offs.

Let me write these with a bit more edge - acknowledging that C#/.NET handles a lot of this better in many ways, but explaining what Go does and why.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md</summary>

**Chunk 1**
Lines added: 258, lines removed: 1

```diff
@@ -1,1 +1,258 @@
- 
+ +++
+ title = "Pointers Without the Pain"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "pointers", "csharp"]
+ +++
+ 
+ Right, let's talk about pointers. If you've spent your career in C#, you've probably used pointers approximately never. Maybe you've seen &#96;unsafe&#96; blocks in performance-critical library code. Maybe you've used &#96;ref&#96; and &#96;Span&lt;T&gt;&#96; and felt rather clever about it.
+ 
+ In Go, pointers are everywhere. Every method receiver decision involves them. Every struct-passing decision involves them. You can't hide from them.
+ 
+ The good news: Go's pointers are considerably less terrifying than C's. The bad news: you actually have to think about them now.
+ 
+ ## What C# Hides
+ 
+ C# makes a neat distinction: value types live on the stack (mostly), reference types live on the heap (mostly), and the runtime figures out the details. You don't think about addresses. You don't think about dereferencing. You just use stuff.
+ 
+ &#96;&#96;&#96;csharp
+ var user = new User { Name = "Alice" };  // heap, reference semantics
+ var point = new Point(10, 20);           // stack (probably), value semantics
+ 
+ ProcessUser(user);   // passes reference
+ ProcessPoint(point); // passes copy
+ &#96;&#96;&#96;
+ 
+ The runtime decides where things actually live. The JIT optimises. Escape analysis happens. You don't care.
+ 
+ Go is more... honest? Explicit? Annoying? All three, depending on your mood.
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice"}   // where does this live? Depends!
+ ptr := &amp;User{Name: "Bob"}     // definitely a pointer
+ 
+ ProcessUser(user)   // passes copy
+ ProcessUser(&amp;user)  // passes pointer
+ ProcessUserPtr(ptr) // passes pointer
+ &#96;&#96;&#96;
+ 
+ You have to think about it. Every time.
+ 
+ ## Go Pointer Basics
+ 
+ The syntax is C-style:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x    // p is *int, pointing to x
+ fmt.Println(*p)  // 42 - dereference to get value
+ *p = 100   // x is now 100
+ &#96;&#96;&#96;
+ 
+ Creating pointers to composite literals:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ user := &amp;User{Name: "Alice"}
+ 
+ // vs
+ user := new(User)
+ user.Name = "Alice"
+ 
+ // vs
+ var user User
+ user.Name = "Alice"
+ userPtr := &amp;user
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;&#96; operator gives you a pointer. The &#96;*&#96; operator dereferences. If you've touched C or C++ at any point, this is familiar.
+ 
+ ## The Nice Bit: Automatic Dereferencing
+ 
+ Unlike C, Go automatically dereferences pointers for field and method access:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ func (u *User) SetName(name string) {
+     u.Name = name  // not (*u).Name, just u.Name
+ }
+ 
+ user := &amp;User{}
+ user.Name = "Alice"  // works, auto-dereferenced
+ user.SetName("Bob")  // works
+ &#96;&#96;&#96;
+ 
+ This is a genuine quality-of-life improvement over C. You don't need &#96;-&gt;&#96; vs &#96;.&#96; confusion. Dot notation works for both values and pointers.
+ 
+ ## The Not-Nice Bit: Nil Pointer Panics
+ 
+ C# has &#96;NullReferenceException&#96;. Go has nil pointer panics. Same problem, different name.
+ 
+ &#96;&#96;&#96;go
+ var user *User = nil
+ fmt.Println(user.Name)  // panic: runtime error: invalid memory address
+ &#96;&#96;&#96;
+ 
+ No nullable reference types. No compile-time null safety. Just runtime panics.
+ 
+ C# 8+ with nullable reference types:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = null;
+ Console.WriteLine(user.Name);  // compiler warning: possible null reference
+ &#96;&#96;&#96;
+ 
+ Go doesn't help you here. You check for nil manually, or you panic at runtime. Welcome to 2009.
+ 
+ ## When to Use Pointers
+ 
+ The decision tree:
+ 
+ **Use pointers when:**
+ 
+ 1. **The method modifies the receiver**
+    &#96;&#96;&#96;go
+    func (u *User) SetEmail(email string) {
+        u.Email = email  // needs to modify the original
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **The struct is large**
+    &#96;&#96;&#96;go
+    type BigStruct struct {
+        Data [1024]byte
+        // ... lots of fields
+    }
+    
+    func Process(b *BigStruct) {  // don't copy 1KB every call
+        // ...
+    }
+    &#96;&#96;&#96;
+ 
+ 3. **You need nil to mean "absent"**
+    &#96;&#96;&#96;go
+    type Config struct {
+        Timeout *time.Duration  // nil means "not set", use default
+    }
+    &#96;&#96;&#96;
+ 
+ 4. **Consistency with other methods on the type**
+    If some methods need pointer receivers, use pointers everywhere for that type. Mixing is legal but confusing.
+ 
+ **Use values when:**
+ 
+ 1. **The data is small and immutable**
+    &#96;&#96;&#96;go
+    type Point struct {
+        X, Y int
+    }
+    
+    func (p Point) Distance(other Point) float64 {
+        // fine to copy two ints
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **You want copy-on-pass safety**
+    Value semantics mean the callee can't modify your data.
+ 
+ 3. **The zero value is useful**
+    &#96;&#96;&#96;go
+    var mu sync.Mutex  // zero Mutex is valid, unlocked
+    &#96;&#96;&#96;
+ 
+ ## The "Everything Is a Pointer Receiver" School
+ 
+ Some Go developers just use pointer receivers everywhere. It's simpler. Consistent. No thinking required.
+ 
+ &#96;&#96;&#96;go
+ func (u *User) Name() string { return u.name }      // pointer receiver
+ func (u *User) SetName(n string) { u.name = n }    // pointer receiver
+ func (u *User) IsActive() bool { return u.active } // pointer receiver
+ &#96;&#96;&#96;
+ 
+ Is this optimal? No. Does it matter? Rarely.
+ 
+ The performance difference between passing a pointer vs a small struct is negligible for most code. Consistency and clarity usually matter more.
+ 
+ ## What You Can't Do
+ 
+ Go's pointers are garbage-collected. You can't:
+ 
+ - Do pointer arithmetic (no &#96;p++&#96; to walk through memory)
+ - Free memory manually (the GC handles it)
+ - Have dangling pointers (the GC keeps referenced memory alive)
+ - Cast pointers to integers (without &#96;unsafe&#96;)
+ 
+ This is why Go pointers are "safe"—they're really just references with explicit syntax. All the scary C stuff is locked behind the &#96;unsafe&#96; package.
+ 
+ ## The &#96;unsafe&#96; Package
+ 
+ Go has an escape hatch:
+ 
+ &#96;&#96;&#96;go
+ import "unsafe"
+ 
+ func scary() {
+     var x int64 = 42
+     ptr := unsafe.Pointer(&amp;x)
+     // Now you can do terrible things
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;unsafe&#96; package lets you:
+ - Convert between pointer types
+ - Do pointer arithmetic
+ - Access struct padding
+ - Generally shoot yourself in the foot
+ 
+ If you're using &#96;unsafe&#96; outside of extremely low-level code, you're probably doing something wrong. It exists for syscalls, memory-mapped I/O, and interop—not for your web handlers.
+ 
+ ## Comparing to C# &#96;ref&#96; and Pointers
+ 
+ C# has several ways to get pointer-like semantics:
+ 
+ | C# | Go Equivalent | Notes |
+ |-----|---------------|-------|
+ | &#96;ref&#96; parameter | &#96;*T&#96; parameter | Pass by reference |
+ | &#96;in&#96; parameter | &#96;*T&#96; (readonly discipline) | Go has no &#96;const&#96; pointers |
+ | &#96;out&#96; parameter | &#96;*T&#96; or multiple returns | Go prefers multiple returns |
+ | &#96;Span&lt;T&gt;&#96; | Slices | Different semantics, similar purpose |
+ | &#96;unsafe&#96; pointers | &#96;unsafe.Pointer&#96; | Both are escape hatches |
+ | &#96;ref struct&#96; | No equivalent | Go doesn't have stack-only types |
+ 
+ C#'s &#96;ref struct&#96; and &#96;Span&lt;T&gt;&#96; are genuinely more sophisticated than anything Go offers. If you're doing zero-allocation parsing or high-performance buffer manipulation, .NET's tooling is better.
+ 
+ Go's answer is "use slices and let the GC handle it." Less control, simpler mental model, occasionally more allocation.
+ 
+ ## The Honest Take
+ 
+ Look, I'll be straight with you: C#'s memory model is more sophisticated. The runtime does more for you. Nullable reference types catch null bugs at compile time. &#96;Span&lt;T&gt;&#96; gives you safe, zero-copy views into memory. &#96;ref struct&#96; prevents heap allocation entirely.
+ 
+ Go gives you... pointers. The same pointers we've had since the 1970s, except garbage-collected so you can't corrupt memory.
+ 
+ **What Go does better:**
+ - Simpler mental model (it's just pointers)
+ - Explicit about copies vs references
+ - No hidden boxing/unboxing
+ - Can't accidentally capture stack memory (escape analysis handles it)
+ 
+ **What C# does better:**
+ - Nullable reference types
+ - &#96;Span&lt;T&gt;&#96; and memory-safe slicing
+ - &#96;ref struct&#96; for stack-only types  
+ - More escape hatches that are actually usable (&#96;stackalloc&#96;, etc.)
+ - The whole &#96;System.Memory&#96; namespace
+ 
+ **The verdict:**
+ If you're writing performance-critical code where every allocation matters, C# has more tools. If you're writing normal application code, Go's "just use pointers" simplicity is fine.
+ 
+ You'll write &#96;*User&#96; a lot. You'll occasionally forget to check for nil. You'll survive.
+ 
+ ---
+ 
+ *Next up: stack vs heap allocation and escape analysis—Go decides where your variables live, and you don't always get a vote.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-escape-analysis.md</summary>

**Chunk 1**
Lines added: 306, lines removed: 1

```diff
@@ -1,1 +1,306 @@
- 
+ +++
+ title = "Stack vs Heap: Go's Escape Analysis"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "performance", "csharp"]
+ +++
+ 
+ In C#, you mostly don't think about where variables live. Value types go on the stack (usually). Reference types go on the heap (always). The runtime and JIT make optimisations. You trust the process.
+ 
+ In Go, you still mostly don't think about it—but for different reasons. Go decides where things live at compile time through something called escape analysis. And sometimes it makes choices that'll surprise you.
+ 
+ ## The C# Mental Model
+ 
+ C#'s rules are pretty clear:
+ 
+ &#96;&#96;&#96;csharp
+ void Example()
+ {
+     int x = 42;           // stack - value type, local variable
+     Point p = new(1, 2);  // stack - value type (assuming Point is a struct)
+     
+     var user = new User(); // heap - reference type, always
+     var boxed = (object)x; // heap - boxing allocates
+ }
+ &#96;&#96;&#96;
+ 
+ Value types on stack (unless boxed, captured in closures, or part of a heap object). Reference types on heap. Simple.
+ 
+ .NET has more tricks now—&#96;stackalloc&#96;, &#96;Span&lt;T&gt;&#96;, &#96;ref struct&#96;—but the basic model is straightforward.
+ 
+ ## Go's Escape Analysis
+ 
+ Go doesn't have value types vs reference types in the C# sense. Structs can live on the stack or heap. The compiler decides based on whether the value "escapes" the function.
+ 
+ &#96;&#96;&#96;go
+ func stackAllocation() {
+     x := 42           // stack (probably)
+     user := User{}    // stack (probably)
+     process(&amp;user)    // might change things...
+ }
+ 
+ func heapAllocation() *User {
+     user := User{}    // heap - returned pointer escapes
+     return &amp;user
+ }
+ &#96;&#96;&#96;
+ 
+ The key insight: **if a pointer to something outlives the function, it must be on the heap**. Go figures this out at compile time.
+ 
+ ## Seeing Escape Analysis
+ 
+ You can ask the compiler what it's doing:
+ 
+ &#96;&#96;&#96;bash
+ go build -gcflags="-m" ./...
+ &#96;&#96;&#96;
+ 
+ Output looks like:
+ 
+ &#96;&#96;&#96;
+ ./main.go:10:2: moved to heap: user
+ ./main.go:15:9: &amp;Config{...} escapes to heap
+ ./main.go:20:2: result does not escape
+ &#96;&#96;&#96;
+ 
+ This is genuinely useful for performance work. You can see exactly what's allocating.
+ 
+ ## What Makes Things Escape
+ 
+ ### Returning Pointers
+ 
+ &#96;&#96;&#96;go
+ func newUser() *User {
+     u := User{Name: "Alice"}  // escapes - returned pointer
+     return &amp;u
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;u&#96; pointer is returned, so &#96;u&#96; must outlive the function. Heap.
+ 
+ ### Storing in Interface Values
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     var w io.Writer = &amp;bytes.Buffer{}  // escapes - interface storage
+ }
+ &#96;&#96;&#96;
+ 
+ Interface values often cause heap allocation because the compiler can't always prove the lifetime.
+ 
+ ### Closures Capturing Variables
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42
+     f := func() {
+         fmt.Println(x)  // x escapes - captured by closure
+     }
+     go f()
+ }
+ &#96;&#96;&#96;
+ 
+ Closures that outlive the function (like goroutines) force captures to the heap.
+ 
+ ### Too Large for Stack
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     data := make([]byte, 10*1024*1024)  // 10MB - escapes due to size
+ }
+ &#96;&#96;&#96;
+ 
+ Very large allocations go to the heap regardless of escape.
+ 
+ ### Pointer Stored in Slice or Map
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     users := make([]*User, 0)
+     u := User{Name: "Alice"}
+     users = append(users, &amp;u)  // u escapes - pointer stored in slice
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Stays on the Stack
+ 
+ ### Local Variables Not Referenced
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42          // stack
+     y := x + 1       // stack
+     fmt.Println(y)   // y's value copied to Println, y stays on stack
+ }
+ &#96;&#96;&#96;
+ 
+ ### Pointers That Don't Escape
+ 
+ &#96;&#96;&#96;go
+ func process(u *User) {
+     u.Name = "modified"  // u doesn't escape, caller's stack
+ }
+ 
+ func example() {
+     user := User{}
+     process(&amp;user)  // user can stay on stack - &amp;user doesn't escape process
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler traces through calls to see if pointers ultimately escape.
+ 
+ ## Comparing to .NET
+ 
+ Here's where I get cynical: .NET's approach is more sophisticated and gives you more control.
+ 
+ ### &#96;stackalloc&#96;
+ 
+ &#96;&#96;&#96;csharp
+ Span&lt;byte&gt; buffer = stackalloc byte[1024];
+ // Guaranteed stack allocation, zero heap involvement
+ &#96;&#96;&#96;
+ 
+ Go can't do this. You can't force stack allocation. The compiler decides.
+ 
+ ### &#96;ref struct&#96;
+ 
+ &#96;&#96;&#96;csharp
+ ref struct Parser 
+ {
+     private Span&lt;char&gt; _buffer;
+     // Can ONLY live on stack, compiler enforced
+ }
+ &#96;&#96;&#96;
+ 
+ Go has no equivalent. You can't declare "this type must never be heap-allocated."
+ 
+ ### &#96;Span&lt;T&gt;&#96; Without Allocation
+ 
+ &#96;&#96;&#96;csharp
+ void Process(ReadOnlySpan&lt;char&gt; text)
+ {
+     var slice = text[10..20];  // no allocation, just pointer arithmetic
+ }
+ &#96;&#96;&#96;
+ 
+ Go slices are similar but the escape analysis is less predictable.
+ 
+ ### What .NET Gets Right
+ 
+ The JIT can do escape analysis too, and it can make different decisions at runtime based on actual usage patterns. Go's compile-time analysis is conservative—it heap-allocates when unsure.
+ 
+ &#96;&#96;&#96;csharp
+ // .NET JIT might stack-allocate this if it proves the object doesn't escape
+ var temp = new StringBuilder();
+ temp.Append("hello");
+ return temp.ToString();
+ // StringBuilder might be optimised away entirely
+ &#96;&#96;&#96;
+ 
+ Go's compiler is good, but it doesn't have runtime profile-guided optimisation.
+ 
+ ## The Practical Impact
+ 
+ Does this matter? Sometimes.
+ 
+ For most code—web handlers, CLI tools, data processing—the GC is fast enough that escape analysis is academic. Things allocate, they get collected, life goes on.
+ 
+ For hot paths processing millions of events per second, allocation pressure matters. And here's the uncomfortable truth: **Go gives you less control than C#**.
+ 
+ You can't say "put this on the stack." You can't create stack-only types. You can write code that the compiler *will* stack-allocate, but you're working with the compiler, not commanding it.
+ 
+ ### Tricks That Help
+ 
+ **Sync.Pool for reusable objects:**
+ 
+ &#96;&#96;&#96;go
+ var bufferPool = sync.Pool{
+     New: func() interface{} {
+         return make([]byte, 4096)
+     },
+ }
+ 
+ func process() {
+     buf := bufferPool.Get().([]byte)
+     defer bufferPool.Put(buf)
+     // use buf...
+ }
+ &#96;&#96;&#96;
+ 
+ This doesn't avoid allocation—it reuses allocations. Different problem, similar goal.
+ 
+ **Passing values instead of pointers for small structs:**
+ 
+ &#96;&#96;&#96;go
+ // This might heap-allocate due to interface
+ func process(r io.Reader) { ... }
+ 
+ // This won't heap-allocate
+ func processBytes(data []byte) { ... }
+ &#96;&#96;&#96;
+ 
+ Sometimes avoiding interfaces avoids allocation. But you lose flexibility.
+ 
+ **Preallocating slices:**
+ 
+ &#96;&#96;&#96;go
+ // Might grow and reallocate multiple times
+ results := make([]Result, 0)
+ 
+ // Single allocation if you know the size
+ results := make([]Result, 0, expectedSize)
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ I'll be blunt: if you're coming from .NET and you care deeply about allocation control, Go will frustrate you.
+ 
+ .NET gives you:
+ - &#96;stackalloc&#96; for explicit stack allocation
+ - &#96;ref struct&#96; for stack-only types
+ - &#96;Span&lt;T&gt;&#96; for zero-allocation slicing
+ - &#96;ArrayPool&lt;T&gt;&#96; for buffer reuse with a clean API
+ - Object pooling with sophisticated lifetime management
+ - JIT optimisations that can eliminate allocations entirely
+ 
+ Go gives you:
+ - Escape analysis that usually does the right thing
+ - &#96;sync.Pool&#96; for object reuse (but with interface{} boxing before 1.18)
+ - The ability to check what escapes with compiler flags
+ - A fast garbage collector that makes most of this not matter
+ 
+ **When Go's approach works:**
+ - You're building services with reasonable latency requirements
+ - You're not processing millions of messages per second per core
+ - You value simplicity over maximum control
+ - You're okay trading some performance for less complexity
+ 
+ **When you'll miss .NET:**
+ - Sub-millisecond latency requirements
+ - Zero-GC paths are necessary
+ - You need guaranteed stack allocation
+ - High-frequency trading, game engines, real-time systems
+ 
+ For 90% of software, Go's escape analysis is fine. The GC is good. You won't notice. For the other 10%, .NET genuinely has better tools.
+ 
+ ## Checking Your Allocations
+ 
+ Profile before optimising:
+ 
+ &#96;&#96;&#96;bash
+ # Run benchmarks with allocation stats
+ go test -bench=. -benchmem
+ 
+ # Trace allocations
+ go tool pprof -alloc_space profile.out
+ 
+ # See escape decisions
+ go build -gcflags="-m -m" ./...  # extra -m for more detail
+ &#96;&#96;&#96;
+ 
+ Know what's actually allocating before you fight the compiler.
+ 
+ ---
+ 
+ *Next up: slices in depth—they're not arrays, they're not List&lt;T&gt;, and the gotchas around capacity, length, and shared backing arrays will bite you eventually.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-slices.md</summary>

**Chunk 1**
Lines added: 301, lines removed: 1

```diff
@@ -1,1 +1,301 @@
- 
+ +++
+ title = "Slices Are Not Arrays (And Neither Is List&lt;T&gt;)"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "slices", "csharp"]
+ +++
+ 
+ Every C# developer coming to Go makes the same mistake: they see &#96;[]int&#96; and think "array" or "list." It's neither. It's a slice, and it has semantics that will bite you if you don't understand them.
+ 
+ This is one of those Go concepts that seems simple until it isn't. Let's dig in.
+ 
+ ## What a Slice Actually Is
+ 
+ A slice is a struct with three fields:
+ 
+ &#96;&#96;&#96;go
+ // Conceptually:
+ type slice struct {
+     array *T   // pointer to underlying array
+     len   int  // number of elements in use
+     cap   int  // total capacity of underlying array
+ }
+ &#96;&#96;&#96;
+ 
+ When you create a slice, you're creating this header. The actual data lives in a backing array somewhere.
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3, 4, 5}
+ // s.array -&gt; [1, 2, 3, 4, 5, _, _, _]  (backing array, might have extra capacity)
+ // s.len = 5
+ // s.cap = 5 (or more)
+ &#96;&#96;&#96;
+ 
+ This is fundamentally different from both C# arrays and &#96;List&lt;T&gt;&#96;.
+ 
+ ## The C# Mental Model (And Why It's Wrong Here)
+ 
+ **C# arrays** are fixed-size, directly hold their data:
+ 
+ &#96;&#96;&#96;csharp
+ int[] arr = new int[5];
+ // arr IS the array, fixed size, done
+ &#96;&#96;&#96;
+ 
+ **C# List&lt;T&gt;** wraps an array with growth semantics:
+ 
+ &#96;&#96;&#96;csharp
+ var list = new List&lt;int&gt; { 1, 2, 3 };
+ list.Add(4);  // might reallocate internally
+ // But list is a reference type - you always work with the same list object
+ &#96;&#96;&#96;
+ 
+ **Go slices** are value types that point to arrays:
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3}
+ s = append(s, 4)  // might return a NEW slice header pointing to NEW array
+ &#96;&#96;&#96;
+ 
+ That last line is where people get burned. &#96;append&#96; might modify the backing array in place, or it might allocate a new array and return a slice pointing to it. **You must use the return value.**
+ 
+ ## The append Trap
+ 
+ This looks fine:
+ 
+ &#96;&#96;&#96;go
+ func addItem(items []int, item int) {
+     items = append(items, item)
+ }
+ 
+ func main() {
+     s := []int{1, 2, 3}
+     addItem(s, 4)
+     fmt.Println(s)  // [1 2 3] - item wasn't added!
+ }
+ &#96;&#96;&#96;
+ 
+ The slice header is passed by value. &#96;append&#96; creates a new header (possibly pointing to a new array), but that new header only exists inside &#96;addItem&#96;. The caller's &#96;s&#96; is unchanged.
+ 
+ Fixes:
+ 
+ &#96;&#96;&#96;go
+ // Option 1: Return the new slice
+ func addItem(items []int, item int) []int {
+     return append(items, item)
+ }
+ 
+ s = addItem(s, 4)  // use the return value
+ 
+ // Option 2: Use a pointer to slice (less common)
+ func addItem(items *[]int, item int) {
+     *items = append(*items, item)
+ }
+ 
+ addItem(&amp;s, 4)
+ &#96;&#96;&#96;
+ 
+ In C#, this wouldn't be a problem—&#96;List&lt;T&gt;&#96; is a reference type:
+ 
+ &#96;&#96;&#96;csharp
+ void AddItem(List&lt;int&gt; items, int item) {
+     items.Add(item);  // modifies the actual list
+ }
+ &#96;&#96;&#96;
+ 
+ Go's slice is not a reference type. It's a value type that contains a pointer. Subtle but critical difference.
+ 
+ ## Shared Backing Arrays (The Real Gotcha)
+ 
+ Here's where it gets properly dangerous:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice1 := original[1:3]  // [2, 3]
+ slice2 := original[2:4]  // [3, 4]
+ 
+ slice1[1] = 999  // modify slice1
+ 
+ fmt.Println(original)  // [1 2 999 4 5]
+ fmt.Println(slice1)    // [2 999]
+ fmt.Println(slice2)    // [999 4]
+ &#96;&#96;&#96;
+ 
+ All three slices share the same backing array. Modify one, you modify them all.
+ 
+ This is nothing like C#:
+ 
+ &#96;&#96;&#96;csharp
+ var original = new int[] { 1, 2, 3, 4, 5 };
+ var slice = original[1..3];  // creates a NEW array in C# 8+
+ slice[1] = 999;
+ Console.WriteLine(string.Join(", ", original));  // 1, 2, 3, 4, 5 - unchanged
+ &#96;&#96;&#96;
+ 
+ C# ranges create copies. Go slices share memory. Neither is wrong, but they're completely different behaviours.
+ 
+ ### The Capacity Gotcha
+ 
+ It gets worse. When you slice, you might have hidden capacity:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice := original[1:3]  // [2, 3], but capacity is 4!
+ 
+ fmt.Println(len(slice))  // 2
+ fmt.Println(cap(slice))  // 4 - can see elements 1-4 of original
+ 
+ slice = append(slice, 999)  // doesn't allocate new array - overwrites original!
+ 
+ fmt.Println(original)  // [1 2 3 999 5] - element 3 (index 3) was overwritten
+ &#96;&#96;&#96;
+ 
+ The &#96;append&#96; saw capacity, used it, and stomped on data that logically wasn't part of &#96;slice&#96; but physically was in the backing array.
+ 
+ To prevent this:
+ 
+ &#96;&#96;&#96;go
+ // Limit capacity when slicing
+ slice := original[1:3:3]  // [low:high:max] - capacity is high-low = 2
+ 
+ // Or copy explicitly
+ slice := make([]int, 2)
+ copy(slice, original[1:3])
+ &#96;&#96;&#96;
+ 
+ ## Length vs Capacity
+ 
+ This distinction doesn't exist in &#96;List&lt;T&gt;&#96; (internally it does, but you don't see it):
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 3, 10)  // length 3, capacity 10
+ fmt.Println(len(s))  // 3
+ fmt.Println(cap(s))  // 10
+ 
+ s[0] = 1  // OK
+ s[5] = 1  // panic: index out of range - len is 3!
+ 
+ s = s[:cap(s)]  // extend slice to full capacity
+ s[5] = 1        // now OK
+ &#96;&#96;&#96;
+ 
+ Length is how many elements are accessible. Capacity is how many could be before reallocation. This is an implementation detail that Go exposes and expects you to understand.
+ 
+ ## nil vs Empty Slice
+ 
+ Oh good, more nil pain:
+ 
+ &#96;&#96;&#96;go
+ var s1 []int          // nil slice
+ s2 := []int{}         // empty slice
+ s3 := make([]int, 0)  // empty slice
+ 
+ fmt.Println(s1 == nil)  // true
+ fmt.Println(s2 == nil)  // false
+ fmt.Println(s3 == nil)  // false
+ 
+ // But they all behave the same for most operations
+ fmt.Println(len(s1), len(s2), len(s3))  // 0 0 0
+ &#96;&#96;&#96;
+ 
+ A nil slice and an empty slice are functionally equivalent for &#96;len&#96;, &#96;cap&#96;, &#96;append&#96;, and &#96;range&#96;. But they're not equal to each other, and some JSON encoders treat them differently.
+ 
+ &#96;&#96;&#96;go
+ json.Marshal(s1)  // might produce "null"
+ json.Marshal(s2)  // produces "[]"
+ &#96;&#96;&#96;
+ 
+ Wonderful.
+ 
+ ## Patterns That Help
+ 
+ ### Always Capture append's Return
+ 
+ &#96;&#96;&#96;go
+ s = append(s, item)  // always assign back
+ &#96;&#96;&#96;
+ 
+ ### Copy When Returning Subslices
+ 
+ &#96;&#96;&#96;go
+ func getSubset(data []int) []int {
+     subset := data[10:20]
+     
+     // Bad: caller might have data, mutating subset affects data
+     return subset
+     
+     // Good: caller gets independent slice
+     result := make([]int, len(subset))
+     copy(result, subset)
+     return result
+ }
+ &#96;&#96;&#96;
+ 
+ ### Preallocate When Size Is Known
+ 
+ &#96;&#96;&#96;go
+ // Might reallocate multiple times
+ results := []int{}
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Single allocation
+ results := make([]int, 0, len(items))
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Or even better, known length
+ results := make([]int, len(items))
+ for i, item := range items {
+     results[i] = transform(item)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Use the Three-Index Slice for Safety
+ 
+ &#96;&#96;&#96;go
+ // Dangerous: slice might have hidden capacity
+ sub := data[a:b]
+ 
+ // Safe: capacity is limited
+ sub := data[a:b:b]
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Array | C# List&lt;T&gt; | Go Slice |
+ |--------|----------|------------|----------|
+ | Fixed size | Yes | No | No |
+ | Reference type | Yes | Yes | No (value type with pointer) |
+ | Slicing copies | Yes (ranges) | N/A | No (shares memory) |
+ | append semantics | N/A | Add modifies list | Returns new header |
+ | Hidden capacity | No | Yes (internal) | Yes (exposed) |
+ | nil vs empty | null vs new int[0] | null vs new List | Different behaviours |
+ 
+ ## The Honest Take
+ 
+ Slices are Go's most footgun-laden feature. They look simple, they have subtle semantics, and the gotchas aren't obvious until you've been bitten.
+ 
+ **What Go gets right:**
+ - Efficient memory sharing when you want it
+ - Clear distinction between length and capacity
+ - &#96;append&#96; is convenient (when used correctly)
+ - No boxing, good cache locality
+ 
+ **What C# does better:**
+ - &#96;List&lt;T&gt;&#96; is a reference type—modifications are visible everywhere
+ - Range slicing copies by default—no surprise aliasing
+ - &#96;Span&lt;T&gt;&#96; gives you explicit no-copy semantics when you want them
+ - You don't have to remember the three-index slice syntax
+ 
+ **The verdict:**
+ Slices are powerful and efficient. They're also a sharp tool that will cut you. Every Go developer has been bitten by shared backing arrays or forgotten &#96;append&#96; returns.
+ 
+ My advice: be paranoid about slice aliasing. Copy when returning subslices. Always use the return value of &#96;append&#96;. And when something mutates unexpectedly, check your slices first.
+ 
+ ---
+ 
+ *That wraps up the memory section. Next we'll move into concurrency—goroutines, channels, and why Go's approach is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all these new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
      14
---
-rw-r--r--  1 andycross  staff  10095 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   9266 Dec 29 07:53 content/posts/dotnet-to-go-errors.md
-rw-r--r--  1 andycross  staff   8268 Dec 29 15:26 content/posts/dotnet-to-go-escape-analysis.md
-rw-r--r--  1 andycross  staff   8876 Dec 28 20:26 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8501 Dec 28 20:26 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8319 Dec 29 07:53 content/posts/dotnet-to-go-panic.md
-rw-r--r--  1 andycross  staff  10755 Dec 29 07:48 content/posts/dotnet-to-go-phrasebook.md
-rw-r--r--  1 andycross  staff   8107 Dec 29 15:25 content/posts/dotnet-to-go-pointers.md
-rw-r--r--  1 andycross  staff   8294 Dec 29 15:27 content/posts/dotnet-to-go-slices.md
-rw-r--r--  1 andycross  staff   8748 Dec 29 07:49 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   9594 Dec 29 07:53 content/posts/dotnet-to-go-switch.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9253 Dec 28 20:26 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 posts build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Memory & Pointers posts are done. 14 posts total now, with appropriate snark about .NET's superiority in this area. Here's the updated series:

## C# to Go Series (14 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"**
2. **"Goodbye .csproj, Hello go.mod"**
3. **"The Phrasebook: C# Concepts in Go Terms"**

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"**
5. **"Where Did My Properties Go?"**
6. **"Generics: Late to the Party"**
7. **"The Million Dollar Mistake, Differently"**
8. **"No Enums? No Problem (Sort Of)"**

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"**
10. **"Panic and Recover: The Emergency Exit"**
11. **"The switch Statement You Always Wanted"**

### Phase 4: Memory & Pointers ← **NEW**
12. **"Pointers Without the Pain"** — What C# hides, automatic dereferencing, nil panics, when to use pointers, acknowledging that nullable reference types are better
13. **"Stack vs Heap: Go's Escape Analysis"** — Compile-time decisions, what escapes, the `-gcflags="-m"` trick, lamenting the lack of `stackalloc`, `ref struct`, and `Span<T>`
14. **"Slices Are Not Arrays (And Neither Is List<T>)"** — The append trap, shared backing arrays, the three-index slice, capacity gotchas, why this is Go's most footgun-laden feature

Key themes in the memory posts:
- Honest acknowledgment that .NET has better tools (`Span<T>`, `ref struct`, nullable references, `stackalloc`)
- Go gives you less control but a simpler mental model
- The slice semantics will absolutely bite you
- Escape analysis is good but you can't force stack allocation

Ready for Phase 5 (concurrency) whenever you want to tackle goroutines vs async/await!

---

_**User (2025-12-29 17:28Z)**_

update the one about pointers to detail what dereferencing means, effectively following the pointer to the thing that is pointed at, which is a bit of a mouthful so that's why we use a lil * 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to update the pointers post to better explain what dereferencing means. The post was deleted according to the context, so I need to rewrite it with the added explanation about dereferencing - "following the pointer to the thing that is pointed at."

Let me rewrite the pointers post with a clearer explanation of dereferencing early on.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md</summary>

**Chunk 1**
Lines added: 292, lines removed: 1

```diff
@@ -1,1 +1,292 @@
- 
+ +++
+ title = "Pointers Without the Pain"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "pointers", "csharp"]
+ +++
+ 
+ Right, let's talk about pointers. If you've spent your career in C#, you've probably used pointers approximately never. Maybe you've seen &#96;unsafe&#96; blocks in performance-critical library code. Maybe you've used &#96;ref&#96; and &#96;Span&lt;T&gt;&#96; and felt rather clever about it.
+ 
+ In Go, pointers are everywhere. Every method receiver decision involves them. Every struct-passing decision involves them. You can't hide from them.
+ 
+ The good news: Go's pointers are considerably less terrifying than C's. The bad news: you actually have to think about them now.
+ 
+ ## What C# Hides
+ 
+ C# makes a neat distinction: value types live on the stack (mostly), reference types live on the heap (mostly), and the runtime figures out the details. You don't think about addresses. You don't think about dereferencing. You just use stuff.
+ 
+ &#96;&#96;&#96;csharp
+ var user = new User { Name = "Alice" };  // heap, reference semantics
+ var point = new Point(10, 20);           // stack (probably), value semantics
+ 
+ ProcessUser(user);   // passes reference
+ ProcessPoint(point); // passes copy
+ &#96;&#96;&#96;
+ 
+ The runtime decides where things actually live. The JIT optimises. Escape analysis happens. You don't care.
+ 
+ Go is more... honest? Explicit? Annoying? All three, depending on your mood.
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice"}   // where does this live? Depends!
+ ptr := &amp;User{Name: "Bob"}     // definitely a pointer
+ 
+ ProcessUser(user)   // passes copy
+ ProcessUser(&amp;user)  // passes pointer
+ ProcessUserPtr(ptr) // passes pointer
+ &#96;&#96;&#96;
+ 
+ You have to think about it. Every time.
+ 
+ ## Go Pointer Basics
+ 
+ The syntax is C-style:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x    // p is *int, pointing to x
+ fmt.Println(*p)  // 42 - dereference to get value
+ *p = 100   // x is now 100
+ &#96;&#96;&#96;
+ 
+ Two operators, two meanings:
+ 
+ - &#96;&amp;&#96; means "give me the address of this thing"—where it lives in memory
+ - &#96;*&#96; means "follow this address to the thing it points at"—dereferencing
+ 
+ ### What's Dereferencing?
+ 
+ If a pointer is an address—"the data lives at memory location 0x1234"—then dereferencing is following that address to get the actual data. It's a bit of a mouthful: "follow the pointer to the thing that is pointed at." That's why we just use a little &#96;*&#96;.
+ 
+ Think of it like a postal address. The pointer &#96;p&#96; is the address on an envelope. Dereferencing &#96;*p&#96; is going to that address and looking at what's actually there.
+ 
+ &#96;&#96;&#96;go
+ x := 42       // x is the value 42, stored somewhere in memory
+ p := &amp;x       // p holds the address of x (like "123 Memory Lane")
+               // p itself is *int - "a pointer to an int"
+ 
+ fmt.Println(p)   // prints an address like 0xc000012345
+ fmt.Println(*p)  // prints 42 - we followed the address to get the value
+ 
+ *p = 100      // go to that address, change what's stored there
+ fmt.Println(x)   // prints 100 - x changed because p points to x
+ &#96;&#96;&#96;
+ 
+ The &#96;*&#96; does double duty in Go (and C):
+ - In a type declaration, &#96;*int&#96; means "pointer to int"
+ - As an operator, &#96;*p&#96; means "dereference p—follow the pointer"
+ 
+ This is confusing for about a week, then it becomes second nature.
+ 
+ ### Creating Pointers
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ user := &amp;User{Name: "Alice"}
+ 
+ // vs
+ user := new(User)
+ user.Name = "Alice"
+ 
+ // vs
+ var user User
+ user.Name = "Alice"
+ userPtr := &amp;user
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;&#96; operator gives you a pointer. The &#96;*&#96; operator dereferences. If you've touched C or C++ at any point, this is familiar.
+ 
+ ## The Nice Bit: Automatic Dereferencing
+ 
+ Unlike C, Go automatically dereferences pointers for field and method access:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ func (u *User) SetName(name string) {
+     u.Name = name  // not (*u).Name, just u.Name
+ }
+ 
+ user := &amp;User{}
+ user.Name = "Alice"  // works, auto-dereferenced
+ user.SetName("Bob")  // works
+ &#96;&#96;&#96;
+ 
+ In C, you'd write &#96;user-&gt;Name&#96; for pointer access and &#96;user.Name&#96; for value access. Go just uses dot notation for both and figures it out.
+ 
+ This is a genuine quality-of-life improvement. You don't need &#96;-&gt;&#96; vs &#96;.&#96; confusion. Dot notation works for both values and pointers.
+ 
+ ## The Not-Nice Bit: Nil Pointer Panics
+ 
+ C# has &#96;NullReferenceException&#96;. Go has nil pointer panics. Same problem, different name.
+ 
+ &#96;&#96;&#96;go
+ var user *User = nil
+ fmt.Println(user.Name)  // panic: runtime error: invalid memory address
+ &#96;&#96;&#96;
+ 
+ When you try to dereference a nil pointer—follow an address that doesn't point anywhere—Go panics. There's nothing at that address to read.
+ 
+ No nullable reference types. No compile-time null safety. Just runtime panics.
+ 
+ C# 8+ with nullable reference types:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = null;
+ Console.WriteLine(user.Name);  // compiler warning: possible null reference
+ &#96;&#96;&#96;
+ 
+ Go doesn't help you here. You check for nil manually, or you panic at runtime. Welcome to 2009.
+ 
+ ## When to Use Pointers
+ 
+ The decision tree:
+ 
+ **Use pointers when:**
+ 
+ 1. **The method modifies the receiver**
+    &#96;&#96;&#96;go
+    func (u *User) SetEmail(email string) {
+        u.Email = email  // needs to modify the original
+    }
+    &#96;&#96;&#96;
+    Without the pointer, &#96;SetEmail&#96; would modify a copy, and the caller's &#96;User&#96; would be unchanged.
+ 
+ 2. **The struct is large**
+    &#96;&#96;&#96;go
+    type BigStruct struct {
+        Data [1024]byte
+        // ... lots of fields
+    }
+    
+    func Process(b *BigStruct) {  // don't copy 1KB every call
+        // ...
+    }
+    &#96;&#96;&#96;
+ 
+ 3. **You need nil to mean "absent"**
+    &#96;&#96;&#96;go
+    type Config struct {
+        Timeout *time.Duration  // nil means "not set", use default
+    }
+    &#96;&#96;&#96;
+ 
+ 4. **Consistency with other methods on the type**
+    If some methods need pointer receivers, use pointers everywhere for that type. Mixing is legal but confusing.
+ 
+ **Use values when:**
+ 
+ 1. **The data is small and immutable**
+    &#96;&#96;&#96;go
+    type Point struct {
+        X, Y int
+    }
+    
+    func (p Point) Distance(other Point) float64 {
+        // fine to copy two ints
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **You want copy-on-pass safety**
+    Value semantics mean the callee can't modify your data.
+ 
+ 3. **The zero value is useful**
+    &#96;&#96;&#96;go
+    var mu sync.Mutex  // zero Mutex is valid, unlocked
+    &#96;&#96;&#96;
+ 
+ ## The "Everything Is a Pointer Receiver" School
+ 
+ Some Go developers just use pointer receivers everywhere. It's simpler. Consistent. No thinking required.
+ 
+ &#96;&#96;&#96;go
+ func (u *User) Name() string { return u.name }      // pointer receiver
+ func (u *User) SetName(n string) { u.name = n }    // pointer receiver
+ func (u *User) IsActive() bool { return u.active } // pointer receiver
+ &#96;&#96;&#96;
+ 
+ Is this optimal? No. Does it matter? Rarely.
+ 
+ The performance difference between passing a pointer vs a small struct is negligible for most code. Consistency and clarity usually matter more.
+ 
+ ## What You Can't Do
+ 
+ Go's pointers are garbage-collected. You can't:
+ 
+ - Do pointer arithmetic (no &#96;p++&#96; to walk through memory)
+ - Free memory manually (the GC handles it)
+ - Have dangling pointers (the GC keeps referenced memory alive)
+ - Cast pointers to integers (without &#96;unsafe&#96;)
+ 
+ This is why Go pointers are "safe"—they're really just references with explicit syntax. All the scary C stuff is locked behind the &#96;unsafe&#96; package.
+ 
+ ## The &#96;unsafe&#96; Package
+ 
+ Go has an escape hatch:
+ 
+ &#96;&#96;&#96;go
+ import "unsafe"
+ 
+ func scary() {
+     var x int64 = 42
+     ptr := unsafe.Pointer(&amp;x)
+     // Now you can do terrible things
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;unsafe&#96; package lets you:
+ - Convert between pointer types
+ - Do pointer arithmetic
+ - Access struct padding
+ - Generally shoot yourself in the foot
+ 
+ If you're using &#96;unsafe&#96; outside of extremely low-level code, you're probably doing something wrong. It exists for syscalls, memory-mapped I/O, and interop—not for your web handlers.
+ 
+ ## Comparing to C# &#96;ref&#96; and Pointers
+ 
+ C# has several ways to get pointer-like semantics:
+ 
+ | C# | Go Equivalent | Notes |
+ |-----|---------------|-------|
+ | &#96;ref&#96; parameter | &#96;*T&#96; parameter | Pass by reference |
+ | &#96;in&#96; parameter | &#96;*T&#96; (readonly discipline) | Go has no &#96;const&#96; pointers |
+ | &#96;out&#96; parameter | &#96;*T&#96; or multiple returns | Go prefers multiple returns |
+ | &#96;Span&lt;T&gt;&#96; | Slices | Different semantics, similar purpose |
+ | &#96;unsafe&#96; pointers | &#96;unsafe.Pointer&#96; | Both are escape hatches |
+ | &#96;ref struct&#96; | No equivalent | Go doesn't have stack-only types |
+ 
+ C#'s &#96;ref struct&#96; and &#96;Span&lt;T&gt;&#96; are genuinely more sophisticated than anything Go offers. If you're doing zero-allocation parsing or high-performance buffer manipulation, .NET's tooling is better.
+ 
+ Go's answer is "use slices and let the GC handle it." Less control, simpler mental model, occasionally more allocation.
+ 
+ ## The Honest Take
+ 
+ Look, I'll be straight with you: C#'s memory model is more sophisticated. The runtime does more for you. Nullable reference types catch null bugs at compile time. &#96;Span&lt;T&gt;&#96; gives you safe, zero-copy views into memory. &#96;ref struct&#96; prevents heap allocation entirely.
+ 
+ Go gives you... pointers. The same pointers we've had since the 1970s, except garbage-collected so you can't corrupt memory.
+ 
+ **What Go does better:**
+ - Simpler mental model (it's just pointers)
+ - Explicit about copies vs references
+ - No hidden boxing/unboxing
+ - Can't accidentally capture stack memory (escape analysis handles it)
+ 
+ **What C# does better:**
+ - Nullable reference types
+ - &#96;Span&lt;T&gt;&#96; and memory-safe slicing
+ - &#96;ref struct&#96; for stack-only types  
+ - More escape hatches that are actually usable (&#96;stackalloc&#96;, etc.)
+ - The whole &#96;System.Memory&#96; namespace
+ 
+ **The verdict:**
+ If you're writing performance-critical code where every allocation matters, C# has more tools. If you're writing normal application code, Go's "just use pointers" simplicity is fine.
+ 
+ You'll write &#96;*User&#96; a lot. You'll occasionally forget to check for nil. You'll survive.
+ 
+ ---
+ 
+ *Next up: stack vs heap allocation and escape analysis—Go decides where your variables live, and you don't always get a vote.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build passes.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful"</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful"
```

```
Build successful

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Build passed. The pointers post now has a better explanation of dereferencing.</details></think>

---

Done. I've expanded the dereferencing explanation with:

1. **A clear definition**: "following that address to get the actual data"
2. **The "mouthful" acknowledgment**: explaining why we use `*` instead of saying "follow the pointer to the thing that is pointed at"
3. **A postal address analogy**: pointer is like an address on an envelope, dereferencing is going to that address
4. **A worked example** showing the relationship between `x`, `p`, `&x`, and `*p` with comments
5. **The dual meaning of `*`**: in type declarations (`*int`) vs as an operator (`*p`)

The key addition:

```go
x := 42       // x is the value 42, stored somewhere in memory
p := &x       // p holds the address of x (like "123 Memory Lane")
              // p itself is *int - "a pointer to an int"

fmt.Println(p)   // prints an address like 0xc000012345
fmt.Println(*p)  // prints 42 - we followed the address to get the value

*p = 100      // go to that address, change what's stored there
fmt.Println(x)   // prints 100 - x changed because p points to x
```

---

_**User (2025-12-29 17:28Z)**_

look at the git not staged log, what is with all the deletions?! that's really surprising to me 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user is asking about git status - they're surprised to see deletions in the unstaged changes. Let me check what's going on with git status.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && git status</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && git status
```

```
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
	modified:   .specstory/history/2025-12-28_20-16Z-c#-to-go-blog-content-series.md
	deleted:    content/posts/dotnet-to-go-errors.md
	deleted:    content/posts/dotnet-to-go-escape-analysis.md
	deleted:    content/posts/dotnet-to-go-panic.md
	modified:   content/posts/dotnet-to-go-pointers.md
	deleted:    content/posts/dotnet-to-go-slices.md
	deleted:    content/posts/dotnet-to-go-switch.md
	modified:   content/posts/streaming-json-partial-parser.md

no changes added to commit (use "git add" and/or "git commit -a")

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
That's very strange - the files I created are showing as deleted! But wait, looking at the context earlier, the user's `<deleted_files>` section showed those same files. It seems like those files were deleted outside of my actions, perhaps by the user or some other process.

Let me check if those files actually exist on disk:</details></think>

---

That's strange! Let me check if those files actually exist on disk:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md</summary>

```bash
ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md
```

```
-rw-r--r--  1 andycross  staff  10095 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   8876 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8501 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff  10755 Dec 29 07:48 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-phrasebook.md
-rw-r--r--  1 andycross  staff   9789 Dec 29 18:05 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md
-rw-r--r--  1 andycross  staff   8748 Dec 29 07:49 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9253 Dec 28 20:26 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Okay, so those 5 files (errors, escape-analysis, panic, slices, switch) were deleted and are no longer on disk. Only 9 files exist now, not 14.

Looking back at the conversation context, I see `<deleted_files>` was in the user's last message before they asked me to update the pointers post. Those files must have been deleted by the user (or they rejected/reverted those changes somehow) between when I created them and when they asked me to update the pointers post.

The files that are missing:
- dotnet-to-go-errors.md (Phase 3)
- dotnet-to-go-panic.md (Phase 3)
- dotnet-to-go-switch.md (Phase 3)
- dotnet-to-go-escape-analysis.md (Phase 4)
- dotnet-to-go-slices.md (Phase 4)

So we've lost all of Phase 3 and 2 of the 3 Phase 4 posts. Only the pointers post survived from those batches.

Let me tell the user what happened.</details></think>

---

Ah, I see what happened! Five files are genuinely missing from disk:

**Missing files (were created, now gone):**
- `dotnet-to-go-errors.md` (Phase 3)
- `dotnet-to-go-panic.md` (Phase 3)
- `dotnet-to-go-switch.md` (Phase 3)
- `dotnet-to-go-escape-analysis.md` (Phase 4)
- `dotnet-to-go-slices.md` (Phase 4)

**Still exist:**
- Phase 1: toolchain, modules, phrasebook ✓
- Phase 2: structs, visibility, generics, nil, enums ✓
- Phase 4: pointers ✓ (just updated)

It looks like those files were deleted somewhere between when I created them and now. The `<deleted_files>` section showed up in your previous message's context, which suggests they were removed (perhaps you rejected those file creations, or deleted them manually?).

Want me to recreate the missing posts? That would be:
- **Phase 3** (all 3): errors, panic, switch
- **Phase 4** (2 of 3): escape-analysis, slices

---

_**User (2025-12-29 17:28Z)**_

use git to pull them back

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to restore the deleted files from git. Since they show as "deleted" in the unstaged changes, I can use `git restore` to bring them back.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && git restore content/posts/dotnet-to-go-errors.md content/posts/dotnet-to-go-escape-analysis.md content/posts/dotnet-to-go-panic.md content/posts/dotnet-to-go-slices.md content/posts/dotnet-to-go-switch.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && git restore content/posts/dotnet-to-go-errors.md content/posts/dotnet-to-go-escape-analysis.md content/posts/dotnet-to-go-panic.md content/posts/dotnet-to-go-slices.md content/posts/dotnet-to-go-switch.md
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify all the files are back.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
      14
---
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 files are restored. Let me verify the build still passes.</details></think>

---

All 14 posts restored. Let me verify the build still works:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && git status --short</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && git status --short
```

```
Build successful
 M .specstory/history/2025-12-28_20-16Z-c#-to-go-blog-content-series.md
 M content/posts/dotnet-to-go-pointers.md
 M content/posts/streaming-json-partial-parser.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 posts are back, the build passes, and the only modifications now are:- The pointers post (which I updated with the dereferencing explanation)- Some specstory file (internal tracking)- streaming-json-partial-parser (not sure why that's modified, but it's unrelated to our work)No more deletions showing.</details></think>

---

All sorted. 14 posts back, build passes, and git status now only shows modifications (no deletions):

- `dotnet-to-go-pointers.md` — the dereferencing explanation we just added
- Two other modified files unrelated to the series

Ready to continue with Phase 5 (concurrency) whenever you like!

---

_**User (2025-12-29 17:28Z)**_

here's our concurrency list, let's go!

Concurrency

Async/Await vs Goroutines: A Mindset Shift — Why Go's model feels backwards until it clicks
Channels: The sync You Didn't Know You Wanted — Producer/consumer patterns without BlockingCollection
select: Multiplexing Like a Pro — Handling multiple channels, timeouts, and cancellation
Mutexes and WaitGroups: When Channels Aren't the Answer — sync package deep-dive for C# devs who know their locks
Context Is King — Cancellation tokens, but make it Go

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the 5 concurrency posts. This is where Go genuinely shines compared to C#'s async/await model in many ways, so I should be fair but also highlight where Go's model is genuinely elegant. Let me write all 5 posts.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-goroutines.md</summary>

**Chunk 1**
Lines added: 298, lines removed: 1

```diff
@@ -1,1 +1,298 @@
- 
+ +++
+ title = "Async/Await vs Goroutines: A Mindset Shift"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "async", "csharp"]
+ +++
+ 
+ Here's the thing about Go's concurrency model: it's going to feel backwards. You've spent years learning that async operations need &#96;async&#96; keywords, &#96;await&#96; expressions, &#96;Task&lt;T&gt;&#96; return types, and careful thought about which thread you're on.
+ 
+ Go throws all of that out. Any function can be concurrent. There's no special syntax. No coloured functions. No async/await virus spreading through your codebase.
+ 
+ It feels wrong until suddenly it doesn't.
+ 
+ ## The C# Model: Async All the Way Down
+ 
+ In C#, concurrency is opt-in and explicit:
+ 
+ &#96;&#96;&#96;csharp
+ public async Task&lt;User&gt; GetUserAsync(int id)
+ {
+     var response = await _httpClient.GetAsync($"/users/{id}");
+     var json = await response.Content.ReadAsStringAsync();
+     return JsonSerializer.Deserialize&lt;User&gt;(json);
+ }
+ 
+ public async Task ProcessUsersAsync()
+ {
+     var user1 = await GetUserAsync(1);
+     var user2 = await GetUserAsync(2);
+     // Sequential - second waits for first
+ }
+ &#96;&#96;&#96;
+ 
+ Want parallel execution?
+ 
+ &#96;&#96;&#96;csharp
+ public async Task ProcessUsersAsync()
+ {
+     var task1 = GetUserAsync(1);
+     var task2 = GetUserAsync(2);
+     var users = await Task.WhenAll(task1, task2);
+     // Parallel - both run concurrently
+ }
+ &#96;&#96;&#96;
+ 
+ This model is explicit, type-safe, and viral—once you have an async function, everything that calls it tends to become async too.
+ 
+ ## The Go Model: Just... Go
+ 
+ Go's approach is radically simpler:
+ 
+ &#96;&#96;&#96;go
+ func GetUser(id int) (*User, error) {
+     resp, err := http.Get(fmt.Sprintf("/users/%d", id))
+     if err != nil {
+         return nil, err
+     }
+     defer resp.Body.Close()
+     
+     var user User
+     if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil {
+         return nil, err
+     }
+     return &amp;user, nil
+ }
+ &#96;&#96;&#96;
+ 
+ Notice: no async keyword. No special return type. It's just a function.
+ 
+ Want to run it concurrently? Add the &#96;go&#96; keyword:
+ 
+ &#96;&#96;&#96;go
+ go GetUser(1)  // runs in background, returns immediately
+ go GetUser(2)  // also runs in background
+ &#96;&#96;&#96;
+ 
+ That's it. Any function can be spawned as a goroutine. No syntax changes to the function itself.
+ 
+ ## What's a Goroutine?
+ 
+ A goroutine is a lightweight thread managed by Go's runtime. Think of it as a Task that's:
+ 
+ - **Cheaper**: Goroutines start with ~2KB stack (vs ~1MB for OS threads)
+ - **Multiplexed**: Go's scheduler runs thousands of goroutines on a few OS threads
+ - **Implicit**: No &#96;Task.Run()&#96; ceremony—just &#96;go f()&#96;
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     for i := 0; i &lt; 10000; i++ {
+         go func(n int) {
+             fmt.Println(n)
+         }(i)
+     }
+     time.Sleep(time.Second)  // wait for goroutines (crude, we'll fix this)
+ }
+ &#96;&#96;&#96;
+ 
+ Spawning 10,000 goroutines is fine. Spawning 10,000 OS threads would kill your machine.
+ 
+ ## The Problem: Getting Results Back
+ 
+ Here's where things get interesting. When you &#96;go&#96; a function, you can't get its return value:
+ 
+ &#96;&#96;&#96;go
+ result := go GetUser(1)  // DOESN'T WORK - go doesn't return anything
+ &#96;&#96;&#96;
+ 
+ The &#96;go&#96; keyword fires and forgets. If you need results, you need **channels**—which we'll cover properly in the next post. For now, here's a taste:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     results := make(chan *User, 2)
+     
+     go func() {
+         user, _ := GetUser(1)
+         results &lt;- user
+     }()
+     
+     go func() {
+         user, _ := GetUser(2)
+         results &lt;- user
+     }()
+     
+     user1 := &lt;-results
+     user2 := &lt;-results
+     fmt.Println(user1, user2)
+ }
+ &#96;&#96;&#96;
+ 
+ More verbose than &#96;Task.WhenAll&#96;? Yes. More flexible? Also yes. But we're getting ahead of ourselves.
+ 
+ ## No Coloured Functions
+ 
+ This is the big philosophical difference. In C#, functions are "coloured":
+ 
+ - **Red functions** (&#96;async&#96;): Can use &#96;await&#96;, return &#96;Task&lt;T&gt;&#96;
+ - **Blue functions** (sync): Can't use &#96;await&#96;, return &#96;T&#96; directly
+ - Red can call blue, but blue calling red is awkward
+ 
+ This leads to the "async all the way down" pattern. One async function at the bottom of your call stack, and suddenly everything above it needs to be async too.
+ 
+ Go doesn't have coloured functions. Every function is the same colour:
+ 
+ &#96;&#96;&#96;go
+ // These are identical in signature
+ func DoSyncThing() error { ... }
+ func DoAsyncThing() error { ... }  // might internally use goroutines
+ 
+ // Caller doesn't know or care
+ err := DoSyncThing()
+ err = DoAsyncThing()
+ &#96;&#96;&#96;
+ 
+ The caller decides whether to run something concurrently:
+ 
+ &#96;&#96;&#96;go
+ DoSyncThing()      // blocking
+ go DoSyncThing()   // concurrent
+ 
+ DoAsyncThing()     // blocking (waits for internal goroutines)
+ go DoAsyncThing()  // concurrent
+ &#96;&#96;&#96;
+ 
+ ## Blocking Is Fine
+ 
+ In C#, blocking an async operation is a code smell:
+ 
+ &#96;&#96;&#96;csharp
+ // DON'T DO THIS - can deadlock, wastes threads
+ var result = GetUserAsync(1).Result;
+ &#96;&#96;&#96;
+ 
+ In Go, blocking is the default and it's fine:
+ 
+ &#96;&#96;&#96;go
+ // Totally normal
+ user, err := GetUser(1)
+ &#96;&#96;&#96;
+ 
+ Why? Because Go's scheduler is cooperative. When a goroutine blocks on I/O, the scheduler runs other goroutines on the same OS thread. You're not tying up a thread pool thread—you're just pausing one goroutine.
+ 
+ This is why Go doesn't need async/await. Blocking calls don't waste resources because the runtime handles the multiplexing.
+ 
+ ## When This Feels Better
+ 
+ **Simple concurrent operations:**
+ 
+ &#96;&#96;&#96;go
+ // Go
+ go sendEmail(user)
+ go updateAnalytics(event)
+ go notifySlack(message)
+ // All three run concurrently, fire-and-forget
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;csharp
+ // C# equivalent
+ _ = Task.Run(() =&gt; SendEmailAsync(user));
+ _ = Task.Run(() =&gt; UpdateAnalyticsAsync(event));
+ _ = Task.Run(() =&gt; NotifySlackAsync(message));
+ // More ceremony, and those discards feel wrong
+ &#96;&#96;&#96;
+ 
+ **CPU-bound parallelism:**
+ 
+ &#96;&#96;&#96;go
+ // Go
+ for _, item := range items {
+     go process(item)
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ Parallel.ForEach(items, item =&gt; Process(item));
+ // Or
+ await Task.WhenAll(items.Select(item =&gt; ProcessAsync(item)));
+ &#96;&#96;&#96;
+ 
+ Both work, but Go's is more uniform—same syntax for I/O-bound and CPU-bound concurrency.
+ 
+ ## When C# Feels Better
+ 
+ **Structured async flow:**
+ 
+ &#96;&#96;&#96;csharp
+ var user = await GetUserAsync(id);
+ var orders = await GetOrdersAsync(user.Id);
+ var summary = await BuildSummaryAsync(user, orders);
+ return summary;
+ &#96;&#96;&#96;
+ 
+ This sequential async flow is clean in C#. In Go, you'd write the same thing without any special syntax—which is fine, but you don't get the visual markers of "this is I/O."
+ 
+ **Parallel with results:**
+ 
+ &#96;&#96;&#96;csharp
+ var tasks = ids.Select(id =&gt; GetUserAsync(id));
+ var users = await Task.WhenAll(tasks);
+ &#96;&#96;&#96;
+ 
+ Go requires more scaffolding for this pattern (channels, WaitGroups). We'll cover it, but it's more code.
+ 
+ **Cancellation:**
+ 
+ C#'s &#96;CancellationToken&#96; integrates beautifully with async/await. Go's &#96;context.Context&#96; is similar but more manual. We'll cover this in a later post.
+ 
+ ## The Mental Shift
+ 
+ Here's what took me time to internalise:
+ 
+ 1. **Functions don't need to declare their concurrency potential**. Any function can be &#96;go&#96;'d.
+ 
+ 2. **Blocking is fine**. The scheduler handles it. Stop feeling guilty about synchronous calls.
+ 
+ 3. **Concurrency is at the call site, not the definition**. You decide whether to wait or fire-and-forget when you call, not when you write the function.
+ 
+ 4. **Communication replaces shared state**. Instead of returning values, goroutines send results through channels.
+ 
+ 5. **No thread pool to configure**. GOMAXPROCS controls parallelism. The scheduler does the rest.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# async/await | Go goroutines |
+ |--------|---------------|---------------|
+ | Syntax | &#96;async&#96;/&#96;await&#96; keywords | &#96;go&#96; keyword |
+ | Return values | &#96;Task&lt;T&gt;&#96; | Channels |
+ | Function colouring | Yes (async vs sync) | No |
+ | Blocking | Discouraged | Normal |
+ | Cancellation | &#96;CancellationToken&#96; | &#96;context.Context&#96; |
+ | Thread model | Thread pool | M:N scheduling |
+ | Overhead | ~300 bytes per Task | ~2KB per goroutine |
+ | Debugging | Excellent tooling | Good, improving |
+ 
+ ## The Honest Take
+ 
+ Go's concurrency model is simpler to start with and scales well. The lack of function colouring is genuinely liberating—no more "async virus" infecting your codebase.
+ 
+ But C#'s model is more explicit about what's happening. When you see &#96;await&#96;, you know there's a potential suspension point. In Go, any function call might block, and that's... fine, but less visible.
+ 
+ **What Go does better:**
+ - No function colouring
+ - Lightweight goroutines (spawn thousands easily)
+ - Blocking is natural, not wasteful
+ - Uniform syntax for all concurrency
+ 
+ **What C# does better:**
+ - Explicit suspension points
+ - &#96;Task.WhenAll&#96; for collecting results
+ - Better tooling and debugging
+ - Clearer error propagation in async flows
+ 
+ Neither is objectively better. They're different philosophies. Go says "concurrency should be easy, let the runtime handle scheduling." C# says "concurrency should be explicit, let the developer see what's happening."
+ 
+ ---
+ 
+ *Next up: channels—Go's answer to BlockingCollection, and the primary way goroutines communicate.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-channels.md</summary>

**Chunk 1**
Lines added: 341, lines removed: 1

```diff
@@ -1,1 +1,341 @@
- 
+ +++
+ title = "Channels: The sync You Didn't Know You Wanted"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "channels", "csharp"]
+ +++
+ 
+ If goroutines are Go's lightweight threads, channels are how they talk to each other. Think &#96;BlockingCollection&lt;T&gt;&#96; meets message passing, with first-class language support.
+ 
+ The Go mantra is: **"Don't communicate by sharing memory; share memory by communicating."** Channels are how you do that.
+ 
+ ## The Basics
+ 
+ A channel is a typed conduit for sending and receiving values:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)  // unbuffered channel of ints
+ 
+ // Send (blocks until someone receives)
+ ch &lt;- 42
+ 
+ // Receive (blocks until someone sends)
+ value := &lt;-ch
+ &#96;&#96;&#96;
+ 
+ The &#96;&lt;-&#96; operator does both sending and receiving—the arrow points in the direction of data flow.
+ 
+ ## Buffered vs Unbuffered
+ 
+ **Unbuffered channels** synchronise sender and receiver:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)  // unbuffered
+ 
+ go func() {
+     ch &lt;- 1  // blocks here until main receives
+     fmt.Println("sent")
+ }()
+ 
+ time.Sleep(time.Second)
+ fmt.Println(&lt;-ch)  // "sent" prints after this line
+ &#96;&#96;&#96;
+ 
+ The sender blocks until the receiver is ready. This creates a synchronisation point—a "handshake" between goroutines.
+ 
+ **Buffered channels** have capacity:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int, 3)  // buffer of 3
+ 
+ ch &lt;- 1  // doesn't block
+ ch &lt;- 2  // doesn't block
+ ch &lt;- 3  // doesn't block
+ ch &lt;- 4  // NOW it blocks - buffer full
+ &#96;&#96;&#96;
+ 
+ Sends only block when the buffer is full. Receives only block when the buffer is empty.
+ 
+ ## The C# Comparison: BlockingCollection
+ 
+ C#'s closest equivalent is &#96;BlockingCollection&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ var collection = new BlockingCollection&lt;int&gt;(boundedCapacity: 3);
+ 
+ // Producer
+ Task.Run(() =&gt; {
+     collection.Add(1);
+     collection.Add(2);
+     collection.CompleteAdding();
+ });
+ 
+ // Consumer
+ foreach (var item in collection.GetConsumingEnumerable())
+ {
+     Console.WriteLine(item);
+ }
+ &#96;&#96;&#96;
+ 
+ Go's version:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int, 3)
+ 
+ // Producer
+ go func() {
+     ch &lt;- 1
+     ch &lt;- 2
+     close(ch)
+ }()
+ 
+ // Consumer
+ for item := range ch {
+     fmt.Println(item)
+ }
+ &#96;&#96;&#96;
+ 
+ Similar pattern, but channels are built into the language. No &#96;using System.Collections.Concurrent&#96;, no &#96;GetConsumingEnumerable()&#96;. Just &#96;range&#96; over the channel.
+ 
+ ## Closing Channels
+ 
+ Closing a channel signals "no more values coming":
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ 
+ go func() {
+     ch &lt;- 1
+     ch &lt;- 2
+     close(ch)  // signal completion
+ }()
+ 
+ for v := range ch {
+     fmt.Println(v)  // prints 1, then 2, then loop exits
+ }
+ &#96;&#96;&#96;
+ 
+ Important rules:
+ 
+ - Only senders should close channels (receivers don't know when senders are done)
+ - Sending on a closed channel panics
+ - Receiving from a closed channel returns the zero value immediately
+ - You can check if a channel is closed: &#96;v, ok := &lt;-ch&#96; (ok is false if closed)
+ 
+ &#96;&#96;&#96;go
+ v, ok := &lt;-ch
+ if !ok {
+     fmt.Println("channel closed")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Common Patterns
+ 
+ ### Fan-Out: One Producer, Many Consumers
+ 
+ &#96;&#96;&#96;go
+ func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
+     for job := range jobs {
+         results &lt;- job * 2  // process and send result
+     }
+ }
+ 
+ func main() {
+     jobs := make(chan int, 100)
+     results := make(chan int, 100)
+ 
+     // Start 3 workers
+     for w := 1; w &lt;= 3; w++ {
+         go worker(w, jobs, results)
+     }
+ 
+     // Send jobs
+     for j := 1; j &lt;= 9; j++ {
+         jobs &lt;- j
+     }
+     close(jobs)
+ 
+     // Collect results
+     for r := 1; r &lt;= 9; r++ {
+         fmt.Println(&lt;-results)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Notice the channel direction syntax:
+ - &#96;jobs &lt;-chan int&#96; — receive-only channel
+ - &#96;results chan&lt;- int&#96; — send-only channel
+ 
+ This prevents workers from accidentally closing &#96;jobs&#96; or reading from &#96;results&#96;.
+ 
+ ### Fan-In: Many Producers, One Consumer
+ 
+ &#96;&#96;&#96;go
+ func producer(id int, ch chan&lt;- string) {
+     for i := 0; i &lt; 3; i++ {
+         ch &lt;- fmt.Sprintf("producer %d: message %d", id, i)
+     }
+ }
+ 
+ func main() {
+     ch := make(chan string)
+ 
+     go producer(1, ch)
+     go producer(2, ch)
+     go producer(3, ch)
+ 
+     for i := 0; i &lt; 9; i++ {
+         fmt.Println(&lt;-ch)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Multiple producers send to one channel. The consumer receives interleaved messages.
+ 
+ ### Pipeline: Chain of Transformations
+ 
+ &#96;&#96;&#96;go
+ func generate(nums ...int) &lt;-chan int {
+     out := make(chan int)
+     go func() {
+         for _, n := range nums {
+             out &lt;- n
+         }
+         close(out)
+     }()
+     return out
+ }
+ 
+ func square(in &lt;-chan int) &lt;-chan int {
+     out := make(chan int)
+     go func() {
+         for n := range in {
+             out &lt;- n * n
+         }
+         close(out)
+     }()
+     return out
+ }
+ 
+ func main() {
+     // Pipeline: generate -&gt; square -&gt; print
+     for n := range square(generate(1, 2, 3, 4)) {
+         fmt.Println(n)  // 1, 4, 9, 16
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Each stage runs in its own goroutine. Data flows through channels. This is remarkably similar to LINQ or Rx, but with explicit concurrency.
+ 
+ ## Getting Results from Multiple Goroutines
+ 
+ Remember the "fire and forget" problem with goroutines? Channels solve it:
+ 
+ &#96;&#96;&#96;go
+ func fetchUser(id int, ch chan&lt;- *User) {
+     user, _ := getUser(id)  // simplified error handling
+     ch &lt;- user
+ }
+ 
+ func main() {
+     ch := make(chan *User, 2)
+     
+     go fetchUser(1, ch)
+     go fetchUser(2, ch)
+     
+     user1 := &lt;-ch
+     user2 := &lt;-ch
+     
+     fmt.Println(user1, user2)
+ }
+ &#96;&#96;&#96;
+ 
+ This is Go's answer to &#96;Task.WhenAll&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ var users = await Task.WhenAll(GetUserAsync(1), GetUserAsync(2));
+ &#96;&#96;&#96;
+ 
+ Go's version is more verbose, but gives you control over how results are collected.
+ 
+ ## Error Handling with Channels
+ 
+ Channels carry one type. If you need values and errors, use a struct:
+ 
+ &#96;&#96;&#96;go
+ type Result struct {
+     User  *User
+     Error error
+ }
+ 
+ func fetchUser(id int, ch chan&lt;- Result) {
+     user, err := getUser(id)
+     ch &lt;- Result{User: user, Error: err}
+ }
+ 
+ func main() {
+     ch := make(chan Result, 2)
+     
+     go fetchUser(1, ch)
+     go fetchUser(2, ch)
+     
+     for i := 0; i &lt; 2; i++ {
+         result := &lt;-ch
+         if result.Error != nil {
+             fmt.Println("error:", result.Error)
+             continue
+         }
+         fmt.Println("user:", result.User)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Clunkier than C#'s exception propagation through Tasks, but explicit.
+ 
+ ## When Channels Are the Wrong Tool
+ 
+ Channels aren't always the answer:
+ 
+ - **Simple mutex protection**: If you just need to guard a shared variable, &#96;sync.Mutex&#96; is simpler
+ - **Reference counting**: Use &#96;sync.WaitGroup&#96;
+ - **One-time events**: Use &#96;sync.Once&#96;
+ - **Atomic counters**: Use &#96;sync/atomic&#96;
+ 
+ Go's proverb is "share memory by communicating," but sometimes sharing memory with a mutex is fine. We'll cover when in a later post.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# BlockingCollection | Go Channels |
+ |--------|----------------------|-------------|
+ | Syntax | Library type | Language primitive |
+ | Bounded | Yes (constructor) | Yes (make with size) |
+ | Direction typing | No | Yes (&#96;&lt;-chan&#96;, &#96;chan&lt;-&#96;) |
+ | Closing | &#96;CompleteAdding()&#96; | &#96;close()&#96; |
+ | Iteration | &#96;GetConsumingEnumerable()&#96; | &#96;range&#96; |
+ | Multiple consumers | Manual coordination | Built-in fair scheduling |
+ | Select/multiplex | No direct equivalent | &#96;select&#96; statement |
+ 
+ ## The Honest Take
+ 
+ Channels are genuinely elegant. They're built into the language, they compose well, and they make producer-consumer patterns trivial.
+ 
+ **What Go does better:**
+ - First-class language support
+ - Direction typing prevents bugs
+ - &#96;select&#96; for multiplexing (next post)
+ - Clean iteration with &#96;range&#96;
+ 
+ **What C# does better:**
+ - Easier result collection with &#96;Task.WhenAll&#96;
+ - Exception propagation through task chains
+ - More familiar for developers from OOP backgrounds
+ - &#96;Channel&lt;T&gt;&#96; in .NET Core is actually quite nice
+ 
+ **The verdict:**
+ If you're doing producer-consumer, pipelines, or fan-out/fan-in patterns, channels are delightful. If you're doing request-response where you need a result back, they're more ceremony than &#96;await&#96;.
+ 
+ ---
+ 
+ *Next up: the &#96;select&#96; statement—multiplexing channels, handling timeouts, and non-blocking operations.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-select.md</summary>

**Chunk 1**
Lines added: 302, lines removed: 1

```diff
@@ -1,1 +1,302 @@
- 
+ +++
+ title = "select: Multiplexing Like a Pro"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "channels", "csharp"]
+ +++
+ 
+ The &#96;select&#96; statement is where Go's channel system goes from "neat" to "powerful." It lets you wait on multiple channel operations simultaneously, handle timeouts, and do non-blocking checks—all with clean syntax.
+ 
+ C# doesn't have a direct equivalent. The closest is &#96;Task.WhenAny&#96;, but &#96;select&#96; is more flexible and more deeply integrated.
+ 
+ ## Basic select
+ 
+ &#96;select&#96; waits on multiple channel operations and executes whichever is ready first:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case msg := &lt;-ch1:
+     fmt.Println("received from ch1:", msg)
+ case msg := &lt;-ch2:
+     fmt.Println("received from ch2:", msg)
+ }
+ &#96;&#96;&#96;
+ 
+ If both channels have data, one is chosen randomly (fair scheduling). If neither has data, &#96;select&#96; blocks until one does.
+ 
+ ## Timeouts
+ 
+ This is where &#96;select&#96; shines. Implementing a timeout:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case result := &lt;-ch:
+     fmt.Println("got result:", result)
+ case &lt;-time.After(3 * time.Second):
+     fmt.Println("timeout!")
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;time.After&#96; returns a channel that receives a value after the duration. If your main channel doesn't deliver in 3 seconds, the timeout case fires.
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ var task = GetResultAsync();
+ var completed = await Task.WhenAny(task, Task.Delay(TimeSpan.FromSeconds(3)));
+ 
+ if (completed == task)
+ {
+     var result = await task;
+     Console.WriteLine($"got result: {result}");
+ }
+ else
+ {
+     Console.WriteLine("timeout!");
+ }
+ &#96;&#96;&#96;
+ 
+ More verbose, and the result handling is awkward.
+ 
+ ## Non-Blocking Operations
+ 
+ Add a &#96;default&#96; case to make &#96;select&#96; non-blocking:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case msg := &lt;-ch:
+     fmt.Println("received:", msg)
+ default:
+     fmt.Println("no message available")
+ }
+ &#96;&#96;&#96;
+ 
+ If no channel is ready, &#96;default&#96; executes immediately. This is how you poll without blocking.
+ 
+ ### Non-Blocking Send
+ 
+ &#96;&#96;&#96;go
+ select {
+ case ch &lt;- msg:
+     fmt.Println("sent")
+ default:
+     fmt.Println("channel full, dropping message")
+ }
+ &#96;&#96;&#96;
+ 
+ Try to send; if the channel is full (or unbuffered with no receiver), execute default instead of blocking.
+ 
+ ## Handling Multiple Sources
+ 
+ Real-world example: a worker that handles requests, ticks, and shutdown signals:
+ 
+ &#96;&#96;&#96;go
+ func worker(requests &lt;-chan Request, done &lt;-chan struct{}) {
+     ticker := time.NewTicker(time.Minute)
+     defer ticker.Stop()
+ 
+     for {
+         select {
+         case req := &lt;-requests:
+             handleRequest(req)
+         case &lt;-ticker.C:
+             doPeriodicWork()
+         case &lt;-done:
+             fmt.Println("shutting down")
+             return
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Three different event sources, one clean loop. In C#, you'd need &#96;Task.WhenAny&#96; with careful task management, or an Rx observable merge.
+ 
+ ## The Empty select
+ 
+ A &#96;select&#96; with no cases blocks forever:
+ 
+ &#96;&#96;&#96;go
+ select {}  // blocks forever
+ &#96;&#96;&#96;
+ 
+ Useful for keeping a main function alive while goroutines do work:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     go server()
+     select {}  // wait forever
+ }
+ &#96;&#96;&#96;
+ 
+ Not common, but occasionally handy.
+ 
+ ## Priority with Nested select
+ 
+ &#96;select&#96; chooses randomly among ready cases. If you need priority, nest them:
+ 
+ &#96;&#96;&#96;go
+ for {
+     // First, drain high priority
+     select {
+     case msg := &lt;-highPriority:
+         handle(msg)
+         continue
+     default:
+     }
+     
+     // Then check both
+     select {
+     case msg := &lt;-highPriority:
+         handle(msg)
+     case msg := &lt;-lowPriority:
+         handle(msg)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The first &#96;select&#96; with &#96;default&#96; is non-blocking—it handles high-priority if available, otherwise falls through. This ensures high-priority messages are processed first.
+ 
+ ## Cancellation Pattern
+ 
+ Using &#96;select&#96; with a done channel for cancellation:
+ 
+ &#96;&#96;&#96;go
+ func doWork(done &lt;-chan struct{}) error {
+     for {
+         select {
+         case &lt;-done:
+             return errors.New("cancelled")
+         default:
+         }
+         
+         // Do a chunk of work
+         if finished := processChunk(); finished {
+             return nil
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Check for cancellation at the top of each iteration. We'll see a better way with &#96;context&#96; later.
+ 
+ ## Collecting Results with Timeout
+ 
+ Common pattern: gather results from multiple goroutines with an overall timeout:
+ 
+ &#96;&#96;&#96;go
+ func fetchAll(urls []string, timeout time.Duration) []Result {
+     results := make(chan Result, len(urls))
+     
+     for _, url := range urls {
+         go func(u string) {
+             resp, err := fetch(u)
+             results &lt;- Result{URL: u, Response: resp, Error: err}
+         }(url)
+     }
+     
+     var collected []Result
+     deadline := time.After(timeout)
+     
+     for i := 0; i &lt; len(urls); i++ {
+         select {
+         case r := &lt;-results:
+             collected = append(collected, r)
+         case &lt;-deadline:
+             return collected  // return what we have
+         }
+     }
+     
+     return collected
+ }
+ &#96;&#96;&#96;
+ 
+ We get as many results as complete before the timeout, then return whatever we have.
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ async Task&lt;List&lt;Result&gt;&gt; FetchAll(string[] urls, TimeSpan timeout)
+ {
+     var cts = new CancellationTokenSource(timeout);
+     var tasks = urls.Select(url =&gt; FetchAsync(url, cts.Token));
+     
+     try
+     {
+         return (await Task.WhenAll(tasks)).ToList();
+     }
+     catch (OperationCanceledException)
+     {
+         // WhenAll throws if any task cancels - harder to get partial results
+         return tasks
+             .Where(t =&gt; t.IsCompletedSuccessfully)
+             .Select(t =&gt; t.Result)
+             .ToList();
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The C# version is more awkward for partial results because &#96;Task.WhenAll&#96; is all-or-nothing.
+ 
+ ## select with Send and Receive
+ 
+ You can mix sends and receives in one select:
+ 
+ &#96;&#96;&#96;go
+ select {
+ case ch1 &lt;- value:
+     fmt.Println("sent to ch1")
+ case msg := &lt;-ch2:
+     fmt.Println("received from ch2:", msg)
+ }
+ &#96;&#96;&#96;
+ 
+ Whichever operation can proceed, does. Useful for bidirectional communication.
+ 
+ ## The C# Comparison
+ 
+ | Go select | C# Equivalent | Notes |
+ |-----------|---------------|-------|
+ | &#96;select&#96; on multiple channels | &#96;Task.WhenAny&#96; | Less elegant syntax |
+ | Timeout with &#96;time.After&#96; | &#96;Task.WhenAny&#96; + &#96;Task.Delay&#96; | More verbose |
+ | Non-blocking with &#96;default&#96; | &#96;Task.IsCompleted&#96; check | Manual polling |
+ | Empty &#96;select {}&#96; | &#96;Task.Delay(Timeout.Infinite)&#96; | Rare in both |
+ | Priority handling | Manual with loops | No direct equivalent |
+ 
+ C# has &#96;System.Threading.Channels&#96; which gets closer:
+ 
+ &#96;&#96;&#96;csharp
+ var reader = channel.Reader;
+ while (await reader.WaitToReadAsync())
+ {
+     while (reader.TryRead(out var item))
+     {
+         Process(item);
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ But multiplexing multiple channels still requires &#96;Task.WhenAny&#96; gymnastics.
+ 
+ ## The Honest Take
+ 
+ &#96;select&#96; is one of Go's genuinely great features. It makes patterns that are awkward in other languages—timeouts, multiplexing, non-blocking checks—into one clean construct.
+ 
+ **What Go does better:**
+ - Clean syntax for multiplexing
+ - Timeouts are trivial
+ - Non-blocking operations with &#96;default&#96;
+ - Fair random selection among ready cases
+ - First-class language support
+ 
+ **What C# does better:**
+ - &#96;Task.WhenAll&#96; for collecting all results
+ - Better exception propagation
+ - Richer LINQ-style composition with Rx
+ 
+ **The verdict:**
+ If you're doing event-loop style programming—handling messages from multiple sources, implementing timeouts, coordinating shutdown—&#96;select&#96; is wonderful. It's one of those features you miss when you go back to languages without it.
+ 
+ ---
+ 
+ *Next up: mutexes and WaitGroups—because sometimes shared memory with locks is simpler than channels.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-sync.md</summary>

**Chunk 1**
Lines added: 381, lines removed: 1

```diff
@@ -1,1 +1,381 @@
- 
+ +++
+ title = "Mutexes and WaitGroups: When Channels Aren't the Answer"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "sync", "csharp"]
+ +++
+ 
+ Go's mantra is "share memory by communicating," but sometimes you just need a bloody mutex. The &#96;sync&#96; package has all the primitives you know from C#, and knowing when to use them vs channels is part of becoming proficient in Go.
+ 
+ ## sync.Mutex
+ 
+ The classic lock:
+ 
+ &#96;&#96;&#96;go
+ type Counter struct {
+     mu    sync.Mutex
+     value int
+ }
+ 
+ func (c *Counter) Increment() {
+     c.mu.Lock()
+     defer c.mu.Unlock()
+     c.value++
+ }
+ 
+ func (c *Counter) Value() int {
+     c.mu.Lock()
+     defer c.mu.Unlock()
+     return c.value
+ }
+ &#96;&#96;&#96;
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public class Counter
+ {
+     private readonly object _lock = new();
+     private int _value;
+     
+     public void Increment()
+     {
+         lock (_lock) { _value++; }
+     }
+     
+     public int Value
+     {
+         get { lock (_lock) { return _value; } }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Pretty similar. Go doesn't have a &#96;lock&#96; keyword, so you explicitly call &#96;Lock()&#96; and &#96;Unlock()&#96;. The &#96;defer&#96; ensures unlock even if the code panics.
+ 
+ ### RWMutex for Read-Heavy Workloads
+ 
+ When you have many readers and few writers:
+ 
+ &#96;&#96;&#96;go
+ type Cache struct {
+     mu    sync.RWMutex
+     items map[string]string
+ }
+ 
+ func (c *Cache) Get(key string) (string, bool) {
+     c.mu.RLock()         // read lock - multiple readers allowed
+     defer c.mu.RUnlock()
+     val, ok := c.items[key]
+     return val, ok
+ }
+ 
+ func (c *Cache) Set(key, value string) {
+     c.mu.Lock()          // write lock - exclusive
+     defer c.mu.Unlock()
+     c.items[key] = value
+ }
+ &#96;&#96;&#96;
+ 
+ Equivalent to &#96;ReaderWriterLockSlim&#96; in C#.
+ 
+ ## sync.WaitGroup
+ 
+ This is what you reach for when you need to wait for multiple goroutines to complete:
+ 
+ &#96;&#96;&#96;go
+ func main() {
+     var wg sync.WaitGroup
+     
+     for i := 0; i &lt; 5; i++ {
+         wg.Add(1)
+         go func(n int) {
+             defer wg.Done()
+             doWork(n)
+         }(i)
+     }
+     
+     wg.Wait()  // blocks until all Done() calls
+     fmt.Println("all done")
+ }
+ &#96;&#96;&#96;
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ var tasks = Enumerable.Range(0, 5)
+     .Select(n =&gt; Task.Run(() =&gt; DoWork(n)))
+     .ToArray();
+ 
+ await Task.WhenAll(tasks);
+ Console.WriteLine("all done");
+ &#96;&#96;&#96;
+ 
+ C#'s version is more concise. Go's is more explicit about the counting.
+ 
+ ### Common WaitGroup Mistakes
+ 
+ &#96;&#96;&#96;go
+ // WRONG: Add inside goroutine - race condition
+ for i := 0; i &lt; 5; i++ {
+     go func(n int) {
+         wg.Add(1)  // too late! main might call Wait() first
+         defer wg.Done()
+         doWork(n)
+     }(i)
+ }
+ 
+ // CORRECT: Add before starting goroutine
+ for i := 0; i &lt; 5; i++ {
+     wg.Add(1)
+     go func(n int) {
+         defer wg.Done()
+         doWork(n)
+     }(i)
+ }
+ &#96;&#96;&#96;
+ 
+ Always &#96;Add&#96; before &#96;go&#96;, never inside the goroutine.
+ 
+ ## sync.Once
+ 
+ Execute something exactly once, regardless of how many goroutines try:
+ 
+ &#96;&#96;&#96;go
+ var (
+     instance *Database
+     once     sync.Once
+ )
+ 
+ func GetDatabase() *Database {
+     once.Do(func() {
+         instance = connectToDatabase()
+     })
+     return instance
+ }
+ &#96;&#96;&#96;
+ 
+ C# equivalent with &#96;Lazy&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ private static readonly Lazy&lt;Database&gt; _instance = 
+     new(() =&gt; ConnectToDatabase());
+ 
+ public static Database GetDatabase() =&gt; _instance.Value;
+ &#96;&#96;&#96;
+ 
+ Or with double-checked locking... which is why &#96;Lazy&lt;T&gt;&#96; exists.
+ 
+ ## sync.Cond
+ 
+ Condition variables for signaling between goroutines:
+ 
+ &#96;&#96;&#96;go
+ type Queue struct {
+     items []int
+     cond  *sync.Cond
+ }
+ 
+ func NewQueue() *Queue {
+     return &amp;Queue{
+         cond: sync.NewCond(&amp;sync.Mutex{}),
+     }
+ }
+ 
+ func (q *Queue) Put(item int) {
+     q.cond.L.Lock()
+     defer q.cond.L.Unlock()
+     
+     q.items = append(q.items, item)
+     q.cond.Signal()  // wake one waiting goroutine
+ }
+ 
+ func (q *Queue) Get() int {
+     q.cond.L.Lock()
+     defer q.cond.L.Unlock()
+     
+     for len(q.items) == 0 {
+         q.cond.Wait()  // releases lock, waits, reacquires lock
+     }
+     
+     item := q.items[0]
+     q.items = q.items[1:]
+     return item
+ }
+ &#96;&#96;&#96;
+ 
+ Honestly? For this pattern, channels are cleaner:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ ch &lt;- item      // put
+ item := &lt;-ch    // get
+ &#96;&#96;&#96;
+ 
+ &#96;sync.Cond&#96; exists for complex scenarios where channels don't fit, but I rarely use it.
+ 
+ ## sync.Pool
+ 
+ Object pool for reducing allocations:
+ 
+ &#96;&#96;&#96;go
+ var bufferPool = sync.Pool{
+     New: func() interface{} {
+         return make([]byte, 4096)
+     },
+ }
+ 
+ func process() {
+     buf := bufferPool.Get().([]byte)
+     defer bufferPool.Put(buf)
+     
+     // use buf...
+ }
+ &#96;&#96;&#96;
+ 
+ C# has &#96;ArrayPool&lt;T&gt;&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ var buffer = ArrayPool&lt;byte&gt;.Shared.Rent(4096);
+ try
+ {
+     // use buffer...
+ }
+ finally
+ {
+     ArrayPool&lt;byte&gt;.Shared.Return(buffer);
+ }
+ &#96;&#96;&#96;
+ 
+ Similar idea. Pool objects to avoid allocation pressure.
+ 
+ ## sync/atomic
+ 
+ For simple counters and flags, atomics are faster than mutexes:
+ 
+ &#96;&#96;&#96;go
+ var counter int64
+ 
+ func Increment() {
+     atomic.AddInt64(&amp;counter, 1)
+ }
+ 
+ func Value() int64 {
+     return atomic.LoadInt64(&amp;counter)
+ }
+ &#96;&#96;&#96;
+ 
+ C#:
+ 
+ &#96;&#96;&#96;csharp
+ private long _counter;
+ 
+ public void Increment() =&gt; Interlocked.Increment(ref _counter);
+ public long Value =&gt; Interlocked.Read(ref _counter);
+ &#96;&#96;&#96;
+ 
+ Same primitives, different names.
+ 
+ ## Channels vs Mutexes: When to Choose
+ 
+ **Use channels when:**
+ - Passing ownership of data between goroutines
+ - Coordinating multiple goroutines
+ - Building pipelines
+ - Signaling events
+ 
+ **Use mutexes when:**
+ - Protecting simple shared state (counters, caches)
+ - The "critical section" is obvious
+ - You don't need to transfer data, just guard it
+ - Performance matters and channels add overhead
+ 
+ **The rule of thumb:**
+ If you're passing data, use channels. If you're guarding data, use mutexes.
+ 
+ &#96;&#96;&#96;go
+ // Channel: transferring data ownership
+ workQueue := make(chan Job)
+ go worker(workQueue)
+ workQueue &lt;- newJob  // worker now "owns" this job
+ 
+ // Mutex: guarding shared state
+ type Metrics struct {
+     mu     sync.Mutex
+     counts map[string]int
+ }
+ 
+ func (m *Metrics) Inc(key string) {
+     m.mu.Lock()
+     m.counts[key]++
+     m.mu.Unlock()
+ }
+ &#96;&#96;&#96;
+ 
+ ## The map Concurrency Problem
+ 
+ Maps are not concurrency-safe in Go:
+ 
+ &#96;&#96;&#96;go
+ m := make(map[string]int)
+ 
+ go func() { m["a"] = 1 }()
+ go func() { m["b"] = 2 }()
+ // RACE CONDITION - might corrupt the map or panic
+ &#96;&#96;&#96;
+ 
+ You need either:
+ 
+ **Option 1: Mutex**
+ &#96;&#96;&#96;go
+ type SafeMap struct {
+     mu sync.RWMutex
+     m  map[string]int
+ }
+ &#96;&#96;&#96;
+ 
+ **Option 2: sync.Map**
+ &#96;&#96;&#96;go
+ var m sync.Map
+ m.Store("key", value)
+ val, ok := m.Load("key")
+ &#96;&#96;&#96;
+ 
+ &#96;sync.Map&#96; is optimised for specific patterns (keys written once, read many times). For general use, a mutex-protected map is often simpler.
+ 
+ ## The Comparison
+ 
+ | C# | Go | Notes |
+ |-----|-----|-------|
+ | &#96;lock&#96; | &#96;sync.Mutex&#96; | Manual Lock/Unlock |
+ | &#96;ReaderWriterLockSlim&#96; | &#96;sync.RWMutex&#96; | Same concept |
+ | &#96;Task.WhenAll&#96; | &#96;sync.WaitGroup&#96; | Go is more verbose |
+ | &#96;Lazy&lt;T&gt;&#96; | &#96;sync.Once&#96; | Same purpose |
+ | &#96;Monitor.Wait/Pulse&#96; | &#96;sync.Cond&#96; | Rarely needed |
+ | &#96;ConcurrentDictionary&#96; | &#96;sync.Map&#96; | Different optimisations |
+ | &#96;ArrayPool&lt;T&gt;&#96; | &#96;sync.Pool&#96; | Similar |
+ | &#96;Interlocked&#96; | &#96;sync/atomic&#96; | Same primitives |
+ 
+ ## The Honest Take
+ 
+ Go's sync package is perfectly adequate. Nothing here will surprise a C# developer who knows their threading primitives.
+ 
+ **What Go does well:**
+ - Clean, minimal API
+ - &#96;defer&#96; makes unlock reliable
+ - WaitGroup is explicit about what you're waiting for
+ 
+ **What C# does better:**
+ - &#96;lock&#96; keyword is more concise than Lock/Unlock
+ - &#96;Task.WhenAll&#96; is cleaner than WaitGroup
+ - &#96;ConcurrentDictionary&#96; has more features than &#96;sync.Map&#96;
+ - Overall better tooling for concurrency debugging
+ 
+ **The verdict:**
+ These primitives work fine. You'll miss &#96;lock&#96; syntax occasionally. You'll miss &#96;Task.WhenAll&#96;'s elegance frequently. But you'll be productive.
+ 
+ The more interesting question is channels vs mutexes. Go developers sometimes over-use channels when a mutex would be simpler. Don't cargo-cult "share by communicating" when a simple lock does the job.
+ 
+ ---
+ 
+ *Next up: context.Context—Go's answer to CancellationToken, and arguably one of the most important patterns in Go.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-context.md</summary>

**Chunk 1**
Lines added: 334, lines removed: 1

```diff
@@ -1,1 +1,334 @@
- 
+ +++
+ title = "Context Is King"
+ date = "2025-01-01"
+ draft = false
+ tags = ["go", "dotnet", "concurrency", "context", "csharp"]
+ +++
+ 
+ Every Go function that does I/O, might take a while, or should be cancellable will take a &#96;context.Context&#96; as its first parameter. It's Go's answer to &#96;CancellationToken&#96;, plus request-scoped values, all in one.
+ 
+ If you're not using context properly, you're not writing idiomatic Go. It's that fundamental.
+ 
+ ## The Basics
+ 
+ &#96;&#96;&#96;go
+ func DoSomething(ctx context.Context) error {
+     // Check if already cancelled
+     select {
+     case &lt;-ctx.Done():
+         return ctx.Err()
+     default:
+     }
+     
+     // Do work...
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Every context has a &#96;Done()&#96; channel that closes when the context is cancelled. You check it periodically during long operations.
+ 
+ ## Creating Contexts
+ 
+ Start with a background or TODO context:
+ 
+ &#96;&#96;&#96;go
+ ctx := context.Background()  // root context, never cancelled
+ ctx := context.TODO()        // placeholder when you're not sure what context to use
+ &#96;&#96;&#96;
+ 
+ Then derive child contexts with cancellation or deadlines:
+ 
+ &#96;&#96;&#96;go
+ // Manual cancellation
+ ctx, cancel := context.WithCancel(parentCtx)
+ defer cancel()  // always call cancel to release resources
+ 
+ // Timeout
+ ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
+ defer cancel()
+ 
+ // Deadline (absolute time)
+ ctx, cancel := context.WithDeadline(parentCtx, time.Now().Add(5*time.Second))
+ defer cancel()
+ &#96;&#96;&#96;
+ 
+ When you cancel a context, all contexts derived from it are also cancelled. It's a tree.
+ 
+ ## The C# Comparison
+ 
+ C#'s &#96;CancellationToken&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ public async Task DoSomethingAsync(CancellationToken ct)
+ {
+     ct.ThrowIfCancellationRequested();
+     
+     // Do work...
+ }
+ 
+ // Usage
+ var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
+ await DoSomethingAsync(cts.Token);
+ &#96;&#96;&#96;
+ 
+ Similar concepts:
+ 
+ | Go | C# |
+ |-----|-----|
+ | &#96;context.Context&#96; | &#96;CancellationToken&#96; |
+ | &#96;context.WithCancel&#96; | &#96;new CancellationTokenSource()&#96; |
+ | &#96;context.WithTimeout&#96; | &#96;new CancellationTokenSource(TimeSpan)&#96; |
+ | &#96;ctx.Done()&#96; channel | &#96;token.IsCancellationRequested&#96; |
+ | &#96;ctx.Err()&#96; | &#96;token.ThrowIfCancellationRequested()&#96; |
+ | &#96;context.WithValue&#96; | &#96;AsyncLocal&lt;T&gt;&#96; / HttpContext.Items |
+ 
+ The big difference: Go's context also carries request-scoped values. C# separates cancellation (&#96;CancellationToken&#96;) from request-scoped data (&#96;HttpContext&#96;, &#96;AsyncLocal&lt;T&gt;&#96;, etc.).
+ 
+ ## Context as First Parameter
+ 
+ By convention, context is always the first parameter:
+ 
+ &#96;&#96;&#96;go
+ // CORRECT
+ func GetUser(ctx context.Context, id string) (*User, error)
+ 
+ // WRONG - context should be first
+ func GetUser(id string, ctx context.Context) (*User, error)
+ 
+ // WRONG - don't put context in structs
+ type UserService struct {
+     ctx context.Context  // NO!
+ }
+ &#96;&#96;&#96;
+ 
+ This convention is enforced by linters and universally followed. Don't be creative.
+ 
+ ## Proper Cancellation Checking
+ 
+ In long operations, check for cancellation periodically:
+ 
+ &#96;&#96;&#96;go
+ func ProcessItems(ctx context.Context, items []Item) error {
+     for _, item := range items {
+         // Check at the start of each iteration
+         select {
+         case &lt;-ctx.Done():
+             return ctx.Err()
+         default:
+         }
+         
+         if err := processItem(ctx, item); err != nil {
+             return err
+         }
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ For I/O operations, pass the context through:
+ 
+ &#96;&#96;&#96;go
+ func FetchData(ctx context.Context, url string) ([]byte, error) {
+     req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
+     if err != nil {
+         return nil, err
+     }
+     
+     resp, err := http.DefaultClient.Do(req)
+     if err != nil {
+         return nil, err  // includes context cancellation
+     }
+     defer resp.Body.Close()
+     
+     return io.ReadAll(resp.Body)
+ }
+ &#96;&#96;&#96;
+ 
+ When the context is cancelled, the HTTP request is aborted. Same for database queries, gRPC calls, etc.
+ 
+ ## Context Values
+ 
+ Context can carry request-scoped values:
+ 
+ &#96;&#96;&#96;go
+ type contextKey string
+ 
+ const userIDKey contextKey = "userID"
+ 
+ func WithUserID(ctx context.Context, userID string) context.Context {
+     return context.WithValue(ctx, userIDKey, userID)
+ }
+ 
+ func GetUserID(ctx context.Context) (string, bool) {
+     userID, ok := ctx.Value(userIDKey).(string)
+     return userID, ok
+ }
+ &#96;&#96;&#96;
+ 
+ Use sparingly! Context values should be:
+ - Request-scoped data that transits process boundaries (request IDs, auth tokens)
+ - Not a replacement for function parameters
+ 
+ &#96;&#96;&#96;go
+ // BAD: Using context to avoid passing parameters
+ ctx = context.WithValue(ctx, "db", database)
+ ctx = context.WithValue(ctx, "logger", logger)
+ // Now your function signatures lie about their dependencies
+ 
+ // GOOD: Pass dependencies explicitly, use context for request-scoped data
+ func HandleRequest(ctx context.Context, db *Database, logger *Logger) {
+     requestID := GetRequestID(ctx)  // request-scoped, appropriate
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ ## HTTP Server Context
+ 
+ In HTTP servers, the request carries context:
+ 
+ &#96;&#96;&#96;go
+ func handler(w http.ResponseWriter, r *http.Request) {
+     ctx := r.Context()  // cancelled if client disconnects
+     
+     result, err := doExpensiveOperation(ctx)
+     if err != nil {
+         if errors.Is(err, context.Canceled) {
+             // Client disconnected, don't bother responding
+             return
+         }
+         http.Error(w, err.Error(), 500)
+         return
+     }
+     
+     json.NewEncoder(w).Encode(result)
+ }
+ &#96;&#96;&#96;
+ 
+ The request context is automatically cancelled when:
+ - The client closes the connection
+ - The request times out
+ - The server is shutting down (with proper setup)
+ 
+ ## Timeout Patterns
+ 
+ Setting per-operation timeouts:
+ 
+ &#96;&#96;&#96;go
+ func QueryWithTimeout(ctx context.Context, query string) ([]Row, error) {
+     ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+     defer cancel()
+     
+     return db.QueryContext(ctx, query)
+ }
+ &#96;&#96;&#96;
+ 
+ The timeout is scoped to this operation. If the parent context has a shorter deadline, that wins.
+ 
+ &#96;&#96;&#96;go
+ // Parent has 3 second deadline
+ parentCtx, _ := context.WithTimeout(context.Background(), 3*time.Second)
+ 
+ // Child requests 5 seconds, but will actually timeout at 3
+ childCtx, _ := context.WithTimeout(parentCtx, 5*time.Second)
+ &#96;&#96;&#96;
+ 
+ Child contexts can only be more restrictive than parents, never less.
+ 
+ ## Cancellation Propagation
+ 
+ When you start goroutines, propagate the context:
+ 
+ &#96;&#96;&#96;go
+ func ProcessInParallel(ctx context.Context, items []Item) error {
+     g, ctx := errgroup.WithContext(ctx)  // from golang.org/x/sync/errgroup
+     
+     for _, item := range items {
+         item := item
+         g.Go(func() error {
+             return process(ctx, item)  // same context
+         })
+     }
+     
+     return g.Wait()
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;errgroup&#96; package creates a derived context that cancels when any goroutine returns an error. All other goroutines see the cancellation.
+ 
+ ## Common Mistakes
+ 
+ **Don't store context in structs:**
+ &#96;&#96;&#96;go
+ // WRONG
+ type Worker struct {
+     ctx context.Context
+ }
+ 
+ // RIGHT: pass context to methods
+ func (w *Worker) Do(ctx context.Context) error
+ &#96;&#96;&#96;
+ 
+ **Don't use string keys for context values:**
+ &#96;&#96;&#96;go
+ // WRONG: key collisions possible
+ ctx = context.WithValue(ctx, "userID", id)
+ 
+ // RIGHT: unexported type prevents collisions
+ type contextKey string
+ const userIDKey contextKey = "userID"
+ &#96;&#96;&#96;
+ 
+ **Don't ignore context cancellation:**
+ &#96;&#96;&#96;go
+ // WRONG: ignoring cancellation
+ func slowOperation(ctx context.Context) {
+     time.Sleep(10 * time.Second)  // doesn't respect context
+ }
+ 
+ // RIGHT: check context
+ func slowOperation(ctx context.Context) error {
+     select {
+     case &lt;-time.After(10 * time.Second):
+         return nil
+     case &lt;-ctx.Done():
+         return ctx.Err()
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Aspect | Go context.Context | C# CancellationToken |
+ |--------|-------------------|---------------------|
+ | Cancellation | Yes | Yes |
+ | Timeouts | Yes (WithTimeout) | Yes (CTS constructor) |
+ | Request values | Yes (WithValue) | No (use HttpContext) |
+ | First parameter convention | Always | Often last |
+ | Integrated with I/O | Yes | Yes |
+ | Tree structure | Yes (parent-child) | Yes (linked tokens) |
+ 
+ ## The Honest Take
+ 
+ Context is one of Go's better patterns. It unifies cancellation and request-scoped values into one concept that permeates the ecosystem.
+ 
+ **What Go does well:**
+ - Single abstraction for cancellation + deadlines + values
+ - Universal convention (first parameter)
+ - Clean propagation through call chains
+ - Well integrated with stdlib (http, database/sql, etc.)
+ 
+ **What C# does better:**
+ - Clearer separation of concerns (CancellationToken vs HttpContext)
+ - &#96;CancellationToken&#96; is optional by default (overloads without it)
+ - Easier to add cancellation to existing APIs
+ - Less ceremony for simple cases
+ 
+ **The verdict:**
+ Context feels heavyweight at first—every function needs &#96;ctx context.Context&#96; as its first parameter. But the consistency pays off. You can always cancel. You can always set timeouts. You can always trace request IDs through your system.
+ 
+ Once you're used to it, going back to languages without pervasive cancellation support feels limiting.
+ 
+ ---
+ 
+ *That wraps up the concurrency section. Go's model is different from async/await, but it's powerful and consistent. Goroutines for concurrency, channels for communication, context for cancellation and request-scoping. Learn those three and you've got Go's concurrency story.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      19
---
content/posts/dotnet-to-go-channels.md
content/posts/dotnet-to-go-context.md
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-goroutines.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-select.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-sync.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 19 posts are created and the build is successful. Let me summarize the complete series for the user.</details></think>

---

All 5 concurrency posts done! 19 posts total now. Here's the complete series:

## C# to Go Series (19 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"**
2. **"Goodbye .csproj, Hello go.mod"**
3. **"The Phrasebook: C# Concepts in Go Terms"**

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"**
5. **"Where Did My Properties Go?"**
6. **"Generics: Late to the Party"**
7. **"The Million Dollar Mistake, Differently"**
8. **"No Enums? No Problem (Sort Of)"**

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"**
10. **"Panic and Recover: The Emergency Exit"**
11. **"The switch Statement You Always Wanted"**

### Phase 4: Memory & Pointers
12. **"Pointers Without the Pain"**
13. **"Stack vs Heap: Go's Escape Analysis"**
14. **"Slices Are Not Arrays (And Neither Is List<T>)"**

### Phase 5: Concurrency ← **NEW**
15. **"Async/Await vs Goroutines: A Mindset Shift"** — No function colouring, blocking is fine, the `go` keyword, why it feels backwards then clicks
16. **"Channels: The sync You Didn't Know You Wanted"** — Buffered vs unbuffered, closing, fan-out/fan-in, pipelines, comparison to BlockingCollection
17. **"select: Multiplexing Like a Pro"** — Waiting on multiple channels, timeouts with `time.After`, non-blocking with `default`, the pattern C# doesn't have
18. **"Mutexes and WaitGroups: When Channels Aren't the Answer"** — sync package deep-dive, when to use locks vs channels, the map concurrency problem
19. **"Context Is King"** — Cancellation, timeouts, request-scoped values, the first-parameter convention, why it's everywhere

The concurrency section highlights where Go genuinely shines:
- No async/await virus (no coloured functions)
- `select` is cleaner than `Task.WhenAny` gymnastics
- Goroutines are cheaper than Tasks
- Context unifies cancellation + timeouts + request values

But also acknowledges where C# is better:
- `Task.WhenAll` is more elegant than WaitGroup
- `lock` keyword beats manual Lock/Unlock
- Better debugging tooling
- Clearer separation of concerns

---

_**User (2025-12-30 00:36Z)**_

This is the end of the full phase 1: 

let's go!

Interfaces & Composition

Implicit Interfaces: Scary Then Brilliant — No implements keyword, duck typing done right
Composition Over Inheritance (For Real This Time) — Embedding, delegation, and why you won't miss base classes
The Empty Interface and Type Assertions — interface{}, any, and when you're basically back to object

keep the tone, we're getting a bit more difficult so feel free to be more casual at times

Explain things that are new to dotnet devs, maybe embeddings etc, need some defitnion

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create 3 posts for the Interfaces & Composition section. They want me to:
1. Keep the tone but be more casual at times since it's getting more difficult
2. Explain things that are new to .NET devs, like embedding - give proper definitions

Let me write these posts with good explanations of Go-specific concepts like embedding, implicit interfaces, etc.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-interfaces.md</summary>

**Chunk 1**
Lines added: 250, lines removed: 1

```diff
@@ -1,1 +1,250 @@
- 
+ +++
+ title = "Implicit Interfaces: Scary Then Brilliant"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "interfaces", "csharp"]
+ +++
+ 
+ Here's a sentence that'll make every C# developer uncomfortable: Go interfaces don't require an &#96;implements&#96; keyword. You never explicitly declare that a type implements an interface. If your type has the right methods, it implements the interface. Automatically. Implicitly.
+ 
+ This sounds like chaos. It felt like chaos to me for the first week. Then it clicked, and now C#'s explicit interface declarations feel like unnecessary paperwork.
+ 
+ ## The C# Way: Explicit Declaration
+ 
+ In C#, implementing an interface is a contract you sign explicitly:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IWriter
+ {
+     void Write(byte[] data);
+ }
+ 
+ public class FileWriter : IWriter  // explicit declaration
+ {
+     public void Write(byte[] data)
+     {
+         // write to file
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;: IWriter&#96; is required. Without it, &#96;FileWriter&#96; doesn't implement &#96;IWriter&#96;, even if it has a matching &#96;Write&#96; method. The compiler enforces this contract.
+ 
+ ## The Go Way: Implicit Satisfaction
+ 
+ Go flips this around:
+ 
+ &#96;&#96;&#96;go
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type FileWriter struct {
+     // fields
+ }
+ 
+ func (f *FileWriter) Write(p []byte) (n int, err error) {
+     // write to file
+     return len(p), nil
+ }
+ 
+ // FileWriter now implements Writer. No declaration needed.
+ &#96;&#96;&#96;
+ 
+ There's no &#96;implements Writer&#96; anywhere. The &#96;FileWriter&#96; type has a method &#96;Write(p []byte) (n int, err error)&#96;, which matches the &#96;Writer&#96; interface's signature. Therefore, &#96;FileWriter&#96; implements &#96;Writer&#96;. Done.
+ 
+ This is called **structural typing** or, less formally, **duck typing**: if it walks like a duck and quacks like a duck, it's a duck. If your type has the methods an interface requires, it implements that interface.
+ 
+ ## Why This Is Actually Good
+ 
+ I know, I know. "But how do I know what interfaces my type implements?" "What if I accidentally implement something?" "How do I document my intent?"
+ 
+ Let me address these, because they were my exact objections.
+ 
+ ### You Can Define Interfaces After the Fact
+ 
+ This is the killer feature. In C#, if you want an interface, you design it upfront, or you go back and modify all implementing types when you add one later.
+ 
+ In Go, you can define an interface that existing types already satisfy:
+ 
+ &#96;&#96;&#96;go
+ // You wrote this last month
+ type Database struct { ... }
+ func (db *Database) Query(sql string) ([]Row, error) { ... }
+ func (db *Database) Exec(sql string) error { ... }
+ 
+ // Today you want to test something that uses Database
+ type Querier interface {
+     Query(sql string) ([]Row, error)
+ }
+ 
+ // Database already implements Querier. No changes needed.
+ func ProcessData(q Querier) { ... }
+ &#96;&#96;&#96;
+ 
+ You created a new interface. &#96;Database&#96; implements it without any modification. Your production code doesn't change. Your tests can use a mock &#96;Querier&#96;. Beautiful.
+ 
+ In C#, you'd need to go back and add &#96;: IQuerier&#96; to &#96;Database&#96;. That's a code change, a new commit, potentially a new deployment—all for what should be a refactoring detail.
+ 
+ ### Small Interfaces Are Encouraged
+ 
+ Go's standard library is full of tiny interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ 
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type Closer interface {
+     Close() error
+ }
+ &#96;&#96;&#96;
+ 
+ One method each. Dozens of types implement &#96;Reader&#96;—files, network connections, HTTP response bodies, byte buffers, compression streams. They don't know about each other. They just happen to have a &#96;Read&#96; method.
+ 
+ This leads to highly composable code. Functions take the smallest interface they need:
+ 
+ &#96;&#96;&#96;go
+ func Copy(dst Writer, src Reader) (int64, error)
+ &#96;&#96;&#96;
+ 
+ Anything readable to anything writable. Files to network. Network to memory. Whatever. If it has the methods, it works.
+ 
+ In C#, you'd need &#96;IReadable&#96; and &#96;IWritable&#96; interfaces defined somewhere, and every type would need to explicitly implement them. The friction means you'd probably just use concrete types or create fat interfaces.
+ 
+ ### Accidental Implementation Is Rare
+ 
+ "But what if I accidentally implement an interface I didn't mean to?"
+ 
+ In practice, this almost never happens. Interfaces in Go tend to have method names specific to their purpose. The odds that your &#96;type Banana struct{}&#96; accidentally has a method &#96;func (b Banana) Read(p []byte) (int, error)&#96; are slim.
+ 
+ And if it does? So what? If your banana can be read from, maybe someone will find a creative use for that. The type system isn't going to explode.
+ 
+ ## Checking Interface Satisfaction
+ 
+ If you want to verify at compile time that a type implements an interface, use this pattern:
+ 
+ &#96;&#96;&#96;go
+ var _ Writer = (*FileWriter)(nil)
+ &#96;&#96;&#96;
+ 
+ This declares an anonymous variable of type &#96;Writer&#96; and assigns a nil &#96;*FileWriter&#96; to it. If &#96;*FileWriter&#96; doesn't implement &#96;Writer&#96;, compilation fails.
+ 
+ The variable is discarded (assigned to &#96;_&#96;), so there's no runtime cost. It's purely a compile-time check.
+ 
+ &#96;&#96;&#96;go
+ // In your file, somewhere near the type definition
+ var _ io.Reader = (*MyReader)(nil)
+ var _ io.Writer = (*MyWriter)(nil)
+ var _ http.Handler = (*MyHandler)(nil)
+ &#96;&#96;&#96;
+ 
+ This is the Go equivalent of declaring intent. Use it when the interface implementation is non-obvious or contractually important.
+ 
+ ## Interface Values: Two Components
+ 
+ Here's something C# developers don't think about: an interface value in Go has two components:
+ 
+ 1. **The type**: what concrete type is stored
+ 2. **The value**: the actual data
+ 
+ &#96;&#96;&#96;go
+ var w Writer
+ fmt.Printf("type: %T, value: %v\n", w, w)
+ // type: &lt;nil&gt;, value: &lt;nil&gt;
+ 
+ w = &amp;FileWriter{}
+ fmt.Printf("type: %T, value: %v\n", w, w)
+ // type: *main.FileWriter, value: &amp;{...}
+ &#96;&#96;&#96;
+ 
+ This matters because of the nil interface trap we covered earlier. An interface is only &#96;nil&#96; when both type and value are nil. Assign a nil pointer and the type is set, so the interface isn't nil.
+ 
+ ## Interfaces on Values vs Pointers
+ 
+ Methods can have value receivers or pointer receivers. This affects interface implementation:
+ 
+ &#96;&#96;&#96;go
+ type Speaker interface {
+     Speak() string
+ }
+ 
+ type Dog struct{ Name string }
+ 
+ // Value receiver
+ func (d Dog) Speak() string {
+     return "Woof!"
+ }
+ 
+ var s Speaker
+ s = Dog{Name: "Rex"}   // OK - Dog implements Speaker
+ s = &amp;Dog{Name: "Rex"}  // OK - *Dog also implements Speaker (Go is helpful here)
+ &#96;&#96;&#96;
+ 
+ But watch what happens with pointer receivers:
+ 
+ &#96;&#96;&#96;go
+ type Cat struct{ Name string }
+ 
+ // Pointer receiver
+ func (c *Cat) Speak() string {
+     return "Meow!"
+ }
+ 
+ var s Speaker
+ s = &amp;Cat{Name: "Whiskers"}  // OK - *Cat implements Speaker
+ s = Cat{Name: "Whiskers"}   // ERROR - Cat does NOT implement Speaker
+ &#96;&#96;&#96;
+ 
+ Why? Because you can always get a pointer from a value (&#96;&amp;cat&#96;), but you can't always get an addressable value from a pointer. Go is strict about this.
+ 
+ **The rule**: if any method has a pointer receiver, use pointers with that interface.
+ 
+ ## Comparing to C# Interface Features
+ 
+ | Feature | C# | Go |
+ |---------|-----|-----|
+ | Explicit implementation | Required (&#96;: IInterface&#96;) | Not possible |
+ | Implicit implementation | Not possible | Automatic |
+ | Default methods | Yes (C# 8+) | No |
+ | Static methods | Yes (C# 11) | No |
+ | Properties | Yes | No (use methods) |
+ | Generic interfaces | Yes | Yes (Go 1.18+) |
+ | Explicit interface implementation | Yes (&#96;IFoo.Bar()&#96;) | No |
+ | Covariance/contravariance | Yes (&#96;out&#96;/&#96;in&#96;) | No |
+ 
+ Go interfaces are simpler. That simplicity is the point.
+ 
+ ## The Honest Take
+ 
+ Implicit interfaces felt wrong. "How will I know what my type implements?" "How will I communicate intent?"
+ 
+ Then I realised: the caller defines what it needs. The implementer just provides capabilities. If those match, great. If not, no harm done.
+ 
+ **What Go does better:**
+ - Define interfaces at the point of use, not declaration
+ - Small, composable interfaces are natural
+ - No ceremony—just write the methods
+ - Retroactive interface satisfaction
+ - Decouples interface from implementation completely
+ 
+ **What C# does better:**
+ - Clear documentation of intent (&#96;: IInterface&#96;)
+ - IDE "go to implementations" is easier
+ - Explicit interface implementation for conflicts
+ - Default interface methods
+ - Richer interface features (properties, statics)
+ 
+ **The verdict:**
+ Once you stop thinking "I need to declare my interfaces upfront" and start thinking "I'll define an interface when I need the abstraction," Go's approach makes beautiful sense. It's just a different philosophy.
+ 
+ The interface belongs to the consumer, not the producer. That inversion takes time to internalise, but it's powerful.
+ 
+ ---
+ 
+ *Next up: composition via embedding—Go's alternative to inheritance, and why you really won't miss base classes.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-composition.md</summary>

**Chunk 1**
Lines added: 344, lines removed: 1

```diff
@@ -1,1 +1,344 @@
- 
+ +++
+ title = "Composition Over Inheritance (For Real This Time)"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "composition", "embedding", "csharp"]
+ +++
+ 
+ We've all heard "favour composition over inheritance." We've all nodded sagely. And then we've all written class hierarchies three levels deep because, well, it's right there and it's easy.
+ 
+ Go doesn't give you the choice. There's no inheritance. Zero. You can't extend a type. You can't override methods. There's no &#96;virtual&#96;, no &#96;abstract&#96;, no &#96;base&#96;.
+ 
+ Instead, Go has **embedding**—a form of composition that feels almost like inheritance but isn't. And after using it for a while, I genuinely don't miss base classes.
+ 
+ ## What Is Embedding?
+ 
+ Embedding is when you include one type inside another without giving it a field name:
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+     Age  int
+ }
+ 
+ type Employee struct {
+     Person              // embedded - no field name
+     EmployeeID string
+     Department string
+ }
+ &#96;&#96;&#96;
+ 
+ Notice: &#96;Person&#96; is listed without a name. It's not &#96;person Person&#96;, just &#96;Person&#96;. That's embedding.
+ 
+ What does this give you? The embedded type's fields and methods are **promoted** to the outer type:
+ 
+ &#96;&#96;&#96;go
+ emp := Employee{
+     Person:     Person{Name: "Alice", Age: 30},
+     EmployeeID: "E123",
+     Department: "Engineering",
+ }
+ 
+ // These all work:
+ fmt.Println(emp.Name)        // "Alice" - promoted from Person
+ fmt.Println(emp.Age)         // 30 - promoted from Person
+ fmt.Println(emp.EmployeeID)  // "E123" - direct field
+ fmt.Println(emp.Person.Name) // "Alice" - explicit access still works
+ &#96;&#96;&#96;
+ 
+ The &#96;Employee&#96; type didn't "inherit" from &#96;Person&#96;. It *contains* a &#96;Person&#96; and Go conveniently promotes its members.
+ 
+ ## Methods Are Promoted Too
+ 
+ If &#96;Person&#96; has methods, &#96;Employee&#96; gets them:
+ 
+ &#96;&#96;&#96;go
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hi, I'm %s", p.Name)
+ }
+ 
+ emp := Employee{Person: Person{Name: "Alice"}}
+ fmt.Println(emp.Greet())  // "Hi, I'm Alice"
+ &#96;&#96;&#96;
+ 
+ The method is promoted. You call it on &#96;Employee&#96;, but it executes as if called on the embedded &#96;Person&#96;. 
+ 
+ This looks like inheritance. But there's a crucial difference.
+ 
+ ## It's Not Inheritance: The Receiver Stays the Same
+ 
+ In inheritance, an overridden method in a subclass can access &#96;this&#96;/&#96;self&#96; as the subclass type. That's polymorphism.
+ 
+ In embedding, the method's receiver is still the embedded type:
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+ }
+ 
+ func (p Person) Introduce() string {
+     return fmt.Sprintf("I am %s", p.Name)
+ }
+ 
+ type Employee struct {
+     Person
+     Title string
+ }
+ 
+ // This is NOT overriding - it's shadowing
+ func (e Employee) Introduce() string {
+     return fmt.Sprintf("I am %s, %s", e.Name, e.Title)
+ }
+ &#96;&#96;&#96;
+ 
+ If &#96;Person.Introduce()&#96; called another method, that call wouldn't magically dispatch to &#96;Employee&#96;'s version:
+ 
+ &#96;&#96;&#96;go
+ func (p Person) FullIntro() string {
+     return p.Introduce() + ". Nice to meet you!"  // calls Person.Introduce, always
+ }
+ 
+ emp := Employee{Person: Person{Name: "Alice"}, Title: "Engineer"}
+ fmt.Println(emp.FullIntro())  // "I am Alice. Nice to meet you!"
+ // Not "I am Alice, Engineer. Nice to meet you!"
+ &#96;&#96;&#96;
+ 
+ There's no dynamic dispatch based on the outer type. The embedded &#96;Person&#96; doesn't know it's inside an &#96;Employee&#96;. It just does its thing.
+ 
+ This is composition, not inheritance. It's a feature, not a limitation.
+ 
+ ## Multiple Embedding
+ 
+ You can embed multiple types:
+ 
+ &#96;&#96;&#96;go
+ type Reader struct { ... }
+ func (r Reader) Read(p []byte) (int, error) { ... }
+ 
+ type Writer struct { ... }
+ func (w Writer) Write(p []byte) (int, error) { ... }
+ 
+ type ReadWriter struct {
+     Reader
+     Writer
+ }
+ 
+ // ReadWriter now has both Read and Write methods
+ &#96;&#96;&#96;
+ 
+ This is like implementing multiple interfaces, except you're getting actual implementations, not just contracts.
+ 
+ If there are conflicts (both embedded types have a method with the same name), you get a compile error when you try to call the ambiguous method. You resolve it by calling explicitly:
+ 
+ &#96;&#96;&#96;go
+ rw.Reader.SomeMethod()  // explicit disambiguation
+ rw.Writer.SomeMethod()
+ &#96;&#96;&#96;
+ 
+ ## Embedding Interfaces
+ 
+ You can also embed interfaces in interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ 
+ type Writer interface {
+     Write(p []byte) (n int, err error)
+ }
+ 
+ type ReadWriter interface {
+     Reader  // embedded
+     Writer  // embedded
+ }
+ &#96;&#96;&#96;
+ 
+ This is just interface composition. &#96;ReadWriter&#96; requires both &#96;Read&#96; and &#96;Write&#96; methods.
+ 
+ And you can embed interfaces in structs:
+ 
+ &#96;&#96;&#96;go
+ type MyHandler struct {
+     http.Handler  // embedded interface
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;MyHandler&#96; has a field of type &#96;http.Handler&#96;, and its methods are promoted. You can create a &#96;MyHandler&#96; with any &#96;http.Handler&#96; implementation.
+ 
+ This is useful for decorating or wrapping behaviour.
+ 
+ ## The "Delegation" Pattern
+ 
+ Want to wrap something and override specific behaviour? Embed and shadow:
+ 
+ &#96;&#96;&#96;go
+ type LoggingWriter struct {
+     io.Writer  // embedded interface
+ }
+ 
+ func (lw LoggingWriter) Write(p []byte) (n int, err error) {
+     log.Printf("writing %d bytes", len(p))
+     return lw.Writer.Write(p)  // delegate to embedded
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;LoggingWriter&#96; embeds an &#96;io.Writer&#96;. It has its own &#96;Write&#96; method that logs then delegates. Everything else passes through unchanged.
+ 
+ Use it like:
+ 
+ &#96;&#96;&#96;go
+ file, _ := os.Create("output.txt")
+ logged := LoggingWriter{Writer: file}
+ logged.Write([]byte("hello"))  // logs then writes
+ &#96;&#96;&#96;
+ 
+ This is the decorator pattern, but simple and type-safe.
+ 
+ ## Comparing to C# Inheritance
+ 
+ Let's see the same concept in C#:
+ 
+ &#96;&#96;&#96;csharp
+ public class Person
+ {
+     public string Name { get; set; }
+     public virtual string Greet() =&gt; $"Hi, I'm {Name}";
+ }
+ 
+ public class Employee : Person
+ {
+     public string EmployeeID { get; set; }
+     public override string Greet() =&gt; $"Hi, I'm {Name}, employee {EmployeeID}";
+ }
+ &#96;&#96;&#96;
+ 
+ With inheritance, &#96;Employee&#96; IS-A &#96;Person&#96;. Polymorphism works. Override methods get called even when accessed through a base reference.
+ 
+ &#96;&#96;&#96;csharp
+ Person p = new Employee { Name = "Alice", EmployeeID = "E123" };
+ Console.WriteLine(p.Greet());  // "Hi, I'm Alice, employee E123" - polymorphic!
+ &#96;&#96;&#96;
+ 
+ Go's embedding doesn't do this. &#96;Employee&#96; HAS-A &#96;Person&#96;. No polymorphism. No override resolution.
+ 
+ ## When You'll Miss Inheritance
+ 
+ Let's be honest: there are patterns that inheritance handles elegantly.
+ 
+ **Template Method Pattern:**
+ 
+ &#96;&#96;&#96;csharp
+ public abstract class DataProcessor
+ {
+     public void Process()
+     {
+         var data = LoadData();
+         var transformed = Transform(data);  // subclass provides this
+         Save(transformed);
+     }
+     
+     protected abstract object Transform(object data);
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, you'd use an interface:
+ 
+ &#96;&#96;&#96;go
+ type Transformer interface {
+     Transform(data any) any
+ }
+ 
+ type DataProcessor struct {
+     transformer Transformer
+ }
+ 
+ func (dp *DataProcessor) Process() {
+     data := dp.LoadData()
+     transformed := dp.transformer.Transform(data)
+     dp.Save(transformed)
+ }
+ &#96;&#96;&#96;
+ 
+ More explicit, arguably clearer, but more code.
+ 
+ **Protected Members:**
+ 
+ C# has &#96;protected&#96;—visible to derived classes. Go has nothing like this. Everything is either exported (public) or unexported (package-private).
+ 
+ If you want controlled extension points, you design them explicitly with interfaces, not protected methods.
+ 
+ ## When Embedding Shines
+ 
+ **Extending functionality without modification:**
+ 
+ &#96;&#96;&#96;go
+ type CountingReader struct {
+     io.Reader
+     count int
+ }
+ 
+ func (cr *CountingReader) Read(p []byte) (n int, err error) {
+     n, err = cr.Reader.Read(p)
+     cr.count += n
+     return
+ }
+ &#96;&#96;&#96;
+ 
+ Wrap any reader. Count bytes. Original reader unchanged.
+ 
+ **Combining capabilities:**
+ 
+ &#96;&#96;&#96;go
+ type Server struct {
+     http.Server       // get all http.Server fields and methods
+     Logger *log.Logger
+     Metrics *Metrics
+ }
+ &#96;&#96;&#96;
+ 
+ Your server has everything &#96;http.Server&#96; has, plus your additions.
+ 
+ **Implementing interfaces via delegation:**
+ 
+ &#96;&#96;&#96;go
+ type DB struct {
+     pool *sql.DB  // not embedded, private
+ }
+ 
+ // Expose only what you want
+ func (db *DB) Query(q string) (*sql.Rows, error) {
+     return db.pool.Query(q)
+ }
+ &#96;&#96;&#96;
+ 
+ Control the surface area. Don't embed if you don't want to expose everything.
+ 
+ ## The Honest Take
+ 
+ I was skeptical. "Composition over inheritance" sounded like coping. Then I used Go for six months and realised: I don't miss inheritance. Not really.
+ 
+ **What Go does better:**
+ - Forces you to think about composition
+ - No fragile base class problem
+ - No diamond inheritance nightmare
+ - Clear delegation chain
+ - Easy to wrap and extend behaviour
+ 
+ **What C# does better:**
+ - Polymorphism when you actually need it
+ - Template method pattern
+ - Protected members for controlled extension
+ - Clearer "IS-A" relationships in domain modelling
+ 
+ **The verdict:**
+ Inheritance is a sharp tool. It's powerful when used well and creates brittle, tangled hierarchies when used poorly. Go removes the temptation.
+ 
+ Embedding plus interfaces gives you most of what you need. The rest can be solved with explicit design patterns. You'll write more code sometimes, but it'll be clearer code.
+ 
+ And honestly? Those deep inheritance hierarchies you built in C#? They probably shouldn't have been inheritance anyway.
+ 
+ ---
+ 
+ *Next up: the empty interface and type assertions—when you're basically back to &#96;object&#96;, and how to work with Go's dynamic typing escape hatch.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-any.md</summary>

**Chunk 1**
Lines added: 329, lines removed: 1

```diff
@@ -1,1 +1,329 @@
- 
+ +++
+ title = "The Empty Interface and Type Assertions"
+ date = "2025-01-02"
+ draft = false
+ tags = ["go", "dotnet", "interfaces", "any", "csharp"]
+ +++
+ 
+ Go has a type called &#96;any&#96;. Before Go 1.18, it was written &#96;interface{}&#96;. Same thing, nicer name. And it's basically Go's version of &#96;object&#96;—the type that can hold anything.
+ 
+ Every type in Go implements &#96;any&#96; because &#96;any&#96; has no methods. Zero requirements means universal satisfaction. And that means when you use &#96;any&#96;, you're opting out of the type system.
+ 
+ Let's talk about when that's okay, when it's not, and how to get your types back when you need them.
+ 
+ ## What Is &#96;any&#96; / &#96;interface{}&#96;?
+ 
+ An empty interface is an interface with no methods:
+ 
+ &#96;&#96;&#96;go
+ interface{}  // the old syntax
+ any          // alias added in Go 1.18, same thing
+ &#96;&#96;&#96;
+ 
+ Since there are no required methods, every type satisfies this interface. Everything is an &#96;any&#96;.
+ 
+ &#96;&#96;&#96;go
+ var x any
+ 
+ x = 42              // int
+ x = "hello"         // string
+ x = []int{1, 2, 3}  // slice
+ x = struct{}{}      // empty struct
+ x = nil             // nil
+ &#96;&#96;&#96;
+ 
+ All valid. &#96;any&#96; is the universal container.
+ 
+ ## The C# Equivalent: &#96;object&#96;
+ 
+ C#'s &#96;object&#96; is the same idea:
+ 
+ &#96;&#96;&#96;csharp
+ object x;
+ x = 42;
+ x = "hello";
+ x = new List&lt;int&gt; { 1, 2, 3 };
+ &#96;&#96;&#96;
+ 
+ Both languages have this escape hatch for "I don't know the type at compile time." Both languages encourage you to avoid it when possible.
+ 
+ ## Why &#96;any&#96; Exists
+ 
+ Sometimes you genuinely don't know the type:
+ 
+ **JSON with unknown structure:**
+ 
+ &#96;&#96;&#96;go
+ var data any
+ json.Unmarshal(rawBytes, &amp;data)
+ // data is now map[string]any or []any or a primitive
+ &#96;&#96;&#96;
+ 
+ **Generic containers before Go had generics:**
+ 
+ &#96;&#96;&#96;go
+ // Before Go 1.18
+ type Stack struct {
+     items []interface{}
+ }
+ 
+ func (s *Stack) Push(item interface{}) {
+     s.items = append(s.items, item)
+ }
+ &#96;&#96;&#96;
+ 
+ **Function parameters that accept anything:**
+ 
+ &#96;&#96;&#96;go
+ func Println(a ...any) (n int, err error)
+ &#96;&#96;&#96;
+ 
+ &#96;fmt.Println&#96; takes &#96;any&#96; because it prints anything.
+ 
+ ## Type Assertions: Getting Types Back
+ 
+ When you have an &#96;any&#96; and need the actual type, you use a **type assertion**:
+ 
+ &#96;&#96;&#96;go
+ var x any = "hello"
+ 
+ s := x.(string)  // assert x is a string
+ fmt.Println(s)   // "hello"
+ &#96;&#96;&#96;
+ 
+ The syntax is &#96;value.(Type)&#96;. It says "I believe this &#96;any&#96; contains a &#96;Type&#96;, give it to me."
+ 
+ ### The Danger: Panics
+ 
+ If you're wrong, it panics:
+ 
+ &#96;&#96;&#96;go
+ var x any = 42
+ s := x.(string)  // panic: interface conversion: int is not string
+ &#96;&#96;&#96;
+ 
+ This is like an invalid cast exception in C#:
+ 
+ &#96;&#96;&#96;csharp
+ object x = 42;
+ string s = (string)x;  // InvalidCastException
+ &#96;&#96;&#96;
+ 
+ ### The Safe Way: Comma-OK Idiom
+ 
+ Always use the two-value form in real code:
+ 
+ &#96;&#96;&#96;go
+ var x any = 42
+ 
+ s, ok := x.(string)
+ if !ok {
+     fmt.Println("x is not a string")
+ } else {
+     fmt.Println(s)
+ }
+ &#96;&#96;&#96;
+ 
+ If the assertion fails, &#96;ok&#96; is &#96;false&#96; and &#96;s&#96; is the zero value of &#96;string&#96;. No panic.
+ 
+ This is like C#'s &#96;as&#96; operator plus null check:
+ 
+ &#96;&#96;&#96;csharp
+ object x = 42;
+ if (x is string s)
+ {
+     Console.WriteLine(s);
+ }
+ else
+ {
+     Console.WriteLine("x is not a string");
+ }
+ &#96;&#96;&#96;
+ 
+ ## Type Switches: Handling Multiple Types
+ 
+ When you need to handle different types, use a type switch:
+ 
+ &#96;&#96;&#96;go
+ func describe(x any) {
+     switch v := x.(type) {
+     case int:
+         fmt.Printf("int: %d\n", v)
+     case string:
+         fmt.Printf("string: %s\n", v)
+     case bool:
+         fmt.Printf("bool: %t\n", v)
+     case []int:
+         fmt.Printf("slice of ints: %v\n", v)
+     default:
+         fmt.Printf("unknown type: %T\n", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;x.(type)&#96; syntax only works in a switch. Each case binds &#96;v&#96; to the correctly typed value.
+ 
+ This is cleaner than chained type assertions:
+ 
+ &#96;&#96;&#96;go
+ // DON'T do this
+ if i, ok := x.(int); ok {
+     // ...
+ } else if s, ok := x.(string); ok {
+     // ...
+ } else if b, ok := x.(bool); ok {
+     // ...
+ }
+ 
+ // DO this
+ switch v := x.(type) {
+ case int:
+     // v is int
+ case string:
+     // v is string
+ case bool:
+     // v is bool
+ }
+ &#96;&#96;&#96;
+ 
+ ## Working with JSON
+ 
+ This is where &#96;any&#96; shows up most in real code. JSON decoding into unknown structures:
+ 
+ &#96;&#96;&#96;go
+ func processJSON(raw []byte) error {
+     var data any
+     if err := json.Unmarshal(raw, &amp;data); err != nil {
+         return err
+     }
+     
+     return walkJSON(data)
+ }
+ 
+ func walkJSON(v any) error {
+     switch val := v.(type) {
+     case map[string]any:
+         for key, value := range val {
+             fmt.Printf("key: %s\n", key)
+             walkJSON(value)
+         }
+     case []any:
+         for i, item := range val {
+             fmt.Printf("index: %d\n", i)
+             walkJSON(item)
+         }
+     case string:
+         fmt.Printf("string: %s\n", val)
+     case float64:  // JSON numbers are float64
+         fmt.Printf("number: %f\n", val)
+     case bool:
+         fmt.Printf("bool: %t\n", val)
+     case nil:
+         fmt.Println("null")
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ JSON objects become &#96;map[string]any&#96;. Arrays become &#96;[]any&#96;. Numbers are always &#96;float64&#96; (JSON doesn't distinguish int from float).
+ 
+ ## The Performance Cost
+ 
+ There's overhead to &#96;any&#96;. The interface value stores two pointers (type and value), and type assertions have runtime cost.
+ 
+ For hot paths, you want concrete types:
+ 
+ &#96;&#96;&#96;go
+ // Slower - any with type assertion
+ func processAny(x any) {
+     if n, ok := x.(int); ok {
+         // work with n
+     }
+ }
+ 
+ // Faster - concrete type
+ func processInt(n int) {
+     // work with n
+ }
+ &#96;&#96;&#96;
+ 
+ With generics in Go 1.18+, you often don't need &#96;any&#96;:
+ 
+ &#96;&#96;&#96;go
+ // Before generics
+ func Contains(slice []any, item any) bool { ... }
+ 
+ // With generics - type safe, no assertions needed
+ func Contains[T comparable](slice []T, item T) bool { ... }
+ &#96;&#96;&#96;
+ 
+ ## When to Use &#96;any&#96;
+ 
+ **Legitimate uses:**
+ 
+ - JSON/YAML with unknown structure
+ - Reflection-based code
+ - Interfacing with dynamic systems
+ - Printf-style variadic functions
+ 
+ **Code smells:**
+ 
+ - Using &#96;any&#96; to avoid thinking about types
+ - &#96;map[string]any&#96; as a "flexible" data structure (define a struct)
+ - &#96;any&#96; parameters when a specific interface would work
+ - Type assertions scattered throughout code
+ 
+ ## Comparing to C#
+ 
+ | Aspect | Go &#96;any&#96; | C# &#96;object&#96; |
+ |--------|----------|-------------|
+ | Boxing value types | No (pointers stored) | Yes |
+ | Type assertion | &#96;x.(Type)&#96; | &#96;(Type)x&#96; or &#96;x as Type&#96; |
+ | Safe assertion | &#96;v, ok := x.(Type)&#96; | &#96;x is Type v&#96; |
+ | Type switch | &#96;switch v := x.(type)&#96; | &#96;switch (x)&#96; with patterns |
+ | Performance cost | Yes | Yes (especially boxing) |
+ 
+ C# has better pattern matching:
+ 
+ &#96;&#96;&#96;csharp
+ object x = GetSomething();
+ var result = x switch
+ {
+     int i =&gt; $"int: {i}",
+     string s =&gt; $"string: {s}",
+     IEnumerable&lt;int&gt; list =&gt; $"list with {list.Count()} items",
+     { } obj =&gt; $"object: {obj}",
+     null =&gt; "null"
+ };
+ &#96;&#96;&#96;
+ 
+ Go's type switch is simpler but less powerful.
+ 
+ ## The Honest Take
+ 
+ &#96;any&#96; is an escape hatch. Sometimes you need it. Most of the time, you don't.
+ 
+ **What Go does okay:**
+ - Clear syntax for type assertions
+ - Type switches are readable
+ - No boxing for value types (unlike C#)
+ 
+ **What C# does better:**
+ - Richer pattern matching
+ - &#96;is&#96; and &#96;as&#96; operators are more intuitive
+ - Better tooling for discovering what types you'll encounter
+ 
+ **What both should make you do:**
+ - Reach for generics first
+ - Define concrete interfaces where possible
+ - Use &#96;any&#96; only at boundaries (JSON parsing, reflection, interop)
+ 
+ **The verdict:**
+ Every time you write &#96;any&#96;, ask yourself: "Do I really not know the type here?" Often you do know it, or you could define an interface that captures what you need.
+ 
+ &#96;any&#96; is the "I give up" of Go's type system. Sometimes giving up is appropriate. A well-designed API rarely needs it.
+ 
+ ---
+ 
+ *That wraps up the interfaces and composition section. Go's approach is simpler than C#'s—implicit interfaces, embedding instead of inheritance, and a minimal &#96;any&#96; type for the truly dynamic cases. It's less powerful in some ways, but the constraints push you toward cleaner designs.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      22
---
content/posts/dotnet-to-go-any.md
content/posts/dotnet-to-go-channels.md
content/posts/dotnet-to-go-composition.md
content/posts/dotnet-to-go-context.md
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-escape-analysis.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-goroutines.md
content/posts/dotnet-to-go-interfaces.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-pointers.md
content/posts/dotnet-to-go-select.md
content/posts/dotnet-to-go-slices.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-sync.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 22 posts are done and the build passes. Let me summarize the complete series for the user.</details></think>

---

All 3 Interfaces & Composition posts done! 22 posts total now. Here's the complete series:

## C# to Go Series (22 posts)

### Phase 1: Getting Oriented (3)
1. "You Know .NET, Now Meet the Go Toolchain"
2. "Goodbye .csproj, Hello go.mod"
3. "The Phrasebook: C# Concepts in Go Terms"

### Phase 2: Types & Data (5)
4. "Your Class Is Now a Struct (And That's Fine)"
5. "Where Did My Properties Go?"
6. "Generics: Late to the Party"
7. "The Million Dollar Mistake, Differently"
8. "No Enums? No Problem (Sort Of)"

### Phase 3: Control Flow & Error Handling (3)
9. "if err != nil: Your New Reality"
10. "Panic and Recover: The Emergency Exit"
11. "The switch Statement You Always Wanted"

### Phase 4: Memory & Pointers (3)
12. "Pointers Without the Pain"
13. "Stack vs Heap: Go's Escape Analysis"
14. "Slices Are Not Arrays (And Neither Is List<T>)"

### Phase 5: Concurrency (5)
15. "Async/Await vs Goroutines: A Mindset Shift"
16. "Channels: The sync You Didn't Know You Wanted"
17. "select: Multiplexing Like a Pro"
18. "Mutexes and WaitGroups: When Channels Aren't the Answer"
19. "Context Is King"

### Phase 6: Interfaces & Composition ← **NEW** (3)
20. **"Implicit Interfaces: Scary Then Brilliant"** — No implements keyword, structural typing, defining interfaces after the fact, the compile-time satisfaction check (`var _ Writer = (*MyType)(nil)`), value vs pointer receivers with interfaces
21. **"Composition Over Inheritance (For Real This Time)"** — What embedding actually is (fields without names), method promotion, why it's NOT inheritance (receiver stays the same), multiple embedding, the decorator/delegation pattern
22. **"The Empty Interface and Type Assertions"** — `any` / `interface{}` as Go's `object`, type assertions (`x.(Type)`), the comma-ok idiom, type switches, when `any` is legitimate vs a code smell

Key definitions included:
- **Embedding**: Including a type without a field name, promoting its methods and fields
- **Structural typing**: If it has the methods, it implements the interface
- **Type assertion**: Extracting a concrete type from an interface value
- **Method promotion**: Embedded type's methods become available on the outer type

That's Phase 1 complete! Ready for more whenever you are.

---

