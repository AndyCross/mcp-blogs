<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 1d0ceaf5-94a8-4b5f-a896-102e7ffa7415 (2025-12-28 20:16Z) -->

# C# to Go blog content series (2025-12-28 20:16Z)

_**User (2025-12-28 20:16Z)**_

System prompt: # System Prompt: C# to Go Blog Content

You are a technical writing assistant helping create blog content for experienced C# developers learning Go. The blog documents a genuine learning journey—honest about the bumps, excited about the discoveries.

## Voice & Tone

- **UK English** throughout (favour, colour, organised, whilst, etc.)
- **Techie informal**: Write like a senior dev explaining things to a mate over coffee. Relaxed but precise. No corporate waffle.
- **First person plural** ("we'll", "let's", "we can see") to create a sense of learning together
- Occasional dry humour is welcome; forced jokes are not
- Swearing is fine if it lands naturally (the odd "bloody hell" when something's genuinely surprising)

## Code Style

### Go Code Must:
- Follow idiomatic Go conventions (gofmt, effective Go guidelines)
- Use short, clear variable names as Go devs expect (not C#'s verbose style)
- Prefer explicit error handling—don't hide it, explain it
- Include comments only where they add genuine value
- Be production-worthy, not just "tutorial code"

### C# Comparisons:
- Show C# snippets when the contrast is illuminating
- Highlight where muscle memory will trip you up
- Be fair to both languages—no tribal nonsense
- Point out where Go's approach might feel "worse" at first but explain the reasoning

## Content Structure

### Each Post Should:
1. **Hook**: Start with a real problem or question, not theory
2. **Context**: Brief "why this matters" for working devs
3. **Meat**: The actual learning, with code and explanation
4. **Gotchas**: What caught you out coming from C#
5. **Summary**: Key takeaways, no fluff

### Technical Progression:
The series moves from fundamentals to ecosystem:
- **Phase 1**: Low-level skills (types, memory, concurrency, error handling)
- **Phase 2**: Ecosystem (modules, testing, tooling, common libraries)
- **Phase 3**: Deployment (containers, cloud, CI/CD, observability)

## Formatting Guidelines

- Use headers sparingly—not everything needs a subheading
- Code blocks should be runnable where possible
- Keep paragraphs short; dense walls of text lose readers
- Use tables for genuine comparisons, not for decoration
- Link to official Go docs rather than duplicating them

## What to Avoid

- Overselling Go or bashing C#/.NET
- Assuming readers don't know what they're doing in their current stack
- Hiding complexity—if something's genuinely harder in Go, say so
- Tutorial-speak ("In this article, we will learn...")
- Unnecessary caveats and hedging

## Example Phrases That Fit the Tone

✓ "Right, let's dig into how Go handles this differently."
✓ "If you're coming from C#, your first instinct will be to reach for generics. Hold that thought."
✓ "This looks mental at first glance, but there's method to it."
✓ "Honestly? I'm still not sure this is better. But here's the reasoning."

✗ "In this comprehensive guide, we will explore..."
✗ "As developers, we must always strive to..."
✗ "It is important to note that..."

============

Create a new series, and the first two posts in that series:

Phase 1: The Fundamentals (Low-Level Skills)
Getting Oriented

You Know .NET, Now Meet the Go Toolchain — dotnet CLI vs go commands, project structure, where your code actually lives
Goodbye .csproj, Hello go.mod — Dependency management when NuGet isn't an option

Try to match the tone of the existing docs but also the new instructions above.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create a new blog series for C# developers learning Go. They want me to:
1. First, understand the existing blog's tone and structure by reading the existing posts
2. Create a series introduction and the first two posts following the system prompt guidelines

Let me start by reading the existing blog posts to understand the tone, formatting, and structure they use.</details></think>

---

I'll start by reading some of the existing blog posts to understand the tone, structure, and formatting conventions used.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/streaming-json-partial-parser.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/conversational-consent-pattern.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/building-3d-scenes-with-mcp.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good sense of the blog's tone and structure. Let me also check the hugo.toml to understand the site configuration and how posts are structured.</details></think>

---

Let me also check the hugo configuration and see one more post for additional context:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/hugo.toml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/andycross/src/personal/mcp-blogs/content/posts/seven-dollars-and-twenty-five-years.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the blog's tone, formatting, and structure. The key elements I notice:

1. **TOML frontmatter** with `+++` delimiters, using `title`, `date`, `draft`, and `tags`
2. **UK English** (favour, colour, organised, etc.)
3. **Informal, techie tone** - writes like a senior dev chatting with colleagues
4. **Tables** used for comparisons
5. **Code blocks** are common and practical
6. **Personal anecdotes** and real problems drive the content
7. **Clear structure** with meaningful headers (not too many)
8. **First person** - "I've been", "I wanted to", etc.
9. **Short paragraphs** - never walls of text
10. **Casual but precise** - uses technical terms correctly but explains them naturally
11. **Light humour** - the nonce comment at the end is perfect example
12. **Links to repos/resources** at the end

Now let me create the new C# to Go series. I need to create:
1. A series introduction or first post about the toolchain
2. Second post about go.mod vs .csproj/NuGet

I should aim for a similar tone but adapted to the new system prompt requirements about C# to Go learning journey. The tone should be:
- UK English
- Techie informal
- First person plural ("we'll", "let's")
- Dry humour where natural
- Fair to both languages

Let me write these posts now.</details></think>

---

Now I have a great sense of the blog's tone and structure. Let me create the two new posts for the C# to Go series. I'll write them in the same style—informal, technically precise, UK English, with the specific focus on a C# developer's perspective learning Go.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: 202, lines removed: 1

```diff
@@ -1,1 +1,202 @@
- 
+ +++
+ title = "You Know .NET, Now Meet the Go Toolchain"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "tooling", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ After twenty-odd years writing C#, I'm learning Go. Not because .NET has failed me—it hasn't—but because some problems want a different shape of solution. Small binaries. Fast startup. Simple deployment. The kind of thing Go does without breaking a sweat.
+ 
+ This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.
+ 
+ Let's start with the toolchain. Because before we write any code, we need to know where everything lives.
+ 
+ ## The First Surprise: There's Only One Tool
+ 
+ In .NET, you've got &#96;dotnet&#96; for building, running, testing, and package management. Fair enough. But you've also got Visual Studio, Rider, or VS Code doing heavy lifting. MSBuild lurks underneath. NuGet has its own config. The SDK has versions. The runtime has versions. Different platforms have different workloads.
+ 
+ Go has &#96;go&#96;.
+ 
+ That's it. One command. Build, run, test, format, vet, mod management—all through the same tool. There's no separate "SDK" to install per project. No workload selectors. No runtime configuration.
+ 
+ &#96;&#96;&#96;bash
+ go build    # compiles
+ go run      # compiles and runs
+ go test     # runs tests
+ go fmt      # formats code
+ go vet      # static analysis
+ go mod      # dependency management
+ go get      # adds dependencies
+ &#96;&#96;&#96;
+ 
+ Coming from .NET, this feels almost suspiciously simple. Where's the configuration? Where are the project files? Where's the magic?
+ 
+ The answer: there isn't much. And that's the point.
+ 
+ ## Where Your Code Lives
+ 
+ Here's where your C# instincts will immediately try to betray you.
+ 
+ In .NET, you create a solution, add projects, reference other projects, configure output paths, set up different configurations for debug and release... you know the drill. Projects live wherever you put them. References can point anywhere.
+ 
+ Go has opinions.
+ 
+ ### GOPATH (The Old Way)
+ 
+ Originally, Go wanted all your code in a single workspace called &#96;GOPATH&#96;. Everything lived under &#96;$GOPATH/src/&#96;, organised by import path. If you were writing code for GitHub, it literally lived at &#96;$GOPATH/src/github.com/yourname/yourproject&#96;.
+ 
+ This drove people mad. Especially people coming from languages where "put your project wherever you like" is the norm.
+ 
+ ### Modules (The Current Way)
+ 
+ Since Go 1.11, modules freed us from GOPATH. Now a project can live anywhere, and its identity comes from its &#96;go.mod&#96; file rather than its filesystem location.
+ 
+ &#96;&#96;&#96;bash
+ mkdir myproject &amp;&amp; cd myproject
+ go mod init github.com/yourname/myproject
+ &#96;&#96;&#96;
+ 
+ That &#96;go mod init&#96; command creates a &#96;go.mod&#96; file—Go's equivalent of your &#96;.csproj&#96;. We'll dig into that properly in the next post.
+ 
+ The key insight: **the module path is the project's identity**. It's what other code uses to import your packages. Choose it thoughtfully.
+ 
+ ## The Build Model
+ 
+ This is where things get genuinely different, and honestly? It took me a while to stop fighting it.
+ 
+ ### C# Build Mental Model
+ 
+ In .NET, compilation is incremental and complex. MSBuild tracks dependencies between projects. The compiler emits IL. The runtime JITs it (or AOT compiles it, if you're being fancy). Builds produce assemblies. Assemblies reference other assemblies. There's a whole graph of dependencies that lives in your &#96;bin&#96; folder.
+ 
+ ### Go Build Mental Model
+ 
+ Go compiles to machine code. Directly. No IL, no runtime, no JIT. The &#96;go build&#96; command produces a single static binary that you can copy anywhere and run.
+ 
+ &#96;&#96;&#96;bash
+ go build -o myapp
+ ./myapp  # just... runs
+ &#96;&#96;&#96;
+ 
+ No &#96;dotnet&#96; required on the target machine. No runtime version matching. No framework-dependent vs self-contained deployment decisions. Copy the binary, run it. Done.
+ 
+ The tradeoff? Larger binaries than a framework-dependent .NET app (though smaller than self-contained). But the simplicity of deployment is remarkable.
+ 
+ ### Cross-Compilation
+ 
+ Here's something that still delights me. Want to build for Linux from your Mac?
+ 
+ &#96;&#96;&#96;bash
+ GOOS=linux GOARCH=amd64 go build -o myapp-linux
+ &#96;&#96;&#96;
+ 
+ Done. No Docker, no separate SDK installation, no drama. Go's cross-compilation is a first-class citizen, not an afterthought.
+ 
+ ## Project Structure
+ 
+ A minimal Go project looks nothing like a minimal C# project.
+ 
+ ### C# (Minimal API, .NET 8)
+ 
+ &#96;&#96;&#96;
+ MyProject/
+ ├── MyProject.csproj
+ ├── Program.cs
+ ├── appsettings.json
+ ├── appsettings.Development.json
+ ├── Properties/
+ │   └── launchSettings.json
+ └── bin/
+     └── Debug/
+         └── net8.0/
+             └── (loads of stuff)
+ &#96;&#96;&#96;
+ 
+ ### Go
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── go.mod
+ └── main.go
+ &#96;&#96;&#96;
+ 
+ That's it. Two files. The &#96;go.mod&#96; declares your module identity and dependencies. The &#96;main.go&#96; contains your code. Build it, get a binary.
+ 
+ No configuration hierarchy. No launch profiles. No bin/obj dance. Just source code and a module definition.
+ 
+ ## The Gotchas (Already)
+ 
+ ### Case Sensitivity Matters
+ 
+ Go uses case to control visibility. Uppercase first letter = exported (public). Lowercase = unexported (internal to the package).
+ 
+ &#96;&#96;&#96;go
+ func ProcessData() {}  // exported, other packages can call this
+ func processData() {}  // unexported, package-private
+ &#96;&#96;&#96;
+ 
+ Your C# brain will want to reach for &#96;public&#96; and &#96;private&#96; keywords. They don't exist in Go. Case *is* the visibility modifier.
+ 
+ ### No Implicit Main Package
+ 
+ In C#, top-level statements let you skip the ceremony. In Go, you always need:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ func main() {
+     // your code
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;package main&#96; declaration tells Go this is an executable. The &#96;main()&#96; function is the entry point. No variation. No magic. Every Go executable looks like this.
+ 
+ ### File Organisation Isn't Free
+ 
+ In C#, namespaces and folders are loosely coupled. You can have a file in &#96;Services/&#96; that declares &#96;namespace MyApp.Models&#96;. Weird, but legal.
+ 
+ In Go, packages are directories. Every &#96;.go&#96; file in a directory must have the same &#96;package&#96; declaration. Want a different package? Different directory. No exceptions.
+ 
+ This feels restrictive at first. Then you realise it makes codebases significantly easier to navigate. You always know what package a file belongs to—just look at where it lives.
+ 
+ ## What We Haven't Covered
+ 
+ This is just orientation. We haven't touched:
+ 
+ - **How &#96;go.mod&#96; actually works** (next post)
+ - **How packages and imports differ from namespaces**
+ - **The &#96;internal&#96; directory convention**
+ - **Testing conventions**
+ - **The standard library**
+ 
+ All coming. But first, I wanted to establish the basic geography. Where code lives. How it builds. What tools you actually use.
+ 
+ ## The Honest Assessment
+ 
+ After a few weeks with Go's toolchain, here's my take:
+ 
+ **Better than C#:**
+ - Simplicity. One tool, minimal configuration.
+ - Cross-compilation. Effortless.
+ - Build speed. It's genuinely fast.
+ - Deployment. Single binary, no runtime.
+ 
+ **Worse than C#:**
+ - IDE support. Go has good tooling, but it's not Rider/Visual Studio level.
+ - Refactoring. The tools exist, but they're less sophisticated.
+ - Debug experience. It's fine, but not the polished F5 experience you're used to.
+ 
+ **Different, neither better nor worse:**
+ - Project structure. Go's conventions feel strange, then liberating.
+ - Package system. We'll cover this properly, but it's a genuine paradigm shift.
+ 
+ The toolchain isn't trying to be .NET. It's not trying to be "simple .NET" or ".NET but faster". It's a different philosophy: less configuration, more convention, explicit over implicit.
+ 
+ That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.
+ 
+ But there's method to the explicitness. And honestly? I'm starting to appreciate it.
+ 
+ ---
+ 
+ *Next up: go.mod in depth—dependency management without NuGet, and why it's both simpler and more opinionated than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: 279, lines removed: 1

```diff
@@ -1,1 +1,279 @@
- 
+ +++
+ title = "Goodbye .csproj, Hello go.mod"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "dependencies", "csharp"]
+ series = ["C# to Go"]
+ +++
+ 
+ Right, let's talk about dependencies. In .NET land, we've got NuGet, &#96;.csproj&#96; files, &#96;PackageReference&#96; elements, version ranges, transitive dependencies, and &#96;packages.lock.json&#96; if we're being careful. It's a mature ecosystem with excellent tooling.
+ 
+ Go does things differently. There's no NuGet. There's no package registry at all, actually. And that sounds mental until you understand why—and discover it works rather well.
+ 
+ ## The go.mod File
+ 
+ Every Go module has a &#96;go.mod&#96; file at its root. Here's a real one:
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ 
+ go 1.22
+ 
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ 
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+     github.com/gabriel-vasile/mimetype v1.4.2 // indirect
+     // ... more indirect dependencies
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down.
+ 
+ ### Module Declaration
+ 
+ &#96;&#96;&#96;go
+ module github.com/yourname/yourproject
+ &#96;&#96;&#96;
+ 
+ This is your module's identity—its import path. When someone writes &#96;import "github.com/yourname/yourproject/pkg/whatever"&#96;, Go knows where to find it because of this declaration.
+ 
+ Unlike a &#96;.csproj&#96; where the assembly name is mostly internal, this path is *the* identifier. Choose it thoughtfully.
+ 
+ ### Go Version
+ 
+ &#96;&#96;&#96;go
+ go 1.22
+ &#96;&#96;&#96;
+ 
+ This declares the minimum Go version required. It's not exactly the same as &#96;&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#96;—you're not compiling for a specific runtime. You're just saying "this code uses features from Go 1.22, don't try to build it with something older."
+ 
+ ### Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/gin-gonic/gin v1.9.1
+     github.com/stretchr/testify v1.8.4
+ )
+ &#96;&#96;&#96;
+ 
+ Here's where it gets interesting. These are your direct dependencies—the packages you actually import in your code.
+ 
+ Notice the format: &#96;module-path version&#96;. The version uses semantic versioning prefixed with &#96;v&#96;. No version ranges. No floating versions. Exactly this version, every time.
+ 
+ ### Indirect Dependencies
+ 
+ &#96;&#96;&#96;go
+ require (
+     github.com/bytedance/sonic v1.9.1 // indirect
+ )
+ &#96;&#96;&#96;
+ 
+ The &#96;// indirect&#96; comment marks transitive dependencies—packages that your dependencies need, but you don't import directly. Go tracks these explicitly in &#96;go.mod&#96;.
+ 
+ ## No Central Registry
+ 
+ Here's the thing that confused me coming from NuGet: Go doesn't have a package registry.
+ 
+ NuGet has nuget.org. npm has npmjs.com. Go has... URLs.
+ 
+ When you &#96;go get github.com/gin-gonic/gin&#96;, Go literally fetches from GitHub. The module path isn't an identifier that maps to a registry—it's a resolvable URL (with some clever translation rules).
+ 
+ This means:
+ - No registry account needed to publish
+ - No central point of failure
+ - Dependencies are wherever their code lives
+ 
+ But also:
+ - No central search (though pkg.go.dev indexes public modules)
+ - No private registry without extra setup
+ - Version discovery is... different
+ 
+ ## Adding Dependencies
+ 
+ Here's the workflow comparison:
+ 
+ ### In .NET
+ 
+ &#96;&#96;&#96;bash
+ dotnet add package Newtonsoft.Json --version 13.0.3
+ &#96;&#96;&#96;
+ 
+ Or edit your &#96;.csproj&#96;:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="Newtonsoft.Json" Version="13.0.3" /&gt;
+ &#96;&#96;&#96;
+ 
+ Then &#96;dotnet restore&#96;.
+ 
+ ### In Go
+ 
+ &#96;&#96;&#96;bash
+ go get github.com/gin-gonic/gin@v1.9.1
+ &#96;&#96;&#96;
+ 
+ Or just import it in your code:
+ 
+ &#96;&#96;&#96;go
+ import "github.com/gin-gonic/gin"
+ &#96;&#96;&#96;
+ 
+ Then run &#96;go mod tidy&#96;. Go will fetch the dependency, resolve versions, and update &#96;go.mod&#96; automatically.
+ 
+ That &#96;go mod tidy&#96; command is your friend. It adds missing dependencies, removes unused ones, and generally keeps your &#96;go.mod&#96; clean. I run it roughly as often as I save files.
+ 
+ ## Version Selection
+ 
+ Go's approach to version selection is refreshingly simple, and it took me a while to appreciate it.
+ 
+ ### The Problem With Version Ranges
+ 
+ In NuGet, you might declare:
+ 
+ &#96;&#96;&#96;xml
+ &lt;PackageReference Include="SomeLib" Version="[1.0, 2.0)" /&gt;
+ &#96;&#96;&#96;
+ 
+ Meaning "any version from 1.0 up to but not including 2.0." The actual version you get depends on what's available, what other packages need, and the resolver's algorithm.
+ 
+ This flexibility is powerful but creates problems:
+ - Different machines might resolve different versions
+ - Lock files become essential
+ - "Works on my machine" is often a version resolution issue
+ 
+ ### Go's Minimum Version Selection
+ 
+ Go uses something called Minimum Version Selection (MVS). The idea: given all the version constraints, pick the *minimum* version that satisfies everything.
+ 
+ If you require &#96;v1.9.1&#96; and a dependency requires &#96;v1.8.0&#96; of the same module, Go picks &#96;v1.9.1&#96;—the minimum version that satisfies both.
+ 
+ No ranges. No "latest compatible." Just: here are the minimums everyone needs, let's use those.
+ 
+ The result? Given the same &#96;go.mod&#96; and &#96;go.sum&#96; files, you'll always get exactly the same versions. No lock file randomness. No surprising upgrades.
+ 
+ ### The go.sum File
+ 
+ Speaking of which—&#96;go.sum&#96; is Go's integrity file:
+ 
+ &#96;&#96;&#96;
+ github.com/gin-gonic/gin v1.9.1 h1:4idEAncQnU5...
+ github.com/gin-gonic/gin v1.9.1/go.mod h1:RdK04...
+ &#96;&#96;&#96;
+ 
+ It contains cryptographic hashes of every dependency. If a module's contents don't match the recorded hash, the build fails.
+ 
+ Commit this file. It's your guarantee of reproducible builds.
+ 
+ ## Updating Dependencies
+ 
+ The version-pinning approach means updates are explicit:
+ 
+ &#96;&#96;&#96;bash
+ # Update a specific dependency
+ go get github.com/gin-gonic/gin@v1.10.0
+ 
+ # Update all dependencies to latest minor/patch
+ go get -u ./...
+ 
+ # Update all dependencies to latest (including major)
+ go get -u=patch ./...
+ &#96;&#96;&#96;
+ 
+ There's no equivalent to NuGet's floating versions. When you want an update, you ask for it specifically. Some find this tedious; I find it clarifying.
+ 
+ ## Major Versions Are Different Modules
+ 
+ Here's where Go does something clever (and initially bewildering).
+ 
+ In semantic versioning, major version bumps signal breaking changes. &#96;v2.0.0&#96; might have a completely different API from &#96;v1.9.0&#96;.
+ 
+ Go handles this by treating major versions as *different modules*:
+ 
+ &#96;&#96;&#96;go
+ // v1.x
+ import "github.com/go-redis/redis/v8"
+ 
+ // v9.x (yes, they jumped)
+ import "github.com/redis/go-redis/v9"
+ &#96;&#96;&#96;
+ 
+ The import path includes the major version. &#96;v2&#96;, &#96;v3&#96;, etc. are literally different modules.
+ 
+ This means:
+ - You can use v1 and v2 of the same library simultaneously (different import paths)
+ - Breaking changes are impossible to accidentally adopt
+ - Library authors must maintain separate module paths for major versions
+ 
+ It's awkward at first. Then you realise you've never had a build broken by an accidental major version upgrade.
+ 
+ ## The Comparison
+ 
+ | Aspect | NuGet/.csproj | Go Modules |
+ |--------|---------------|------------|
+ | Registry | Central (nuget.org) | Distributed (any URL) |
+ | Version syntax | Ranges allowed | Exact versions only |
+ | Resolution | Complex algorithm | Minimum Version Selection |
+ | Lock file | Optional but recommended | go.sum (hashes only) |
+ | Private packages | Private feeds | Various options (GOPROXY) |
+ | Major versions | Same package ID | Different module paths |
+ 
+ ## What Actually Trips You Up
+ 
+ After a few weeks, here's what caught me out:
+ 
+ ### Import Path Confusion
+ 
+ Your IDE might autocomplete an import as &#96;github.com/gin-gonic/gin/v2&#96; when you wanted &#96;v1&#96;. Check your imports when things don't compile.
+ 
+ ### Forgetting go mod tidy
+ 
+ Add an import, wonder why it doesn't work, realise you never fetched the dependency. &#96;go mod tidy&#96;. Learn to love it.
+ 
+ ### Private Repositories
+ 
+ Public modules "just work." Private repos need GOPROXY configuration or GOPRIVATE settings. It's not hard, but it's not automatic either.
+ 
+ ### Vendor Directory
+ 
+ Go can vendor dependencies—copy them into a &#96;vendor/&#96; directory in your project. Some teams mandate this for reproducibility. If you see a vendor directory, know that &#96;go build&#96; will use it by default.
+ 
+ ## The Honest Take
+ 
+ **Things I like better than NuGet:**
+ 
+ - Reproducibility. Same inputs, same outputs, always.
+ - No central registry dependency. Dependencies are just code at URLs.
+ - Major version handling. Breaking changes are structurally isolated.
+ - Simplicity. One file, explicit versions, done.
+ 
+ **Things I miss from NuGet:**
+ 
+ - Proper package search. pkg.go.dev is decent but not nuget.org.
+ - Private feeds. Azure Artifacts, MyGet, etc. are more polished than GOPROXY setup.
+ - .NET's tooling. &#96;dotnet add package&#96; with tab completion is lovely.
+ - Version ranges. Sometimes I *want* "latest patch version" and Go says no.
+ 
+ **Things that are just different:**
+ 
+ - Import paths being URLs. It's not better or worse, just a different model.
+ - go.sum vs lock files. Similar goal, different mechanism.
+ - The vendor directory. Some love it, some ignore it entirely.
+ 
+ ## The Philosophy
+ 
+ There's a reason Go's dependency management feels different: it was designed later, learning from problems with other systems.
+ 
+ The Ruby and Node ecosystems taught us that flexible version resolution leads to "works on my machine" nightmares. Go said: fine, no flexibility. Exact versions always.
+ 
+ The npm left-pad incident taught us that central registries are single points of failure. Go said: fine, no central registry. Your dependencies are wherever their source code lives.
+ 
+ Whether you prefer this philosophy is personal. But understanding *why* Go made these choices helps you work with the system rather than fighting it.
+ 
+ ---
+ 
+ *Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
I've created both blog posts. Let me verify the hugo server can build these correctly by checking for any issues, and also make sure the frontmatter is correct for the existing blog structure.

Let me check if there's a `series` taxonomy configured in Hugo, since I added that to the frontmatter. Let me look at the hugo.toml and the theme configuration.</details></think>

---

I've created both posts. Let me verify the Hugo build works with these new files and check if the `series` taxonomy needs configuration:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet 2>&1 | head -30
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The build worked cleanly without any errors. Good - the posts are valid Hugo content. However, I did add a `series` parameter to the frontmatter that might not be configured in the theme. Let me check if the theme handles series or if I should remove that metadata.</details></think>

---

The Hugo build passed cleanly. Let me check if the series taxonomy is configured, and if not, I'll remove it from the frontmatter to keep things clean:

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs" • 6 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./content/posts/dotnet-to-go-modules.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-modules.md` | `*Next in the series: packages and imports—why Go's package system is nothing like namespaces, and how to stop your C# brain from making it harder than it needs to be.*` | L278 |
| `./content/posts/dotnet-to-go-toolchain.md` | `series = ["C# to Go"]` | L6 |
| `./content/posts/dotnet-to-go-toolchain.md` | `This is the first post in a series documenting that journey. Not a tutorial (the Go docs are excellent), but an honest account of where my C# muscle memory helps, where it hinders, and what makes Go feel genuinely different rather than just superficially unfamiliar.` | L11 |
| `./content/posts/dotnet-to-go-toolchain.md` | `That last one will come up a lot in this series. Go loves explicitness. Coming from C#, where we've spent years making things implicit (top-level statements, global usings, minimal APIs), it takes adjustment.` | L195 |
| `./themes/PaperMod/layouts/partials/templates/opengraph.html` | `\{{- range .GetTerms "series" \}}` | L64 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The PaperMod theme does have support for the series taxonomy, so the frontmatter is valid. However, looking at the theme being used (`stepdev` in hugo.toml), let me check if that theme also supports it, or if PaperMod is just a secondary theme included.

Actually looking back at the hugo.toml, the active theme is `stepdev`, not `PaperMod`. Let me check what that theme supports.</details></think>

---

The PaperMod theme has series support, but the active theme is `stepdev`. Let me check if that theme handles series, or if I should just use tags instead:

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "series" in "/Users/andycross/src/personal/mcp-blogs/themes/stepdev" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The stepdev theme doesn't have series support. The series frontmatter won't break anything, but it also won't do anything useful. I should remove it to keep the posts clean and consistent with the existing blog posts. Let me update both posts to remove the series line.</details></think>

---

The `stepdev` theme doesn't use the series taxonomy, so I'll remove that from the frontmatter to keep the posts clean:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "tooling", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md</summary>

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  draft = false
  tags = ["go", "dotnet", "dependencies", "csharp"]
- series = ["C# to Go"]
  +++
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, I've removed the series frontmatter. Let me verify the build still works and then present the results to the user.</details></think>

---

Let me verify the build still works and show you the final posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/*.md | tail -5
```

```
Build successful
-rw-r--r--  1 andycross  staff   6770 Dec  7 07:09 content/posts/invisible-models-ios-3d-debugging.md
-rw-r--r--  1 andycross  staff   7161 Dec  3 07:03 content/posts/seven-dollars-and-twenty-five-years.md
-rw-r--r--  1 andycross  staff   8701 Dec 28 20:16 content/posts/streaming-json-partial-parser.md
-rw-r--r--  1 andycross  staff  25890 Dec  2 09:41 content/posts/three-js-scenes-from-conversation.md
-rw-r--r--  1 andycross  staff  14586 Dec 25 08:53 content/posts/worklet-crashes-ios-force-quit.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Hmm, the new posts don't show in that listing. Let me check the full list to make sure they're there.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md</summary>

```bash
ls -la /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go*.md
```

```
-rw-r--r--  1 andycross  staff  9548 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff  8133 Dec 28 20:20 /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-toolchain.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The posts exist. The `-5` in my tail command just didn't show them because they alphabetically come before the ones shown. Let me show the user a preview of the blog locally.</details></think>

---

Both posts are created and the build passes. Here's what I've created:

## New Series: C# to Go

### Post 1: "You Know .NET, Now Meet the Go Toolchain"
`content/posts/dotnet-to-go-toolchain.md`

Covers:
- The single `go` command vs .NET's tooling ecosystem
- Where code lives (GOPATH history → modules)
- The build model differences (machine code vs IL/JIT)
- Cross-compilation
- Project structure comparison
- Early gotchas: case sensitivity, package declarations, file organisation

### Post 2: "Goodbye .csproj, Hello go.mod"  
`content/posts/dotnet-to-go-modules.md`

Covers:
- The `go.mod` file structure
- No central registry—dependencies are URLs
- Adding dependencies (`go get` vs `dotnet add package`)
- Minimum Version Selection vs NuGet's resolution algorithm
- The `go.sum` file
- Major versions as different modules
- Practical gotchas and honest comparison

Both posts follow the tone you specified:
- **UK English** throughout (organised, behaviour, colour)
- **Techie informal** voice with first-person plural
- **Fair to both languages**—no tribal nonsense
- **Starts with real problems**, not theory
- **Honest assessments** of what's better, worse, and just different
- **Tables for genuine comparisons**
- **Runnable code examples**

Want me to start the local Hugo server so you can preview them?

---

_**User (2025-12-28 20:16Z)**_

Nope, I want to start on the next ones:



Phase 2 Types & Data

Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create the next 5 posts in the series, covering Phase 2: Types & Data. Let me create all five posts following the same tone and style as the first two posts and the existing blog content.

The posts are:
1. Your Class Is Now a Struct (And That's Fine) — Reference vs value semantics, when you actually miss classes
2. Where Did My Properties Go? — Public/private via capitalisation, no getters/setters, embracing bare fields
3. Generics: Late to the Party — What Go 1.18+ gives you vs C#'s mature generics, and where you'll feel the gaps
4. The Million Dollar Mistake, Differently — Nullable reference types vs Go's nil, and why both languages got burned
5. No Enums? No Problem (Sort Of) — iota, const blocks, and faking it until you miss real enums

I'll write all five posts now with the same tone: UK English, techie informal, first person plural, honest about both languages, starts with real problems.</details></think>

---

I'll create all five posts for Phase 2: Types & Data. Let me write them all now.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-structs.md</summary>

**Chunk 1**
Lines added: 276, lines removed: 1

```diff
@@ -1,1 +1,276 @@
- 
+ +++
+ title = "Your Class Is Now a Struct (And That's Fine)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Here's something that'll feel wrong for about a week: Go doesn't have classes. Not "Go has classes but calls them something else"—it genuinely doesn't have them. No inheritance. No class hierarchies. No &#96;virtual&#96; or &#96;override&#96;. No &#96;protected&#96;.
+ 
+ If you've spent years designing C# class hierarchies, this feels like having a limb removed. Then you start writing Go code and realise... you don't actually miss it that much.
+ 
+ Let's dig into why.
+ 
+ ## The Basic Translation
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     public string Name { get; set; }
+     public string Email { get; set; }
+     public DateTime CreatedAt { get; set; }
+     
+     public User(string name, string email)
+     {
+         Name = name;
+         Email = email;
+         CreatedAt = DateTime.UtcNow;
+     }
+     
+     public string DisplayName() =&gt; $"{Name} &lt;{Email}&gt;";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     CreatedAt time.Time
+ }
+ 
+ func NewUser(name, email string) User {
+     return User{
+         Name:      name,
+         Email:     email,
+         CreatedAt: time.Now().UTC(),
+     }
+ }
+ 
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ A few things to notice:
+ 
+ 1. **No constructor syntax**—&#96;NewUser&#96; is just a function. By convention, Go uses &#96;NewX&#96; functions, but there's nothing special about them.
+ 2. **Methods are declared separately**—that &#96;func (u User)&#96; syntax attaches a method to the type.
+ 3. **No access modifiers**—capitalisation controls visibility (covered in the next post).
+ 4. **Fields are just fields**—no properties, no getters/setters.
+ 
+ ## Value Semantics by Default
+ 
+ Here's the big one. In C#, classes are reference types. When you pass a &#96;User&#96; to a method, you're passing a reference. Modifications affect the original.
+ 
+ &#96;&#96;&#96;csharp
+ void UpdateEmail(User user)
+ {
+     user.Email = "new@example.com";  // modifies the original
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, structs are value types by default. Pass a struct, you're passing a copy.
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u User) {
+     u.Email = "new@example.com"  // modifies the copy, original unchanged
+ }
+ &#96;&#96;&#96;
+ 
+ If you want reference semantics, you use pointers explicitly:
+ 
+ &#96;&#96;&#96;go
+ func UpdateEmail(u *User) {
+     u.Email = "new@example.com"  // modifies the original via pointer
+ }
+ &#96;&#96;&#96;
+ 
+ This explicitness is jarring at first. In C#, the type itself determines whether you get value or reference semantics (&#96;struct&#96; vs &#96;class&#96;). In Go, the *calling convention* determines it. Same type, different behaviour depending on whether you use &#96;User&#96; or &#96;*User&#96;.
+ 
+ ### When to Use Pointers
+ 
+ The rule of thumb:
+ 
+ | Scenario | Use |
+ |----------|-----|
+ | Method modifies the receiver | &#96;*User&#96; (pointer receiver) |
+ | Struct is large | &#96;*User&#96; (avoid copy overhead) |
+ | You need nil to mean "absent" | &#96;*User&#96; (pointers can be nil) |
+ | Small, immutable data | &#96;User&#96; (value) |
+ | You want copy-on-pass safety | &#96;User&#96; (value) |
+ 
+ In practice, most methods use pointer receivers. It's more consistent, and you don't have to think about whether each method modifies state.
+ 
+ &#96;&#96;&#96;go
+ // Pointer receiver - conventional for most methods
+ func (u *User) UpdateEmail(email string) {
+     u.Email = email
+ }
+ 
+ // Value receiver - acceptable for pure getters on small structs
+ func (u User) DisplayName() string {
+     return fmt.Sprintf("%s &lt;%s&gt;", u.Name, u.Email)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Composition Over Inheritance
+ 
+ Go doesn't have inheritance. Full stop. No &#96;class Admin : User&#96;. No &#96;protected&#96; members. No &#96;virtual&#96; methods.
+ 
+ Instead, Go has embedding—a form of composition that feels almost like inheritance but isn't.
+ 
+ &#96;&#96;&#96;go
+ type Person struct {
+     Name string
+     Age  int
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ type Employee struct {
+     Person          // embedded - not a field name, just the type
+     EmployeeID string
+     Department string
+ }
+ &#96;&#96;&#96;
+ 
+ Now &#96;Employee&#96; has all of &#96;Person&#96;'s fields and methods:
+ 
+ &#96;&#96;&#96;go
+ emp := Employee{
+     Person:     Person{Name: "Alice", Age: 30},
+     EmployeeID: "E123",
+     Department: "Engineering",
+ }
+ 
+ fmt.Println(emp.Name)    // "Alice" - promoted from Person
+ fmt.Println(emp.Greet()) // "Hello, I'm Alice" - method promoted too
+ &#96;&#96;&#96;
+ 
+ This *looks* like inheritance, but it's not:
+ 
+ - No polymorphism—you can't pass an &#96;Employee&#96; where a &#96;Person&#96; is expected
+ - No &#96;override&#96;—if &#96;Employee&#96; defines its own &#96;Greet()&#96;, it shadows &#96;Person.Greet()&#96;
+ - The embedded type is still accessible—&#96;emp.Person.Name&#96; works
+ 
+ ### When You'll Miss Inheritance
+ 
+ Let's be honest: sometimes you'll miss it.
+ 
+ **Template Method Pattern**—In C#, you'd have a base class with a &#96;virtual&#96; method that subclasses override. Go has no direct equivalent. You use interfaces and composition instead, which works but feels more verbose.
+ 
+ **Protected Members**—There's no "visible to derived types" concept. Everything is either exported (public) or unexported (package-private). For library design, this can be limiting.
+ 
+ **Deep Hierarchies**—If your C# design has &#96;Animal -&gt; Mammal -&gt; Dog -&gt; Labrador&#96;, Go will make you rethink that structure entirely. Usually for the better, but the rethinking takes effort.
+ 
+ ## Interfaces Are Implicit
+ 
+ Here's where Go gets genuinely interesting. Interfaces are satisfied implicitly—no &#96;implements&#96; keyword.
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public interface IGreeter
+ {
+     string Greet();
+ }
+ 
+ public class Person : IGreeter  // explicit implementation
+ {
+     public string Name { get; set; }
+     public string Greet() =&gt; $"Hello, I'm {Name}";
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Greeter interface {
+     Greet() string
+ }
+ 
+ type Person struct {
+     Name string
+ }
+ 
+ func (p Person) Greet() string {
+     return fmt.Sprintf("Hello, I'm %s", p.Name)
+ }
+ 
+ // Person now implements Greeter - no declaration needed
+ &#96;&#96;&#96;
+ 
+ If a type has the methods an interface requires, it implements that interface. Period. No ceremony.
+ 
+ This has profound implications:
+ 
+ 1. **You can define interfaces after the fact**—create an interface that existing types already satisfy
+ 2. **Small interfaces are encouraged**—the standard library is full of one-method interfaces
+ 3. **Testing is trivial**—any type with the right methods can be substituted
+ 
+ The &#96;io.Reader&#96; interface is the canonical example:
+ 
+ &#96;&#96;&#96;go
+ type Reader interface {
+     Read(p []byte) (n int, err error)
+ }
+ &#96;&#96;&#96;
+ 
+ One method. But files, network connections, byte buffers, HTTP response bodies—they all implement it. Polymorphism without inheritance.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Classes | Go Structs |
+ |--------|-----------|------------|
+ | Reference/value | Reference by default | Value by default |
+ | Inheritance | Full class inheritance | Embedding (composition) |
+ | Interface implementation | Explicit (&#96;implements&#96;) | Implicit (duck typing) |
+ | Constructors | Special syntax | Convention (&#96;NewX&#96; functions) |
+ | Access modifiers | &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96; | Exported (capital) or unexported |
+ | Polymorphism | Inheritance + interfaces | Interfaces only |
+ | Method declaration | Inside class body | Separate, attached to type |
+ 
+ ## What I Actually Miss
+ 
+ After a few months, here's my honest assessment:
+ 
+ **Don't miss at all:**
+ - Complex inheritance hierarchies (they were usually a mistake anyway)
+ - The &#96;virtual&#96;/&#96;override&#96; dance
+ - Explicit interface implementation for conflicts
+ 
+ **Sometimes miss:**
+ - &#96;protected&#96; for carefully designed extension points
+ - Abstract classes with partial implementations
+ - The template method pattern (can be done in Go, just clunkier)
+ 
+ **Actively prefer Go's approach:**
+ - Implicit interface satisfaction
+ - Explicit value vs reference choice at call site
+ - Composition via embedding
+ - Small, focused interfaces
+ 
+ The shift from "design your class hierarchy upfront" to "compose small pieces and let interfaces emerge" takes adjustment. But it tends to produce simpler code.
+ 
+ ## The Practical Bit
+ 
+ If you're converting C# code to Go, here's the process I use:
+ 
+ 1. **Start with structs for data**—no methods yet, just fields
+ 2. **Add methods as needed**—use pointer receivers by default
+ 3. **Extract interfaces late**—when you need polymorphism, create the smallest interface that works
+ 4. **Embed for code reuse**—not "inheritance", just "I want those fields and methods too"
+ 5. **Resist the urge to build hierarchies**—if you're thinking "base class", stop and reconsider
+ 
+ The code ends up flatter. More types, shallower relationships. It's different, not worse.
+ 
+ ---
+ 
+ *Next up: visibility and the death of properties—why Go uses capitalisation instead of access modifiers, and why you'll stop missing getters and setters faster than you'd expect.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-visibility.md</summary>

**Chunk 1**
Lines added: 299, lines removed: 1

```diff
@@ -1,1 +1,299 @@
- 
+ +++
+ title = "Where Did My Properties Go?"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "types", "csharp"]
+ +++
+ 
+ Coming from C#, one of the first things you'll notice is that Go structs look... naked. Where are the &#96;{ get; set; }&#96; blocks? Where's &#96;private&#96; and &#96;public&#96;? How do you encapsulate anything?
+ 
+ The answer involves capitalisation, a complete absence of properties, and a philosophy that might make you uncomfortable before it makes you productive.
+ 
+ ## Visibility via Capitalisation
+ 
+ Go has exactly two visibility levels:
+ 
+ - **Exported** (capital first letter): visible outside the package
+ - **Unexported** (lowercase first letter): visible only within the package
+ 
+ That's it. No &#96;public&#96;, &#96;private&#96;, &#96;protected&#96;, &#96;internal&#96;. Just case.
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ type User struct {
+     Name  string    // Exported - other packages can access
+     Email string    // Exported
+     hash  string    // unexported - only this package can access
+ }
+ 
+ func (u *User) SetPassword(password string) {
+     u.hash = hashPassword(password)  // can access hash internally
+ }
+ 
+ func hashPassword(p string) string {  // unexported function
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ From another package:
+ 
+ &#96;&#96;&#96;go
+ package main
+ 
+ import "myapp/user"
+ 
+ func main() {
+     u := user.User{Name: "Alice", Email: "alice@example.com"}
+     u.SetPassword("secret")  // works - SetPassword is exported
+     
+     // u.hash = "something"  // won't compile - hash is unexported
+ }
+ &#96;&#96;&#96;
+ 
+ ### The Mental Adjustment
+ 
+ In C#, visibility is per-member and you have fine-grained control. In Go, the package is the unit of encapsulation.
+ 
+ | C# | Go Equivalent |
+ |----|---------------|
+ | &#96;public&#96; | Capitalised name |
+ | &#96;private&#96; | Lowercase name |
+ | &#96;protected&#96; | Doesn't exist |
+ | &#96;internal&#96; | Lowercase (package = assembly, roughly) |
+ | &#96;private protected&#96; | Doesn't exist |
+ 
+ The lack of &#96;protected&#96; is the big one. There's no "visible to derived types" because there are no derived types. Embedding doesn't grant special access—embedded types can only access their own unexported members.
+ 
+ ## No Properties, Just Fields
+ 
+ Here's the controversial bit. Go doesn't have properties. No getters. No setters. Just fields.
+ 
+ In C#, you'd write:
+ 
+ &#96;&#96;&#96;csharp
+ public class User
+ {
+     private string _email;
+     
+     public string Email
+     {
+         get =&gt; _email;
+         set
+         {
+             ValidateEmail(value);
+             _email = value.ToLowerInvariant();
+         }
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the idiomatic approach is... don't do that:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Email string
+ }
+ &#96;&#96;&#96;
+ 
+ Wait, what about validation? What about normalisation?
+ 
+ Go's answer: if you need to do something when a value changes, make a method for it:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     email string  // unexported
+ }
+ 
+ func (u *User) Email() string {
+     return u.email
+ }
+ 
+ func (u *User) SetEmail(email string) error {
+     if !isValidEmail(email) {
+         return errors.New("invalid email")
+     }
+     u.email = strings.ToLower(email)
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is more verbose than C# properties. Undeniably. You write more code.
+ 
+ But here's the thing: now the call site makes it obvious that something's happening.
+ 
+ &#96;&#96;&#96;go
+ // Caller knows this might fail
+ err := user.SetEmail("alice@example.com")
+ 
+ // vs a property that silently transforms or might panic
+ user.Email = "alice@example.com"  // what does this actually do?
+ &#96;&#96;&#96;
+ 
+ ### When to Use Bare Fields
+ 
+ The Go community's guidance is: **export fields when they're truly just data**.
+ 
+ &#96;&#96;&#96;go
+ // Config is just data, exported fields are fine
+ type Config struct {
+     Host     string
+     Port     int
+     Timeout  time.Duration
+     Debug    bool
+ }
+ 
+ // User has invariants to maintain, unexport fields + methods
+ type User struct {
+     id        int64
+     email     string
+     createdAt time.Time
+ }
+ &#96;&#96;&#96;
+ 
+ This feels wrong to C# developers who've been taught that bare fields are always bad. But Go's standard library is full of exported fields:
+ 
+ &#96;&#96;&#96;go
+ // From net/http
+ type Request struct {
+     Method string
+     URL    *url.URL
+     Header Header
+     Body   io.ReadCloser
+     // ... many more exported fields
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;http.Request&#96; struct has exported fields because that's what makes sense. You read and modify them directly. No ceremony.
+ 
+ ## The "Getter/Setter" Convention
+ 
+ When you do need accessor methods, Go has a naming convention that'll trip you up:
+ 
+ &#96;&#96;&#96;go
+ // C# instinct - WRONG in Go
+ func (u *User) GetEmail() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ 
+ // Go convention - CORRECT
+ func (u *User) Email() string { return u.email }
+ func (u *User) SetEmail(e string) { u.email = e }
+ &#96;&#96;&#96;
+ 
+ Notice: the getter is just &#96;Email()&#96;, not &#96;GetEmail()&#96;. The setter keeps the &#96;Set&#96; prefix.
+ 
+ This feels inconsistent until you see it in use:
+ 
+ &#96;&#96;&#96;go
+ email := user.Email()          // reads like accessing a value
+ user.SetEmail("new@example.com")  // reads like an action
+ &#96;&#96;&#96;
+ 
+ The asymmetry is intentional. Getting a value should feel like accessing a value. Setting a value should look like you're doing something.
+ 
+ ## The Package as Encapsulation Boundary
+ 
+ Here's where Go's model actually shines: the package is the natural unit of encapsulation.
+ 
+ In C#, you often have one class per file, and you think about encapsulation at the class level. You might have &#96;internal&#96; methods that are really just for one other class in the same assembly.
+ 
+ In Go, all files in a package share the same namespace. Unexported identifiers are visible across all files in the package:
+ 
+ &#96;&#96;&#96;go
+ // user/user.go
+ package user
+ 
+ type User struct {
+     email string
+ }
+ 
+ // user/validation.go  
+ package user
+ 
+ func validateUser(u *User) error {
+     // Can access u.email - same package
+     if u.email == "" {
+         return errors.New("email required")
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ This encourages small, focused packages where the implementation details can be shared freely within the package boundary, but the public API is carefully controlled.
+ 
+ ### The &#96;internal&#96; Directory
+ 
+ Go has one more visibility mechanism: the &#96;internal&#96; directory convention.
+ 
+ &#96;&#96;&#96;
+ myproject/
+ ├── internal/
+ │   └── auth/
+ │       └── token.go    // only importable by myproject and its children
+ ├── api/
+ │   └── handler.go      // can import internal/auth
+ └── main.go             // can import internal/auth
+ &#96;&#96;&#96;
+ 
+ Packages under &#96;internal/&#96; can only be imported by packages rooted at the parent of &#96;internal&#96;. This gives you "internal to this module" visibility without language keywords.
+ 
+ ## Struct Tags
+ 
+ One thing C# attributes do that Go handles differently: metadata on fields. Go uses struct tags:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     ID        int64     &#96;json:"id" db:"user_id"&#96;
+     Email     string    &#96;json:"email" db:"email" validate:"required,email"&#96;
+     CreatedAt time.Time &#96;json:"created_at" db:"created_at"&#96;
+ }
+ &#96;&#96;&#96;
+ 
+ These are just strings—the runtime and libraries parse them by convention. The &#96;json&#96; package looks for &#96;json:&#96; tags. Database libraries look for &#96;db:&#96; tags. Validation libraries look for &#96;validate:&#96; tags.
+ 
+ It's less type-safe than C# attributes (no compile-time checking of tag names), but it's simple and works.
+ 
+ ## The Honest Take
+ 
+ After months of Go, here's where I've landed:
+ 
+ **Things I like better than C#:**
+ 
+ - **Simplicity of the model**. Two visibility levels, no exceptions.
+ - **Package-level encapsulation**. Encourages cohesive packages.
+ - **Explicit methods over magic properties**. Call sites are clear about what's happening.
+ - **The &#96;internal&#96; convention**. Solves the "internal to this module" case elegantly.
+ 
+ **Things I miss from C#:**
+ 
+ - **&#96;protected&#96; for library extension**. Sometimes you want "derived types only" access.
+ - **Computed properties**. &#96;user.FullName&#96; is nicer than &#96;user.FullName()&#96; when it's genuinely just a computed value.
+ - **Init-only setters**. Go has no equivalent to &#96;init&#96; for construction-time-only setting.
+ - **Attributes**. Struct tags work but aren't type-safe.
+ 
+ **Things that are just different:**
+ 
+ - **Capitalisation visibility**. Weird for a week, then invisible.
+ - **No &#96;get&#96;/&#96;set&#96; syntax**. More typing, but more explicit.
+ - **Fields vs properties**. Go trusts you to know when bare fields are appropriate.
+ 
+ ## Practical Advice
+ 
+ 1. **Start with exported fields for DTOs**. Structs that just carry data (configs, API responses, database rows) don't need method accessors.
+ 
+ 2. **Use unexported fields when invariants matter**. If setting a value could break something, make it unexported and provide methods.
+ 
+ 3. **Name getters without &#96;Get&#96;**. It's &#96;Email()&#96;, not &#96;GetEmail()&#96;.
+ 
+ 4. **Return errors from setters that validate**. Don't panic, don't silently fail.
+ 
+ 5. **Keep packages small and focused**. The package boundary is your encapsulation tool—make packages that are cohesive enough that sharing unexported identifiers makes sense.
+ 
+ 6. **Use &#96;internal/&#96; for module-private packages**. Better than making everything unexported in a shared package.
+ 
+ The shift from "everything should have properties" to "fields are fine, methods when needed" takes time. But once you stop fighting it, Go code ends up pleasantly straightforward.
+ 
+ ---
+ 
+ *Next up: generics in Go—what we got in Go 1.18, where the gaps are, and why you'll need to adjust your expectations if you're used to C#'s mature generics.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-generics.md</summary>

**Chunk 1**
Lines added: 331, lines removed: 1

```diff
@@ -1,1 +1,331 @@
- 
+ +++
+ title = "Generics: Late to the Party"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "generics", "csharp"]
+ +++
+ 
+ Go shipped generics in version 1.18 (March 2022). C# has had them since 2.0 (November 2005). That's a seventeen-year head start, and it shows.
+ 
+ If you're coming from C# expecting the same power and flexibility, you'll be disappointed. Go's generics are deliberately constrained—they solve the common cases but won't let you build the same abstractions you're used to.
+ 
+ Let's look at what we've got, what's missing, and whether that matters.
+ 
+ ## The Basic Syntax
+ 
+ A generic function in Go:
+ 
+ &#96;&#96;&#96;go
+ func Map[T, U any](items []T, f func(T) U) []U {
+     result := make([]U, len(items))
+     for i, item := range items {
+         result[i] = f(item)
+     }
+     return result
+ }
+ 
+ // Usage
+ numbers := []int{1, 2, 3, 4}
+ squared := Map(numbers, func(n int) int { return n * n })
+ &#96;&#96;&#96;
+ 
+ Compare to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public static IEnumerable&lt;U&gt; Map&lt;T, U&gt;(IEnumerable&lt;T&gt; items, Func&lt;T, U&gt; f)
+ {
+     foreach (var item in items)
+         yield return f(item);
+ }
+ 
+ // Usage  
+ var numbers = new[] { 1, 2, 3, 4 };
+ var squared = Map(numbers, n =&gt; n * n);
+ &#96;&#96;&#96;
+ 
+ The syntax is different but the concept is familiar. Type parameters go in square brackets in Go (&#96;[T, U any]&#96;) rather than angle brackets (&#96;&lt;T, U&gt;&#96;). The &#96;any&#96; is a constraint—more on that shortly.
+ 
+ ## Constraints
+ 
+ Here's where Go's approach diverges. In C#, you constrain type parameters with &#96;where&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ public T Max&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;
+ {
+     return a.CompareTo(b) &gt; 0 ? a : b;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, constraints are interfaces:
+ 
+ &#96;&#96;&#96;go
+ func Max[T cmp.Ordered](a, b T) T {
+     if a &gt; b {
+         return a
+     }
+     return b
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;cmp.Ordered&#96; constraint (from the standard library) allows the &#96;&gt;&#96; operator. Without it, Go wouldn't know that &#96;T&#96; supports comparison.
+ 
+ ### Built-in Constraints
+ 
+ Go provides some standard constraints in the &#96;constraints&#96; and &#96;cmp&#96; packages:
+ 
+ | Constraint | What it allows |
+ |-----------|----------------|
+ | &#96;any&#96; | Any type (alias for &#96;interface{}&#96;) |
+ | &#96;comparable&#96; | Types that support &#96;==&#96; and &#96;!=&#96; |
+ | &#96;cmp.Ordered&#96; | Types that support &#96;&lt;&#96;, &#96;&gt;&#96;, &#96;&lt;=&#96;, &#96;&gt;=&#96; |
+ | &#96;constraints.Integer&#96; | All integer types |
+ | &#96;constraints.Float&#96; | All float types |
+ | &#96;constraints.Signed&#96; | Signed integers |
+ | &#96;constraints.Unsigned&#96; | Unsigned integers |
+ 
+ ### Custom Constraints
+ 
+ You can define your own constraints as interfaces:
+ 
+ &#96;&#96;&#96;go
+ type Number interface {
+     ~int | ~int64 | ~float64
+ }
+ 
+ func Sum[T Number](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ That &#96;~int&#96; syntax means "any type whose underlying type is int". This lets you include type aliases and defined types, not just the primitive itself.
+ 
+ ## Generic Types
+ 
+ Generic structs work as you'd expect:
+ 
+ &#96;&#96;&#96;go
+ type Stack[T any] struct {
+     items []T
+ }
+ 
+ func (s *Stack[T]) Push(item T) {
+     s.items = append(s.items, item)
+ }
+ 
+ func (s *Stack[T]) Pop() (T, bool) {
+     if len(s.items) == 0 {
+         var zero T
+         return zero, false
+     }
+     item := s.items[len(s.items)-1]
+     s.items = s.items[:len(s.items)-1]
+     return item, true
+ }
+ 
+ // Usage
+ stack := &amp;Stack[string]{}
+ stack.Push("hello")
+ value, ok := stack.Pop()
+ &#96;&#96;&#96;
+ 
+ ## Where the Gaps Hurt
+ 
+ Right, here's the honest bit. Go's generics are limited in ways that'll frustrate you coming from C#.
+ 
+ ### No Generic Methods on Non-Generic Types
+ 
+ In C#, you can do this:
+ 
+ &#96;&#96;&#96;csharp
+ public class Converter
+ {
+     public T Convert&lt;T&gt;(string value) { ... }
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, you can't add a generic method to a non-generic type. This doesn't compile:
+ 
+ &#96;&#96;&#96;go
+ type Converter struct{}
+ 
+ // ERROR: method must have no type parameters
+ func (c Converter) Convert[T any](value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ You have to use a generic function instead:
+ 
+ &#96;&#96;&#96;go
+ func Convert[T any](c Converter, value string) T { ... }
+ &#96;&#96;&#96;
+ 
+ It works, but it's clunkier and doesn't chain as nicely.
+ 
+ ### No Specialisation
+ 
+ C# lets you specialise behaviour based on type arguments (with runtime checks or partial specialisation). Go doesn't. You can't do:
+ 
+ &#96;&#96;&#96;go
+ func Process[T any](item T) {
+     // Can't check "if T is string, do this"
+     // Can't have different implementations for different T
+ }
+ &#96;&#96;&#96;
+ 
+ Everything must work uniformly for all types that satisfy the constraint.
+ 
+ ### No Variance
+ 
+ C# has covariance (&#96;out T&#96;) and contravariance (&#96;in T&#96;) for generic interfaces. Go has neither. A &#96;Stack[Dog]&#96; is not a &#96;Stack[Animal]&#96;, even if &#96;Dog&#96; implements &#96;Animal&#96;. Ever.
+ 
+ ### No Arithmetic Constraints (Sort Of)
+ 
+ Want to write a generic sum function? You need to constrain to types that support &#96;+&#96;:
+ 
+ &#96;&#96;&#96;go
+ func Sum[T constraints.Integer | constraints.Float](items []T) T {
+     var total T
+     for _, item := range items {
+         total += item
+     }
+     return total
+ }
+ &#96;&#96;&#96;
+ 
+ This works, but you can't easily extend it to custom numeric types. The constraint system is based on underlying types, not operators.
+ 
+ ### No Default Type Arguments
+ 
+ C# has:
+ 
+ &#96;&#96;&#96;csharp
+ public class Cache&lt;TKey, TValue, TSerializer = JsonSerializer&gt; { }
+ &#96;&#96;&#96;
+ 
+ Go doesn't. Every type parameter must be specified at use sites (though type inference helps for functions).
+ 
+ ## The Standard Library's Generics
+ 
+ Go 1.21+ added generic functions to the standard library. These are genuinely useful:
+ 
+ &#96;&#96;&#96;go
+ import (
+     "maps"
+     "slices"
+ )
+ 
+ // Slices
+ numbers := []int{3, 1, 4, 1, 5, 9}
+ slices.Sort(numbers)
+ found := slices.Contains(numbers, 4)
+ maxVal := slices.Max(numbers)
+ 
+ // Maps  
+ m := map[string]int{"a": 1, "b": 2}
+ keys := maps.Keys(m)    // iterator over keys
+ values := maps.Values(m) // iterator over values
+ maps.Clone(m)           // shallow copy
+ &#96;&#96;&#96;
+ 
+ Before generics, you'd write these loops by hand every time. Now they're type-safe and reusable.
+ 
+ ## When You'll Feel the Gaps
+ 
+ **Building Fluent APIs**
+ 
+ In C#, you might build a fluent configuration API with generic methods:
+ 
+ &#96;&#96;&#96;csharp
+ builder
+     .WithOption&lt;ConnectionOptions&gt;(opts =&gt; opts.Timeout = 30)
+     .WithOption&lt;RetryOptions&gt;(opts =&gt; opts.MaxRetries = 3)
+     .Build();
+ &#96;&#96;&#96;
+ 
+ This pattern is harder in Go because you can't have generic methods. You'd need a different approach—probably top-level functions or a less fluent API.
+ 
+ **Repository Patterns**
+ 
+ The classic &#96;IRepository&lt;T&gt;&#96; with &#96;Find&lt;TKey&gt;&#96; is awkward:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work - can't have generic method
+ type Repository[T any] interface {
+     Find[K comparable](id K) (T, error)  // ERROR
+ }
+ 
+ // You'd need this instead
+ type Repository[T any, K comparable] interface {
+     Find(id K) (T, error)
+ }
+ &#96;&#96;&#96;
+ 
+ Two type parameters instead of one, threaded through everything.
+ 
+ **LINQ-style Operations**
+ 
+ C# LINQ chains beautifully with generic extension methods:
+ 
+ &#96;&#96;&#96;csharp
+ items.Where(x =&gt; x.Active).Select(x =&gt; x.Name).OrderBy(x =&gt; x).ToList();
+ &#96;&#96;&#96;
+ 
+ Go has no extension methods. You'd write:
+ 
+ &#96;&#96;&#96;go
+ result := slices.Sorted(
+     slices.Collect(
+         Map(
+             Filter(items, func(x Item) bool { return x.Active }),
+             func(x Item) string { return x.Name },
+         ),
+     ),
+ )
+ &#96;&#96;&#96;
+ 
+ Functional, but not as elegant.
+ 
+ ## The Practical Advice
+ 
+ After working with Go's generics, here's how I use them:
+ 
+ **Do use generics for:**
+ - Data structures (stacks, queues, trees, caches)
+ - Collection utilities (map, filter, reduce)
+ - Type-safe wrappers around &#96;interface{}&#96;
+ - Eliminating repetitive code across similar types
+ 
+ **Don't use generics for:**
+ - Everything. Go's non-generic code is often clearer.
+ - Patterns that require generic methods (rethink the design)
+ - Complex type relationships (the constraint syntax gets unwieldy)
+ 
+ **Accept these limitations:**
+ - Write more concrete types, fewer abstractions
+ - Use interfaces for polymorphism, generics for type safety
+ - Sometimes duplicate code is clearer than a generic contortion
+ 
+ ## The Honest Assessment
+ 
+ | Aspect | C# Generics | Go Generics |
+ |--------|------------|-------------|
+ | Maturity | 20 years | 3 years |
+ | Generic methods | Yes | Only on generic types |
+ | Variance | Full (in/out) | None |
+ | Constraints | Rich (interfaces, new(), class, struct) | Interfaces only |
+ | Specialisation | Partial (with runtime checks) | None |
+ | Standard library | Extensive | Growing |
+ 
+ Go's generics are *good enough* for most real-world needs. They eliminate the pre-1.18 pain of &#96;interface{}&#96; everywhere or code generation. But they're not trying to match C#'s power.
+ 
+ The Go team explicitly chose to ship a simpler system first, with room to expand. Whether the gaps will be filled or the community will adapt around them remains to be seen.
+ 
+ For now? Lower your expectations, use generics where they help, and don't twist yourself into knots trying to replicate C# patterns that don't translate well.
+ 
+ ---
+ 
+ *Next up: nil in Go versus nullable reference types in C#—two different approaches to the billion dollar mistake, and why both languages still get caught out.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-nil.md</summary>

**Chunk 1**
Lines added: 312, lines removed: 1

```diff
@@ -1,1 +1,312 @@
- 
+ +++
+ title = "The Million Dollar Mistake, Differently"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "nil", "csharp"]
+ +++
+ 
+ Tony Hoare called null references his "billion dollar mistake." Both C# and Go inherited some form of this mistake, but they've evolved to handle it differently. Neither solution is perfect.
+ 
+ If you're coming from C# 8+ with nullable reference types enabled, Go's approach will feel like stepping backwards. And in some ways, it is. But there's nuance here.
+ 
+ ## The C# Journey
+ 
+ C# started with null everywhere. Any reference type could be null, always. This gave us decades of &#96;NullReferenceException&#96; at runtime.
+ 
+ Then came nullable reference types (NRT) in C# 8:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ 
+ public class User
+ {
+     public string Name { get; set; }        // Non-nullable - compiler warns if null
+     public string? MiddleName { get; set; } // Nullable - explicitly marked
+ }
+ 
+ public void Process(User user)
+ {
+     Console.WriteLine(user.Name.Length);    // Safe - compiler knows it's not null
+     Console.WriteLine(user.MiddleName.Length); // Warning! Might be null
+     
+     // Must check first
+     if (user.MiddleName != null)
+     {
+         Console.WriteLine(user.MiddleName.Length); // Now safe
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler tracks nullability and warns you. It's not perfect—it's still a warning system, not a guarantee—but it catches loads of bugs at compile time.
+ 
+ ## Go's Approach: Everything Is Potentially Nil (But Different)
+ 
+ Go has &#96;nil&#96;, and it works differently depending on the type. Here's the landscape:
+ 
+ | Type | Can be nil? | Zero value |
+ |------|-------------|------------|
+ | Pointers (&#96;*T&#96;) | Yes | &#96;nil&#96; |
+ | Slices | Yes | &#96;nil&#96; (but usable!) |
+ | Maps | Yes | &#96;nil&#96; (but NOT usable for writes) |
+ | Channels | Yes | &#96;nil&#96; |
+ | Interfaces | Yes | &#96;nil&#96; |
+ | Functions | Yes | &#96;nil&#96; |
+ | Structs | No | Zero struct |
+ | Primitives | No | 0, "", false, etc. |
+ 
+ Let's dig into the weird bits.
+ 
+ ### Nil Slices Are Fine
+ 
+ This is the first surprise. A nil slice is usable:
+ 
+ &#96;&#96;&#96;go
+ var s []int    // nil slice
+ len(s)         // 0 - works fine
+ cap(s)         // 0 - works fine
+ s = append(s, 1, 2, 3)  // works fine! Now s is [1, 2, 3]
+ 
+ for _, v := range s { } // works even when nil (iterates zero times)
+ &#96;&#96;&#96;
+ 
+ A nil slice isn't "no slice"—it's an empty slice with no backing array. Most operations work. This is intentional and idiomatic.
+ 
+ ### Nil Maps Are NOT Fine
+ 
+ But a nil map will bite you:
+ 
+ &#96;&#96;&#96;go
+ var m map[string]int  // nil map
+ 
+ v := m["key"]         // works! Returns zero value (0)
+ _, ok := m["key"]     // works! ok is false
+ 
+ m["key"] = 1          // PANIC: assignment to entry in nil map
+ &#96;&#96;&#96;
+ 
+ Reading from a nil map works (returns zero values). Writing to a nil map panics. This inconsistency catches everyone at least once.
+ 
+ Always initialise maps:
+ 
+ &#96;&#96;&#96;go
+ m := make(map[string]int)
+ // or
+ m := map[string]int{}
+ &#96;&#96;&#96;
+ 
+ ### The Interface Nil Trap
+ 
+ This one is genuinely confusing. An interface can be nil in two ways:
+ 
+ &#96;&#96;&#96;go
+ type Writer interface {
+     Write([]byte) (int, error)
+ }
+ 
+ var w Writer = nil     // nil interface - both type and value are nil
+ fmt.Println(w == nil)  // true
+ 
+ var buf *bytes.Buffer = nil  // nil pointer
+ var w2 Writer = buf          // interface with nil concrete value
+ fmt.Println(w2 == nil)       // FALSE!
+ &#96;&#96;&#96;
+ 
+ Wait, what?
+ 
+ An interface value is nil only if both its type and value are nil. If you assign a nil pointer to an interface, the interface has a type (the pointer type) but a nil value. It's not a nil interface.
+ 
+ This causes bugs like:
+ 
+ &#96;&#96;&#96;go
+ func process(w Writer) {
+     if w != nil {
+         w.Write(data)  // might panic! w could be non-nil interface with nil value
+     }
+ }
+ 
+ var buf *bytes.Buffer = nil
+ process(buf)  // passes the nil check, then panics
+ &#96;&#96;&#96;
+ 
+ The fix is to either check the concrete type too, or (better) never assign nil pointers to interfaces.
+ 
+ ## Zero Values as Nullability
+ 
+ Go's approach to handling "absent" values is the zero value:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name      string
+     Email     string
+     Age       int
+     CreatedAt time.Time
+ }
+ 
+ var u User
+ // u is now {Name: "", Email: "", Age: 0, CreatedAt: zero time}
+ &#96;&#96;&#96;
+ 
+ Every field has a defined zero value. There's no "unset" state—just "set to zero."
+ 
+ This works well for many cases:
+ 
+ &#96;&#96;&#96;go
+ // Empty string often means "not set"
+ if user.Email == "" {
+     // No email provided
+ }
+ 
+ // But what if 0 is a valid age?
+ if user.Age == 0 {
+     // Is this "not set" or "newborn"?
+ }
+ &#96;&#96;&#96;
+ 
+ When you need to distinguish "not set" from "zero value," you have options:
+ 
+ ### Option 1: Pointers
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name  string
+     Age   *int  // nil means not set, *int value means set
+ }
+ 
+ func (u User) HasAge() bool {
+     return u.Age != nil
+ }
+ &#96;&#96;&#96;
+ 
+ This is the closest to C#'s &#96;int?&#96;. But you pay the pointer indirection cost and the nil-checking overhead.
+ 
+ ### Option 2: The "ok" Pattern
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     name    string
+     nameSet bool
+ }
+ 
+ func (u User) Name() (string, bool) {
+     return u.name, u.nameSet
+ }
+ &#96;&#96;&#96;
+ 
+ Explicit, but verbose.
+ 
+ ### Option 3: Wrapper Types
+ 
+ &#96;&#96;&#96;go
+ import "database/sql"
+ 
+ type User struct {
+     Name sql.NullString
+     Age  sql.NullInt64
+ }
+ 
+ if user.Name.Valid {
+     fmt.Println(user.Name.String)
+ }
+ &#96;&#96;&#96;
+ 
+ The standard library has these for database interop. They're clunky but explicit.
+ 
+ ## Error Handling and Nil
+ 
+ Go's error handling interacts with nil constantly:
+ 
+ &#96;&#96;&#96;go
+ func LoadUser(id string) (*User, error) {
+     // ...
+ }
+ 
+ user, err := LoadUser("123")
+ if err != nil {
+     return nil, err
+ }
+ // Use user - we know it's not nil because no error
+ &#96;&#96;&#96;
+ 
+ The convention is: if &#96;err != nil&#96;, don't trust the other return values. If &#96;err == nil&#96;, the values should be valid.
+ 
+ But this is convention, not enforcement. Nothing stops you from writing:
+ 
+ &#96;&#96;&#96;go
+ return nil, nil  // No user, no error - bad practice!
+ &#96;&#96;&#96;
+ 
+ The compiler won't save you from this. Code review and convention do.
+ 
+ ## What I Miss from C#
+ 
+ **Compile-time nullability tracking.** C#'s NRT warns you when you dereference something that might be null. Go just lets you do it.
+ 
+ **The null-conditional operators.** &#96;user?.Profile?.Address?.City&#96; in C# is a single expression. In Go:
+ 
+ &#96;&#96;&#96;go
+ var city string
+ if user != nil &amp;&amp; user.Profile != nil &amp;&amp; user.Profile.Address != nil {
+     city = user.Profile.Address.City
+ }
+ &#96;&#96;&#96;
+ 
+ **Null-coalescing.** &#96;name ?? "Unknown"&#96; vs:
+ 
+ &#96;&#96;&#96;go
+ name := user.Name
+ if name == "" {
+     name = "Unknown"
+ }
+ &#96;&#96;&#96;
+ 
+ Go 1.22 added some helpers, but nothing as clean.
+ 
+ ## What Go Does Well
+ 
+ **Zero values are useful defaults.** A zero &#96;sync.Mutex&#96; works. A zero &#96;bytes.Buffer&#96; works. You don't need constructor ceremonies for basic types.
+ 
+ **No null reference exceptions.** You get panics on nil pointer dereference, but nil slices, nil channels (blocks forever), and nil maps (read) don't crash.
+ 
+ **Explicit pointer semantics.** When something can be nil, it's a pointer. Value types can't be nil. The type tells you what to expect.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# (with NRT) | Go |
+ |--------|---------------|-----|
+ | Compile-time null tracking | Yes (warnings) | No |
+ | Runtime null safety | NullReferenceException | Panic on nil dereference |
+ | Nullable value types | &#96;int?&#96; / &#96;Nullable&lt;T&gt;&#96; | &#96;*int&#96; or wrapper types |
+ | Zero values | Default to null/zero | Always well-defined |
+ | Null-conditional | &#96;?.&#96;, &#96;??&#96; | Manual checks |
+ | Interface nil trap | No equivalent problem | Yes - be careful |
+ 
+ ## Practical Advice
+ 
+ 1. **Initialise maps eagerly.** Don't leave them nil.
+ 
+ 2. **Never assign nil pointers to interfaces.** Return the zero interface instead:
+    &#96;&#96;&#96;go
+    // Bad
+    var buf *bytes.Buffer = nil
+    return buf
+    
+    // Good
+    return nil
+    &#96;&#96;&#96;
+ 
+ 3. **Use pointers for optional fields sparingly.** Often the zero value is fine for "not set."
+ 
+ 4. **Follow the error convention.** If returning an error, either return good values or nil values, not a mix.
+ 
+ 5. **Check nil before method calls on pointer receivers.** Go lets you call methods on nil receivers, which can work or panic depending on the implementation.
+ 
+ 6. **Accept that the compiler won't catch null dereferences.** Tests and careful coding are your only defence.
+ 
+ The lack of NRT-style static analysis is Go's weakest area compared to modern C#. Tools like &#96;staticcheck&#96; help, but they're not built into the language.
+ 
+ You'll write more nil checks. You'll occasionally miss one. That's the trade-off for Go's simplicity.
+ 
+ ---
+ 
+ *Next up: Go's approach to enums—const blocks, iota, and why you'll miss real enums more than you expected to.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-enums.md</summary>

**Chunk 1**
Lines added: 440, lines removed: 1

```diff
@@ -1,1 +1,440 @@
- 
+ +++
+ title = "No Enums? No Problem (Sort Of)"
+ date = "2024-12-29"
+ draft = false
+ tags = ["go", "dotnet", "enums", "csharp"]
+ +++
+ 
+ Go doesn't have enums. Not "Go has something enum-like"—it genuinely doesn't have a dedicated enum construct. What it has instead is constants, a clever auto-incrementing keyword called &#96;iota&#96;, and convention.
+ 
+ For simple cases, this works fine. For anything more complex, you'll miss C#'s enums more than you expect.
+ 
+ ## The Basic Pattern
+ 
+ In C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status
+ {
+     Pending,
+     Active,
+     Completed,
+     Cancelled
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Let's break this down:
+ 
+ 1. **Define a new type** based on an underlying type (usually &#96;int&#96;)
+ 2. **Create a const block** with values of that type
+ 3. **Use &#96;iota&#96;** to auto-increment values (0, 1, 2, 3...)
+ 
+ The &#96;iota&#96; keyword resets to 0 at each &#96;const&#96; block and increments for each line. It's surprisingly powerful:
+ 
+ &#96;&#96;&#96;go
+ // Skip zero (useful when zero should mean "unset")
+ const (
+     _ Status = iota  // 0 - discarded
+     StatusPending    // 1
+     StatusActive     // 2
+     StatusCompleted  // 3
+     StatusCancelled  // 4
+ )
+ 
+ // Bit flags
+ const (
+     FlagRead  = 1 &lt;&lt; iota  // 1
+     FlagWrite              // 2
+     FlagExec               // 4
+ )
+ 
+ // Custom formula
+ const (
+     KB = 1 &lt;&lt; (10 * (iota + 1))  // 1024
+     MB                           // 1048576
+     GB                           // 1073741824
+ )
+ &#96;&#96;&#96;
+ 
+ ## What's Missing
+ 
+ ### No Exhaustive Switch
+ 
+ In C#, if you switch on an enum and miss a case, the compiler can warn you:
+ 
+ &#96;&#96;&#96;csharp
+ Status status = GetStatus();
+ switch (status)
+ {
+     case Status.Pending: // ...
+     case Status.Active:  // ...
+     // Missing Completed and Cancelled - compiler warning (with newer analyzers)
+ }
+ &#96;&#96;&#96;
+ 
+ In Go, the compiler doesn't care:
+ 
+ &#96;&#96;&#96;go
+ var status Status = getStatus()
+ switch status {
+ case StatusPending:
+     // ...
+ case StatusActive:
+     // ...
+ // Missing cases? Compiler doesn't notice.
+ }
+ &#96;&#96;&#96;
+ 
+ You can use linters like &#96;exhaustive&#96; to catch this, but it's not built in.
+ 
+ ### No Name Resolution
+ 
+ C#'s enums have built-in stringification:
+ 
+ &#96;&#96;&#96;csharp
+ Status.Active.ToString()  // "Active"
+ Enum.Parse&lt;Status&gt;("Active")  // Status.Active
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just integers. No automatic name mapping:
+ 
+ &#96;&#96;&#96;go
+ fmt.Println(StatusActive)  // prints "1" - not useful
+ 
+ // You have to implement String() yourself
+ func (s Status) String() string {
+     switch s {
+     case StatusPending:
+         return "Pending"
+     case StatusActive:
+         return "Active"
+     case StatusCompleted:
+         return "Completed"
+     case StatusCancelled:
+         return "Cancelled"
+     default:
+         return fmt.Sprintf("Status(%d)", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This gets tedious. Tools like &#96;stringer&#96; can generate these methods, but it's an extra build step.
+ 
+ ### No Type Safety (Not Really)
+ 
+ C#'s enums prevent you from using arbitrary values:
+ 
+ &#96;&#96;&#96;csharp
+ Status s = (Status)999;  // Compiles but feels wrong
+ // Modern analyzers can warn about this
+ &#96;&#96;&#96;
+ 
+ Go's "enums" are just typed integers. Any int can be cast:
+ 
+ &#96;&#96;&#96;go
+ var s Status = 999  // Perfectly valid, no warning
+ &#96;&#96;&#96;
+ 
+ Nothing stops you from creating invalid values. The type gives you some protection (can't accidentally pass an &#96;int&#96; where &#96;Status&#96; is expected), but it's weak.
+ 
+ ### No Flag Enums with Utility Methods
+ 
+ C#'s &#96;[Flags]&#96; attribute gives you &#96;HasFlag&#96;:
+ 
+ &#96;&#96;&#96;csharp
+ [Flags]
+ public enum Permissions
+ {
+     None = 0,
+     Read = 1,
+     Write = 2,
+     Execute = 4
+ }
+ 
+ var perms = Permissions.Read | Permissions.Write;
+ perms.HasFlag(Permissions.Read)  // true
+ &#96;&#96;&#96;
+ 
+ Go gives you nothing. You do bit manipulation manually:
+ 
+ &#96;&#96;&#96;go
+ const (
+     PermissionNone = 0
+     PermissionRead = 1 &lt;&lt; iota
+     PermissionWrite
+     PermissionExecute
+ )
+ 
+ perms := PermissionRead | PermissionWrite
+ hasRead := perms&amp;PermissionRead != 0  // manual check
+ &#96;&#96;&#96;
+ 
+ Not hard, but not helpful either.
+ 
+ ## Making It Better
+ 
+ Here's how the Go community works around these limitations:
+ 
+ ### The Stringer Tool
+ 
+ Generate &#96;String()&#96; methods automatically:
+ 
+ &#96;&#96;&#96;bash
+ go install golang.org/x/tools/cmd/stringer@latest
+ &#96;&#96;&#96;
+ 
+ Add a generate directive:
+ 
+ &#96;&#96;&#96;go
+ //go:generate stringer -type=Status
+ 
+ type Status int
+ 
+ const (
+     StatusPending Status = iota
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ &#96;&#96;&#96;
+ 
+ Run &#96;go generate ./...&#96; and you get a &#96;status_string.go&#96; file with the &#96;String()&#96; method implemented.
+ 
+ ### Validation Methods
+ 
+ Add explicit validation:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) IsValid() bool {
+     switch s {
+     case StatusPending, StatusActive, StatusCompleted, StatusCancelled:
+         return true
+     default:
+         return false
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Slice of All Values
+ 
+ Useful for iteration and testing:
+ 
+ &#96;&#96;&#96;go
+ var AllStatuses = []Status{
+     StatusPending,
+     StatusActive,
+     StatusCompleted,
+     StatusCancelled,
+ }
+ 
+ func (s Status) IsValid() bool {
+     return slices.Contains(AllStatuses, s)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parse Functions
+ 
+ For deserialisation:
+ 
+ &#96;&#96;&#96;go
+ func ParseStatus(s string) (Status, error) {
+     switch s {
+     case "Pending", "pending":
+         return StatusPending, nil
+     case "Active", "active":
+         return StatusActive, nil
+     case "Completed", "completed":
+         return StatusCompleted, nil
+     case "Cancelled", "cancelled":
+         return StatusCancelled, nil
+     default:
+         return 0, fmt.Errorf("unknown status: %s", s)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### JSON Marshalling
+ 
+ By default, Go's JSON marshaller uses the integer value. You probably want the string:
+ 
+ &#96;&#96;&#96;go
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     parsed, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = parsed
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ ## A Complete "Enum" Implementation
+ 
+ Here's what a production-ready Go "enum" looks like:
+ 
+ &#96;&#96;&#96;go
+ type Status int
+ 
+ const (
+     StatusPending Status = iota + 1  // start at 1, 0 means "unset"
+     StatusActive
+     StatusCompleted
+     StatusCancelled
+ )
+ 
+ var statusNames = map[Status]string{
+     StatusPending:   "Pending",
+     StatusActive:    "Active",
+     StatusCompleted: "Completed",
+     StatusCancelled: "Cancelled",
+ }
+ 
+ var statusValues = map[string]Status{
+     "Pending":   StatusPending,
+     "Active":    StatusActive,
+     "Completed": StatusCompleted,
+     "Cancelled": StatusCancelled,
+ }
+ 
+ func (s Status) String() string {
+     if name, ok := statusNames[s]; ok {
+         return name
+     }
+     return fmt.Sprintf("Status(%d)", s)
+ }
+ 
+ func ParseStatus(s string) (Status, error) {
+     if v, ok := statusValues[s]; ok {
+         return v, nil
+     }
+     return 0, fmt.Errorf("invalid status: %q", s)
+ }
+ 
+ func (s Status) IsValid() bool {
+     _, ok := statusNames[s]
+     return ok
+ }
+ 
+ func (s Status) MarshalJSON() ([]byte, error) {
+     return json.Marshal(s.String())
+ }
+ 
+ func (s *Status) UnmarshalJSON(data []byte) error {
+     var str string
+     if err := json.Unmarshal(data, &amp;str); err != nil {
+         return err
+     }
+     v, err := ParseStatus(str)
+     if err != nil {
+         return err
+     }
+     *s = v
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Compare that to C#:
+ 
+ &#96;&#96;&#96;csharp
+ public enum Status { Pending, Active, Completed, Cancelled }
+ &#96;&#96;&#96;
+ 
+ Yeah.
+ 
+ ## The Honest Assessment
+ 
+ | Feature | C# Enum | Go "Enum" |
+ |---------|---------|-----------|
+ | Declaration | One line | Const block |
+ | Type safety | Strong | Weak (any int assignable) |
+ | String conversion | Built-in | Manual or generated |
+ | Parsing | Built-in | Manual |
+ | Exhaustive switch | Analyzers available | External linter |
+ | Flag support | &#96;[Flags]&#96; + &#96;HasFlag&#96; | Manual bit ops |
+ | JSON serialisation | Configurable | Manual implementation |
+ | Iteration over values | &#96;Enum.GetValues&#96; | Manual slice |
+ 
+ Go's approach is simpler in concept but more work in practice. For a type you use once, it's fine. For a type used throughout a codebase with JSON APIs, database columns, and validation requirements, you'll write a lot of boilerplate.
+ 
+ ## When to Reach for Alternatives
+ 
+ **String constants instead of int enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status string
+ 
+ const (
+     StatusPending   Status = "pending"
+     StatusActive    Status = "active"
+     StatusCompleted Status = "completed"
+     StatusCancelled Status = "cancelled"
+ )
+ &#96;&#96;&#96;
+ 
+ Pros: Natural JSON serialisation, readable in logs/databases.
+ Cons: More memory, slower comparison, still no exhaustive switch checking.
+ 
+ **Third-party enum packages:**
+ 
+ Libraries like &#96;go-enum&#96; generate all the boilerplate. Worth considering for large projects.
+ 
+ **Interface-based enums:**
+ 
+ &#96;&#96;&#96;go
+ type Status interface {
+     status()  // unexported marker method
+     String() string
+ }
+ 
+ type statusPending struct{}
+ func (statusPending) status() {}
+ func (statusPending) String() string { return "Pending" }
+ 
+ var StatusPending Status = statusPending{}
+ &#96;&#96;&#96;
+ 
+ Type-safe (can't create arbitrary values), but verbose and unusual.
+ 
+ ## Practical Advice
+ 
+ 1. **Use &#96;stringer&#96; for any enum in production code.** The manual &#96;String()&#96; method will fall out of sync.
+ 
+ 2. **Start const values at 1 if zero means "unset."** Or use an explicit &#96;StatusUnknown = 0&#96; value.
+ 
+ 3. **Always add an &#96;IsValid()&#96; method.** Check it at system boundaries (API inputs, database reads).
+ 
+ 4. **Use string-based enums for external APIs.** They're more forgiving and self-documenting.
+ 
+ 5. **Accept the boilerplate.** Fighting it is pointless. Copy-paste or generate.
+ 
+ 6. **Use the &#96;exhaustive&#96; linter.** It's the only way to get switch statement coverage warnings.
+ 
+ Go's lack of proper enums is one of its genuine weaknesses. The workarounds work, but they're workarounds. Every Go developer I know has a personal template or snippet for "proper" enum implementation.
+ 
+ Maybe we'll get real enums eventually. Until then, embrace &#96;iota&#96; and keep your boilerplate consistent.
+ 
+ ---
+ 
+ *That wraps up Phase 2 on types and data. Next we'll move into Phase 3: Functions, Methods, and Interfaces—where Go's composition-over-inheritance philosophy really starts to show its strengths.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
All five posts are written. Let me verify the Hugo build passes with all of them.</details></think>

---

Let me verify the Hugo build passes with all the new posts:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
-rw-r--r--  1 andycross  staff  10096 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   8877 Dec 28 20:24 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8502 Dec 28 20:25 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8749 Dec 28 20:23 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9254 Dec 28 20:23 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All seven posts are now created and the build passes. Let me summarize what was created for the user.</details></think>

---

All five Phase 2 posts are created and the Hugo build passes. Here's the complete series so far:

## C# to Go Series

### Phase 1: Getting Oriented (2 posts)
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model, cross-compilation
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection, go.sum

### Phase 2: Types & Data (5 posts)
3. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, pointers, embedding vs inheritance, implicit interfaces
4. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields vs accessors, the `internal/` convention, struct tags
5. **"Generics: Late to the Party"** — What Go 1.18+ provides, constraints, what's missing (variance, generic methods, specialisation)
6. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap, zero values as defaults
7. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, what's missing (exhaustive switch, String()), stringer tool, workarounds

Each post follows the established tone:
- UK English throughout
- First person plural for learning together
- Fair comparisons (not bashing C# or overselling Go)
- Tables for genuine comparisons
- Runnable code examples
- Honest "what I miss" and "what I prefer" sections
- Practical advice sections

Ready for Phase 3 when you are?

---

_**User (2025-12-29 06:27Z)**_

We need to enhance one of the earlier posts, or inject a new one, which helps understand two key things

1) arrays are slices, dictionaries are maps ---- what are the key terminology changes that trip you up coming from c#
2) what are the new operators that you have to get ready for (:= for instance) 

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to either enhance an existing post or create a new one that covers:
1. Terminology changes (arrays→slices, Dictionary→map, etc.)
2. New operators (:=, etc.)

Looking at the current series structure:
- Phase 1: Toolchain, Modules
- Phase 2: Structs, Visibility, Generics, Nil, Enums

This content feels like it should come early - it's foundational "getting oriented" material. It could either:
1. Be injected into the first post (toolchain)
2. Become a new post between Phase 1 and Phase 2

I think a new post makes more sense - this is substantial enough content to stand alone, and it's really about "the basics that trip you up" before you even get to types in depth. It could be titled something like "The Phrasebook: C# to Go Terminology and Syntax".

Let me create a new post that fits between the toolchain/modules posts and the types posts. This should cover:

Terminology:
- array → slice (and actual arrays exist but are rare)
- List<T> → slice
- Dictionary<K,V> → map
- namespace → package
- null → nil
- class → struct
- interface (explicit) → interface (implicit)
- property → field + methods
- var → var (but also :=)
- async/await → goroutines/channels
- event → channels
- LINQ → no equivalent (loops or generics)
- exception → error
- try/catch → if err != nil
- using → defer
- lock → sync.Mutex
- foreach → for range
- out/ref → pointers

Operators:
- := short variable declaration
- & address-of (like C#)
- * dereference (like C#)
- <- channel send/receive
- ... variadic and slice unpacking
- range keyword in for loops
- _ blank identifier
- := vs = 


- make() and new() are crucial memory allocation functions in Go

I'll explore make() and new() as key memory allocation mechanisms. make() is specifically for creating slices, maps, and channels, initializing their internal data structures. new() allocates memory for a type and returns a pointer, zeroing out the memory. These functions handle different memory initialization scenarios, providing precise control over how Go allocates and prepares memory for various data structures.</details></think>

---

Good call—this foundational "translation" content should come early in the series. I'll create a new post that slots in between the toolchain posts and the types posts. It's substantial enough to stand alone as a "phrasebook" reference.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-phrasebook.md</summary>

**Chunk 1**
Lines added: 424, lines removed: 1

```diff
@@ -1,1 +1,424 @@
- 
+ +++
+ title = "The Phrasebook: C# Concepts in Go Terms"
+ date = "2024-12-28"
+ draft = false
+ tags = ["go", "dotnet", "syntax", "csharp"]
+ +++
+ 
+ Before we get into the weeds of types and patterns, let's establish some vocabulary. Go uses different names for familiar concepts, and has operators you've never seen. This post is a reference—skim it now, bookmark it for later.
+ 
+ ## The Terminology Swap
+ 
+ Your C# brain thinks in certain words. Here's the translation:
+ 
+ | C# Term | Go Term | Notes |
+ |---------|---------|-------|
+ | &#96;List&lt;T&gt;&#96; | slice | Dynamic array, the workhorse collection |
+ | &#96;T[]&#96; (array) | slice (usually) | Go has arrays, but you'll rarely use them |
+ | &#96;Dictionary&lt;K,V&gt;&#96; | map | &#96;map[string]int&#96; instead of &#96;Dictionary&lt;string, int&gt;&#96; |
+ | namespace | package | But packages are directories, not hierarchies |
+ | &#96;null&#96; | &#96;nil&#96; | Same concept, different spelling |
+ | class | struct | No inheritance, but methods work |
+ | property | field (+ methods) | No get/set syntax |
+ | &#96;var&#96; | &#96;var&#96; or &#96;:=&#96; | Two ways to declare variables |
+ | &#96;async&#96;/&#96;await&#96; | goroutines + channels | Completely different model |
+ | exception | error | Errors are values, not control flow |
+ | &#96;try&#96;/&#96;catch&#96; | &#96;if err != nil&#96; | Explicit checking, no unwinding |
+ | &#96;using&#96; | &#96;defer&#96; | Cleanup runs at function exit |
+ | &#96;lock&#96; | &#96;sync.Mutex&#96; | Manual lock/unlock |
+ | &#96;foreach&#96; | &#96;for range&#96; | Single construct for iteration |
+ | &#96;out&#96;/&#96;ref&#96; | pointers | Explicit &#96;*&#96; and &#96;&amp;&#96; |
+ | LINQ | nothing built-in | Loops, or generics since 1.18 |
+ | extension methods | nothing | Define functions, not methods |
+ | partial class | nothing | All code in the package shares scope |
+ | static class | package-level functions | No class, just functions |
+ 
+ ### Arrays vs Slices
+ 
+ This one catches everyone. In C#, "array" means a fixed-size, contiguous block:
+ 
+ &#96;&#96;&#96;csharp
+ int[] numbers = new int[5];  // fixed size 5
+ &#96;&#96;&#96;
+ 
+ In Go, this is also called an array—but you almost never use them directly:
+ 
+ &#96;&#96;&#96;go
+ var numbers [5]int  // array - fixed size, rarely used
+ &#96;&#96;&#96;
+ 
+ What you use instead is a **slice**—a dynamic view over an array:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}  // slice - this is what you want
+ numbers = append(numbers, 6)     // grows automatically
+ &#96;&#96;&#96;
+ 
+ Think of slices as &#96;List&lt;T&gt;&#96; that happens to have array-like syntax. They grow, shrink, and pass by reference (sort of—the header is copied, but the backing array is shared).
+ 
+ **The rule:** if you're reaching for an array in Go, you probably want a slice.
+ 
+ ### Maps
+ 
+ &#96;Dictionary&lt;K, V&gt;&#96; becomes &#96;map[K]V&#96;. The syntax is inside-out:
+ 
+ &#96;&#96;&#96;csharp
+ // C#
+ var scores = new Dictionary&lt;string, int&gt;
+ {
+     ["Alice"] = 100,
+     ["Bob"] = 85
+ };
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go
+ scores := map[string]int{
+     "Alice": 100,
+     "Bob":   85,
+ }
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - Maps must be initialised before use (nil maps panic on write)
+ - Missing keys return the zero value
+ - Use the two-value form to check existence: &#96;val, ok := m[key]&#96;
+ 
+ &#96;&#96;&#96;go
+ score, exists := scores["Charlie"]
+ if !exists {
+     fmt.Println("Charlie not found")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Operators You Haven't Met
+ 
+ Go has several operators and constructs that don't exist in C#. Here's your cheat sheet.
+ 
+ ### &#96;:=&#96; Short Variable Declaration
+ 
+ This is the one you'll use constantly:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ var name string = "Alice"
+ name := "Alice"  // type inferred, shorter
+ &#96;&#96;&#96;
+ 
+ The &#96;:=&#96; operator declares AND assigns. It only works inside functions, and only for new variables.
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ name := "Bob"    // ERROR: no new variables on left side
+ name = "Bob"     // OK: just assignment, no declaration
+ &#96;&#96;&#96;
+ 
+ **The gotcha:** &#96;:=&#96; in an inner scope creates a new variable that shadows the outer one:
+ 
+ &#96;&#96;&#96;go
+ name := "Alice"
+ if true {
+     name := "Bob"  // new variable, shadows outer 'name'
+     fmt.Println(name)  // "Bob"
+ }
+ fmt.Println(name)  // "Alice" - outer unchanged!
+ &#96;&#96;&#96;
+ 
+ This is a common source of bugs. Use &#96;=&#96; for assignment when the variable already exists.
+ 
+ ### &#96;_&#96; Blank Identifier
+ 
+ The underscore discards a value. You'll use it constantly because Go requires you to use all declared variables:
+ 
+ &#96;&#96;&#96;go
+ // Ignore the index in a range loop
+ for _, value := range items {
+     fmt.Println(value)
+ }
+ 
+ // Ignore an unwanted return value
+ _, err := doSomething()
+ 
+ // Ignore the second return value (existence check)
+ value, _ := myMap[key]  // don't care if it exists
+ 
+ // Interface compliance check (compile-time)
+ var _ io.Reader = (*MyType)(nil)
+ &#96;&#96;&#96;
+ 
+ ### &#96;&lt;-&#96; Channel Operator
+ 
+ Channels are Go's concurrency primitive. The &#96;&lt;-&#96; operator sends and receives:
+ 
+ &#96;&#96;&#96;go
+ ch := make(chan int)
+ 
+ go func() {
+     ch &lt;- 42  // send 42 into the channel
+ }()
+ 
+ value := &lt;-ch  // receive from the channel
+ fmt.Println(value)  // 42
+ &#96;&#96;&#96;
+ 
+ The arrow points in the direction of data flow. Send: &#96;ch &lt;- value&#96;. Receive: &#96;value := &lt;-ch&#96;.
+ 
+ ### &#96;...&#96; Variadic and Spread
+ 
+ Two related uses for the ellipsis:
+ 
+ **Variadic parameters** (like C#'s &#96;params&#96;):
+ 
+ &#96;&#96;&#96;go
+ func Sum(numbers ...int) int {
+     total := 0
+     for _, n := range numbers {
+         total += n
+     }
+     return total
+ }
+ 
+ Sum(1, 2, 3)  // works
+ Sum(1, 2, 3, 4, 5)  // also works
+ &#96;&#96;&#96;
+ 
+ **Spreading a slice** into variadic arguments:
+ 
+ &#96;&#96;&#96;go
+ numbers := []int{1, 2, 3, 4, 5}
+ Sum(numbers...)  // unpacks the slice
+ &#96;&#96;&#96;
+ 
+ ### &#96;&amp;&#96; and &#96;*&#96; (Pointers)
+ 
+ These exist in C# but you probably haven't used them much. In Go, they're everywhere:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x   // p is *int, points to x
+ *p = 100  // dereference: x is now 100
+ &#96;&#96;&#96;
+ 
+ More commonly, you'll see them with structs:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ u := User{Name: "Alice"}
+ ptr := &amp;u           // *User
+ ptr.Name = "Bob"    // Go auto-dereferences for field access
+ &#96;&#96;&#96;
+ 
+ ### &#96;make()&#96; and &#96;new()&#96;
+ 
+ Two built-in functions for creating things:
+ 
+ **&#96;make()&#96;** is for slices, maps, and channels—types that need initialisation:
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 0, 10)     // slice with length 0, capacity 10
+ m := make(map[string]int)   // initialised map (not nil!)
+ ch := make(chan int)        // unbuffered channel
+ ch := make(chan int, 10)    // buffered channel, capacity 10
+ &#96;&#96;&#96;
+ 
+ **&#96;new()&#96;** allocates and returns a pointer to the zero value:
+ 
+ &#96;&#96;&#96;go
+ p := new(User)  // *User, pointing to User{}
+ &#96;&#96;&#96;
+ 
+ In practice, you'll use &#96;make()&#96; often and &#96;new()&#96; rarely. The composite literal with &#96;&amp;&#96; is more common:
+ 
+ &#96;&#96;&#96;go
+ p := &amp;User{Name: "Alice"}  // equivalent to new + field assignment
+ &#96;&#96;&#96;
+ 
+ ## The &#96;for&#96; Loop (It's the Only One)
+ 
+ Go has one loop construct: &#96;for&#96;. It does everything.
+ 
+ &#96;&#96;&#96;go
+ // Traditional for loop (like C#)
+ for i := 0; i &lt; 10; i++ {
+     fmt.Println(i)
+ }
+ 
+ // While loop (condition only)
+ for condition {
+     // ...
+ }
+ 
+ // Infinite loop
+ for {
+     // break to exit
+ }
+ 
+ // Range over slice (like foreach)
+ for index, value := range items {
+     fmt.Println(index, value)
+ }
+ 
+ // Range over map
+ for key, value := range myMap {
+     fmt.Println(key, value)
+ }
+ 
+ // Range over string (gives runes, not bytes)
+ for index, char := range "hello" {
+     fmt.Printf("%d: %c\n", index, char)
+ }
+ 
+ // Range over channel
+ for msg := range messages {
+     fmt.Println(msg)  // until channel is closed
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;_&#96; to ignore index or value:
+ 
+ &#96;&#96;&#96;go
+ for _, value := range items { }  // ignore index
+ for index := range items { }     // ignore value (just omit it)
+ &#96;&#96;&#96;
+ 
+ ## &#96;defer&#96; Instead of &#96;using&#96;
+ 
+ C#'s &#96;using&#96; statement disposes resources at block exit:
+ 
+ &#96;&#96;&#96;csharp
+ using var file = File.OpenRead("data.txt");
+ // file is disposed when scope exits
+ &#96;&#96;&#96;
+ 
+ Go's &#96;defer&#96; schedules a function call to run when the *function* exits:
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()  // runs when this function returns
+ 
+ // use file...
+ &#96;&#96;&#96;
+ 
+ Key differences:
+ - &#96;defer&#96; runs at function exit, not block exit
+ - Multiple defers run in LIFO order (last defer runs first)
+ - Deferred calls capture their arguments when the defer statement executes
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     defer fmt.Println("first")
+     defer fmt.Println("second")
+     defer fmt.Println("third")
+ }
+ // Output: third, second, first
+ &#96;&#96;&#96;
+ 
+ ## Error Handling: &#96;if err != nil&#96;
+ 
+ This is the biggest mental shift. No exceptions, no try/catch. Errors are values.
+ 
+ &#96;&#96;&#96;go
+ file, err := os.Open("data.txt")
+ if err != nil {
+     return fmt.Errorf("failed to open: %w", err)
+ }
+ defer file.Close()
+ 
+ data, err := io.ReadAll(file)
+ if err != nil {
+     return fmt.Errorf("failed to read: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ You'll write &#96;if err != nil&#96; hundreds of times. It's verbose. It's explicit. It works.
+ 
+ The &#96;%w&#96; verb wraps errors, preserving the chain for later inspection with &#96;errors.Is()&#96; and &#96;errors.As()&#96;.
+ 
+ ## Multiple Return Values
+ 
+ Go functions can return multiple values. This is how errors are returned:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (float64, error) {
+     if b == 0 {
+         return 0, errors.New("division by zero")
+     }
+     return a / b, nil
+ }
+ 
+ result, err := Divide(10, 2)
+ if err != nil {
+     // handle error
+ }
+ &#96;&#96;&#96;
+ 
+ You can also use named return values:
+ 
+ &#96;&#96;&#96;go
+ func Divide(a, b float64) (result float64, err error) {
+     if b == 0 {
+         err = errors.New("division by zero")
+         return  // returns named values
+     }
+     result = a / b
+     return
+ }
+ &#96;&#96;&#96;
+ 
+ Named returns are sometimes clearer, sometimes not. Use your judgement.
+ 
+ ## Type Assertions and Switches
+ 
+ When you have an &#96;interface{}&#96; (or &#96;any&#96;) and need the concrete type:
+ 
+ &#96;&#96;&#96;go
+ // Type assertion
+ value := something.(string)  // panics if not string
+ 
+ // Safe type assertion
+ value, ok := something.(string)
+ if !ok {
+     // not a string
+ }
+ 
+ // Type switch
+ switch v := something.(type) {
+ case string:
+     fmt.Println("string:", v)
+ case int:
+     fmt.Println("int:", v)
+ default:
+     fmt.Println("unknown type")
+ }
+ &#96;&#96;&#96;
+ 
+ ## Quick Reference Card
+ 
+ Keep this handy until it's automatic:
+ 
+ | When you want to... | C# | Go |
+ |---------------------|-----|-----|
+ | Declare and assign | &#96;var x = 5;&#96; | &#96;x := 5&#96; |
+ | Declare without assign | &#96;int x;&#96; | &#96;var x int&#96; |
+ | Create a list | &#96;new List&lt;int&gt;()&#96; | &#96;[]int{}&#96; or &#96;make([]int, 0)&#96; |
+ | Create a dictionary | &#96;new Dictionary&lt;K,V&gt;()&#96; | &#96;make(map[K]V)&#96; |
+ | Append to list | &#96;list.Add(x)&#96; | &#96;slice = append(slice, x)&#96; |
+ | Get dictionary value | &#96;dict[key]&#96; | &#96;val := m[key]&#96; or &#96;val, ok := m[key]&#96; |
+ | Check key exists | &#96;dict.ContainsKey(k)&#96; | &#96;_, ok := m[k]&#96; |
+ | Iterate collection | &#96;foreach (var x in items)&#96; | &#96;for _, x := range items&#96; |
+ | Null check | &#96;if (x == null)&#96; | &#96;if x == nil&#96; |
+ | String format | &#96;$"Hello {name}"&#96; | &#96;fmt.Sprintf("Hello %s", name)&#96; |
+ | Error handling | &#96;try { } catch { }&#96; | &#96;if err != nil { }&#96; |
+ | Cleanup | &#96;using var x = ...&#96; | &#96;defer x.Close()&#96; |
+ | Async | &#96;await Task.Run(...)&#96; | &#96;go func() { }()&#96; |
+ 
+ ---
+ 
+ *This post is a reference, not a deep dive. We'll cover structs, visibility, and the type system properly in the next posts. But now you've got the vocabulary and the operators—the rest should make more sense.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, let me verify the build works.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l
```

```
Build successful
       8

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 8 posts now exist and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

Build passes. Here's the updated series structure with the new post slotted in:

## C# to Go Series (8 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — The `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet, Minimum Version Selection
3. **"The Phrasebook: C# Concepts in Go Terms"** ← **NEW** — Terminology swap (slice, map, nil), new operators (`:=`, `_`, `<-`, `...`), `for range`, `defer`, error handling basics, quick reference card

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference semantics, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields, struct tags
6. **"Generics: Late to the Party"** — What Go 1.18+ provides versus C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types, the interface nil trap
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, stringer, workarounds

The Phrasebook post covers:
- **Terminology:** array→slice, Dictionary→map, null→nil, foreach→for range, using→defer, try/catch→if err != nil
- **New operators:** `:=` (short declaration), `_` (blank identifier), `<-` (channels), `...` (variadic/spread), `&`/`*` (pointers)
- **Built-ins:** `make()` vs `new()`, the single `for` loop, `defer` semantics
- **Quick reference card** at the end for bookmarking

The date is set to 2024-12-28 (same as the first two posts) so it'll sort appropriately. Ready for Phase 3 whenever you are!

---

_**User (2025-12-29 06:27Z)**_

ok the next phase now, phase 3 - Control Flow & Error Handling

if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create Phase 3: Control Flow & Error Handling with 3 posts:

1. if err != nil: Your New Reality — Why exceptions don't exist and how to stop hating explicit errors
2. Panic and Recover: The Emergency Exit — When Go devs actually use exceptions (and when they judge you for it)
3. The switch Statement You Always Wanted — Type switches, fallthrough weirdness, and expression switching

Let me write all three posts following the same tone and style.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-errors.md</summary>

**Chunk 1**
Lines added: 374, lines removed: 1

```diff
@@ -1,1 +1,374 @@
- 
+ +++
+ title = "if err != nil: Your New Reality"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ Let's address the elephant in the room. You're going to write &#96;if err != nil&#96; hundreds of times. Thousands, probably. And for the first week, you're going to hate it.
+ 
+ Coming from C#, where exceptions handle the sad path invisibly, Go's explicit error handling feels like a step backwards. It's verbose. It's repetitive. It clutters your code with what looks like boilerplate.
+ 
+ Then something shifts. You start to see what you're gaining. Let's work through that shift.
+ 
+ ## Why No Exceptions?
+ 
+ C# uses exceptions for error handling:
+ 
+ &#96;&#96;&#96;csharp
+ try
+ {
+     var data = await File.ReadAllTextAsync("config.json");
+     var config = JsonSerializer.Deserialize&lt;Config&gt;(data);
+     await database.Connect(config.ConnectionString);
+ }
+ catch (FileNotFoundException)
+ {
+     logger.Error("Config file missing");
+ }
+ catch (JsonException ex)
+ {
+     logger.Error($"Invalid config: {ex.Message}");
+ }
+ catch (Exception ex)
+ {
+     logger.Error($"Unexpected error: {ex.Message}");
+     throw;
+ }
+ &#96;&#96;&#96;
+ 
+ This looks clean. The happy path is uncluttered. Errors are handled elsewhere.
+ 
+ But there's a hidden cost: **you can't see which lines can fail**. Any line might throw. Any function you call might throw. The &#96;catch&#96; block is disconnected from the code that caused the problem.
+ 
+ Go takes the opposite view: **errors are values, returned like any other value**:
+ 
+ &#96;&#96;&#96;go
+ data, err := os.ReadFile("config.json")
+ if err != nil {
+     return fmt.Errorf("reading config: %w", err)
+ }
+ 
+ var config Config
+ if err := json.Unmarshal(data, &amp;config); err != nil {
+     return fmt.Errorf("parsing config: %w", err)
+ }
+ 
+ if err := database.Connect(config.ConnectionString); err != nil {
+     return fmt.Errorf("connecting to database: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ Verbose? Yes. But look at what you can see:
+ 
+ - Every line that can fail is marked with &#96;err :=&#96; or &#96;, err&#96;
+ - You know exactly what error each block handles
+ - The handling is right next to the call that produced the error
+ - No hidden control flow—the code does what it looks like it does
+ 
+ ## The Error Interface
+ 
+ In Go, &#96;error&#96; is just an interface:
+ 
+ &#96;&#96;&#96;go
+ type error interface {
+     Error() string
+ }
+ &#96;&#96;&#96;
+ 
+ Anything with an &#96;Error()&#96; method is an error. This is intentionally simple.
+ 
+ Creating errors:
+ 
+ &#96;&#96;&#96;go
+ import "errors"
+ 
+ // Simple error
+ err := errors.New("something went wrong")
+ 
+ // Formatted error
+ err := fmt.Errorf("failed to load user %d: %w", userID, originalErr)
+ &#96;&#96;&#96;
+ 
+ That &#96;%w&#96; verb is important—it wraps the original error, preserving the chain.
+ 
+ ## The Pattern You'll Write Forever
+ 
+ Here's the basic pattern:
+ 
+ &#96;&#96;&#96;go
+ result, err := doSomething()
+ if err != nil {
+     return fmt.Errorf("doing something: %w", err)
+ }
+ // use result
+ &#96;&#96;&#96;
+ 
+ Variations:
+ 
+ &#96;&#96;&#96;go
+ // When there's no result to use
+ if err := doSomething(); err != nil {
+     return err
+ }
+ 
+ // When you want to handle specific errors
+ if err := doSomething(); err != nil {
+     if errors.Is(err, ErrNotFound) {
+         return defaultValue, nil  // handle gracefully
+     }
+     return zero, err  // propagate others
+ }
+ 
+ // When you need to clean up on error
+ file, err := os.Create("output.txt")
+ if err != nil {
+     return err
+ }
+ defer file.Close()
+ 
+ if err := writeData(file); err != nil {
+     os.Remove("output.txt")  // clean up partial file
+     return fmt.Errorf("writing data: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Wrapping Errors Properly
+ 
+ Go 1.13 introduced error wrapping. Use it:
+ 
+ &#96;&#96;&#96;go
+ // BAD: loses the original error
+ if err != nil {
+     return errors.New("failed to connect")
+ }
+ 
+ // BAD: concatenates as string, loses error chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %s", err)
+ }
+ 
+ // GOOD: wraps the error, preserves the chain
+ if err != nil {
+     return fmt.Errorf("failed to connect: %w", err)
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;%w&#96; verb creates a chain that can be inspected:
+ 
+ &#96;&#96;&#96;go
+ if errors.Is(err, sql.ErrNoRows) {
+     // somewhere in the chain, there's a sql.ErrNoRows
+ }
+ 
+ var pathErr *os.PathError
+ if errors.As(err, &amp;pathErr) {
+     // somewhere in the chain, there's a *os.PathError
+     fmt.Println(pathErr.Path)
+ }
+ &#96;&#96;&#96;
+ 
+ ## Sentinel Errors
+ 
+ For errors that callers need to check, define package-level sentinel errors:
+ 
+ &#96;&#96;&#96;go
+ package user
+ 
+ var (
+     ErrNotFound     = errors.New("user not found")
+     ErrInvalidEmail = errors.New("invalid email address")
+     ErrDuplicate    = errors.New("user already exists")
+ )
+ 
+ func Find(id string) (*User, error) {
+     // ...
+     if notFound {
+         return nil, ErrNotFound
+     }
+     // ...
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can check:
+ 
+ &#96;&#96;&#96;go
+ user, err := user.Find("123")
+ if errors.Is(err, user.ErrNotFound) {
+     // handle not found specifically
+ }
+ &#96;&#96;&#96;
+ 
+ ## Custom Error Types
+ 
+ When you need more context, create a custom error type:
+ 
+ &#96;&#96;&#96;go
+ type ValidationError struct {
+     Field   string
+     Message string
+ }
+ 
+ func (e *ValidationError) Error() string {
+     return fmt.Sprintf("%s: %s", e.Field, e.Message)
+ }
+ 
+ func ValidateUser(u *User) error {
+     if u.Email == "" {
+         return &amp;ValidationError{Field: "email", Message: "required"}
+     }
+     if !strings.Contains(u.Email, "@") {
+         return &amp;ValidationError{Field: "email", Message: "invalid format"}
+     }
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ Callers can extract details:
+ 
+ &#96;&#96;&#96;go
+ if err := ValidateUser(u); err != nil {
+     var valErr *ValidationError
+     if errors.As(err, &amp;valErr) {
+         fmt.Printf("Validation failed on %s: %s\n", valErr.Field, valErr.Message)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## Strategies That Help
+ 
+ ### Early Returns
+ 
+ Embrace early returns. Don't nest error handling:
+ 
+ &#96;&#96;&#96;go
+ // BAD: nested, hard to follow
+ func process() error {
+     data, err := loadData()
+     if err == nil {
+         parsed, err := parseData(data)
+         if err == nil {
+             result, err := transform(parsed)
+             if err == nil {
+                 return save(result)
+             } else {
+                 return err
+             }
+         } else {
+             return err
+         }
+     } else {
+         return err
+     }
+ }
+ 
+ // GOOD: flat, obvious
+ func process() error {
+     data, err := loadData()
+     if err != nil {
+         return fmt.Errorf("loading: %w", err)
+     }
+     
+     parsed, err := parseData(data)
+     if err != nil {
+         return fmt.Errorf("parsing: %w", err)
+     }
+     
+     result, err := transform(parsed)
+     if err != nil {
+         return fmt.Errorf("transforming: %w", err)
+     }
+     
+     return save(result)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Naming Consistency
+ 
+ Keep error variable names consistent within a function:
+ 
+ &#96;&#96;&#96;go
+ // Use 'err' for the standard error variable
+ data, err := load()
+ if err != nil { ... }
+ 
+ result, err := process(data)  // reuse 'err'
+ if err != nil { ... }
+ 
+ // Use descriptive names when you have multiple errors in scope
+ loadErr := load()
+ processErr := process()
+ if loadErr != nil || processErr != nil { ... }
+ &#96;&#96;&#96;
+ 
+ ### The "Must" Pattern
+ 
+ For initialisation code where errors are truly unrecoverable:
+ 
+ &#96;&#96;&#96;go
+ var templates = template.Must(template.ParseGlob("templates/*.html"))
+ var config = MustLoadConfig("config.yaml")
+ 
+ func MustLoadConfig(path string) Config {
+     cfg, err := LoadConfig(path)
+     if err != nil {
+         panic(fmt.Sprintf("loading config: %v", err))
+     }
+     return cfg
+ }
+ &#96;&#96;&#96;
+ 
+ Use &#96;Must&#96; functions sparingly—only for program setup where failure means "can't start."
+ 
+ ## What You're Actually Getting
+ 
+ After the initial frustration wears off, here's what explicit errors give you:
+ 
+ **Visible failure points.** Every line that can fail is marked. No surprises.
+ 
+ **Local reasoning.** You handle errors where they occur. No tracing back through call stacks.
+ 
+ **No performance penalty.** Error returns are just values—no stack unwinding, no runtime cost.
+ 
+ **Forced consideration.** You can't ignore errors accidentally. (Well, you can with &#96;_&#96;, but it's deliberate.)
+ 
+ **Simpler debugging.** When something fails, the error message tells you exactly what happened at each level.
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Exceptions | Go Errors |
+ |--------|--------------|-----------|
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;throw&#96; | &#96;if err != nil&#96; |
+ | Control flow | Non-local jump | Normal return |
+ | Performance | Cost on throw | No overhead |
+ | Visibility | Hidden failure points | Explicit everywhere |
+ | Ignoring errors | Silent (dangerous) | Requires explicit &#96;_&#96; |
+ | Stack traces | Automatic | Manual (or wrap carefully) |
+ | Recovery | &#96;catch&#96; blocks | Caller decides |
+ 
+ ## The Honest Take
+ 
+ **Things I like better than C#:**
+ 
+ - You can see which calls can fail
+ - Error handling is local and explicit
+ - No surprise exceptions from deep in the stack
+ - Errors are values—you can store, compare, wrap them
+ 
+ **Things I miss from C#:**
+ 
+ - The happy path being uncluttered
+ - Automatic stack traces
+ - &#96;finally&#96; blocks (defer is close but not identical)
+ - Not writing the same three lines a thousand times
+ 
+ **The verdict:**
+ 
+ Go's approach is more verbose but more honest. Once you accept that error handling is part of your code—not something that happens off to the side—the verbosity starts to feel appropriate.
+ 
+ You're not writing boilerplate. You're writing error handling. It just happens to look the same every time because handling errors correctly *is* repetitive.
+ 
+ ---
+ 
+ *Next up: panic and recover—Go's actual exception mechanism, why it exists, and why using it for normal errors will get you judged.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-panic.md</summary>

**Chunk 1**
Lines added: 316, lines removed: 1

```diff
@@ -1,1 +1,316 @@
- 
+ +++
+ title = "Panic and Recover: The Emergency Exit"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "errors", "csharp"]
+ +++
+ 
+ So Go doesn't have exceptions. Except... it kind of does. They're called &#96;panic&#96; and &#96;recover&#96;, and they work almost exactly like throw and catch.
+ 
+ Here's the thing: if you use them like exceptions, other Go developers will judge you. Harshly. Let's understand why they exist, when to use them, and why the judgment is (mostly) deserved.
+ 
+ ## What Panic Does
+ 
+ &#96;panic&#96; stops normal execution and begins unwinding the stack:
+ 
+ &#96;&#96;&#96;go
+ func divide(a, b int) int {
+     if b == 0 {
+         panic("division by zero")
+     }
+     return a / b
+ }
+ 
+ func main() {
+     result := divide(10, 0)  // panics here
+     fmt.Println(result)      // never reached
+ }
+ &#96;&#96;&#96;
+ 
+ Output:
+ 
+ &#96;&#96;&#96;
+ panic: division by zero
+ 
+ goroutine 1 [running]:
+ main.divide(...)
+         /app/main.go:7
+ main.main()
+         /app/main.go:12
+ exit status 2
+ &#96;&#96;&#96;
+ 
+ Sound familiar? It's an unhandled exception with a stack trace.
+ 
+ Deferred functions still run during a panic:
+ 
+ &#96;&#96;&#96;go
+ func riskyOperation() {
+     defer fmt.Println("cleanup runs")  // this executes
+     panic("oh no")
+     fmt.Println("never reached")
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Recover Does
+ 
+ &#96;recover&#96; catches a panic. It only works inside a deferred function:
+ 
+ &#96;&#96;&#96;go
+ func safeOperation() (err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             err = fmt.Errorf("recovered from panic: %v", r)
+         }
+     }()
+     
+     riskyOperation()  // might panic
+     return nil
+ }
+ &#96;&#96;&#96;
+ 
+ If &#96;riskyOperation&#96; panics, &#96;recover()&#96; catches it and we convert it to an error. The function returns normally instead of crashing.
+ 
+ This is literally try/catch:
+ 
+ &#96;&#96;&#96;csharp
+ // C# equivalent
+ try
+ {
+     RiskyOperation();
+ }
+ catch (Exception ex)
+ {
+     return new Error($"recovered from exception: {ex.Message}");
+ }
+ &#96;&#96;&#96;
+ 
+ ## Why Go Developers Judge You
+ 
+ So if panic/recover is just exceptions by another name, why not use them that way?
+ 
+ Because Go's error philosophy is that **errors are expected, panics are not**.
+ 
+ - Errors are things that can reasonably happen: file not found, network timeout, invalid input
+ - Panics are things that *shouldn't* happen: nil pointer dereference, index out of bounds, programmer bugs
+ 
+ When you use panic for normal errors, you're saying "this should never happen" when what you mean is "I didn't want to write &#96;if err != nil&#96;."
+ 
+ The community has strong opinions about this:
+ 
+ &#96;&#96;&#96;go
+ // This will get you judged
+ func ParseConfig(path string) Config {
+     data, err := os.ReadFile(path)
+     if err != nil {
+         panic(err)  // NO - missing file is a normal error
+     }
+     // ...
+ }
+ 
+ // This is fine
+ func MustParseConfig(path string) Config {
+     // "Must" in the name signals this panics
+     // Only use at startup where failure = can't run
+ }
+ &#96;&#96;&#96;
+ 
+ ## When Panic Is Appropriate
+ 
+ Despite the judgment, there are legitimate uses:
+ 
+ ### 1. Truly Unrecoverable Programmer Errors
+ 
+ &#96;&#96;&#96;go
+ func processItem(item *Item) {
+     if item == nil {
+         panic("processItem called with nil item")
+     }
+     // This is a programming error - the caller screwed up
+     // Not a runtime condition we should handle gracefully
+ }
+ &#96;&#96;&#96;
+ 
+ ### 2. Initialisation Failures
+ 
+ &#96;&#96;&#96;go
+ var db = mustConnect()
+ 
+ func mustConnect() *sql.DB {
+     db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
+     if err != nil {
+         panic(fmt.Sprintf("database connection failed: %v", err))
+     }
+     return db
+ }
+ &#96;&#96;&#96;
+ 
+ If the program can't start without a database, panicking at init is reasonable. There's nothing useful to do with the error.
+ 
+ ### 3. The "Must" Convention
+ 
+ Standard library examples:
+ 
+ &#96;&#96;&#96;go
+ // template.Must panics if parsing fails
+ var templates = template.Must(template.ParseGlob("*.html"))
+ 
+ // regexp.MustCompile panics if pattern is invalid
+ var emailRegex = regexp.MustCompile(&#96;^[a-z]+@[a-z]+\.[a-z]+$&#96;)
+ &#96;&#96;&#96;
+ 
+ The &#96;Must&#96; prefix tells callers "this panics on error—only use with compile-time constant inputs."
+ 
+ ### 4. Deep Recursion Bailout
+ 
+ Sometimes you're deep in recursion and unwinding through error returns is painful:
+ 
+ &#96;&#96;&#96;go
+ func parse(tokens []Token) (result AST, err error) {
+     defer func() {
+         if r := recover(); r != nil {
+             if parseErr, ok := r.(parseError); ok {
+                 err = parseErr
+             } else {
+                 panic(r)  // re-panic if it's not our error
+             }
+         }
+     }()
+     
+     return parseExpression(tokens), nil
+ }
+ 
+ func parseExpression(tokens []Token) AST {
+     // Deep recursive descent
+     // ...
+     if somethingWrong {
+         panic(parseError{msg: "unexpected token", pos: pos})
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ This is controversial but accepted in parsers and similar deep-recursion scenarios. Note that the panic is recovered at the boundary and converted to an error.
+ 
+ ## The Boundary Pattern
+ 
+ The key pattern: **never let panics escape your package**.
+ 
+ If your code might panic (or call code that might panic), recover at the boundary:
+ 
+ &#96;&#96;&#96;go
+ // Public API - never panics
+ func (s *Service) ProcessRequest(req Request) (Response, error) {
+     defer func() {
+         if r := recover(); r != nil {
+             // Log, maybe alert
+             log.Printf("panic in ProcessRequest: %v", r)
+         }
+     }()
+     
+     return s.doProcess(req)  // internal, might panic
+ }
+ &#96;&#96;&#96;
+ 
+ HTTP handlers often do this:
+ 
+ &#96;&#96;&#96;go
+ func recoveryMiddleware(next http.Handler) http.Handler {
+     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+         defer func() {
+             if err := recover(); err != nil {
+                 log.Printf("panic: %v\n%s", err, debug.Stack())
+                 http.Error(w, "Internal Server Error", 500)
+             }
+         }()
+         next.ServeHTTP(w, r)
+     })
+ }
+ &#96;&#96;&#96;
+ 
+ A panic in a handler becomes a 500 response, not a crashed server.
+ 
+ ## Panic Values
+ 
+ Unlike C# where you throw &#96;Exception&#96; objects, you can panic with any value:
+ 
+ &#96;&#96;&#96;go
+ panic("a string")
+ panic(42)
+ panic(errors.New("an error"))
+ panic(MyCustomType{})
+ &#96;&#96;&#96;
+ 
+ When recovering, you get an &#96;interface{}&#96;:
+ 
+ &#96;&#96;&#96;go
+ if r := recover(); r != nil {
+     switch v := r.(type) {
+     case error:
+         log.Printf("error: %v", v)
+     case string:
+         log.Printf("string: %s", v)
+     default:
+         log.Printf("unknown: %v", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Best practice: panic with &#96;error&#96; values or strings. Makes recovery predictable.
+ 
+ ## Comparison with C#
+ 
+ | Aspect | C# Exceptions | Go Panic/Recover |
+ |--------|---------------|------------------|
+ | Normal errors | Often used | Strongly discouraged |
+ | Programmer bugs | Appropriate | Appropriate |
+ | Syntax | &#96;try&#96;/&#96;catch&#96;/&#96;finally&#96; | &#96;defer&#96;/&#96;recover&#96; |
+ | Stack traces | Automatic | Available via &#96;debug.Stack()&#96; |
+ | Filtering | Catch by type | Check recovered value |
+ | Re-throwing | &#96;throw;&#96; | &#96;panic(r)&#96; |
+ | Custom types | Exception subclasses | Any type (usually error) |
+ | Cultural norm | Expected | Emergency only |
+ 
+ ## The Test Exception
+ 
+ One place where panic is universally accepted: tests.
+ 
+ &#96;&#96;&#96;go
+ func TestSomething(t *testing.T) {
+     result := process(input)
+     
+     if result != expected {
+         t.Fatalf("got %v, want %v", result, expected)  // this panics
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;t.Fatal&#96; and &#96;t.Fatalf&#96; panic to abort the test. This is fine—tests are the one place where "stop everything" is the right response to failure.
+ 
+ ## The Honest Take
+ 
+ **When I use panic:**
+ - &#96;Must&#96; functions for startup initialisation
+ - Genuinely impossible conditions (defensive programming)
+ - Test assertions via &#96;t.Fatal&#96;
+ 
+ **When I don't use panic:**
+ - File not found
+ - Network errors
+ - Invalid user input
+ - Anything that can reasonably happen at runtime
+ 
+ **The rule I follow:**
+ If I'm tempted to panic, I ask: "Is this a bug in my program, or is this something that could happen in production?" Bugs can panic. Production conditions should return errors.
+ 
+ ## What About Performance?
+ 
+ One argument for panic: "it's faster because you don't have to check errors at every level."
+ 
+ This is technically true but practically irrelevant. Error checking is a comparison and conditional jump. The performance difference is unmeasurable in real code.
+ 
+ Don't let performance justify panic. If you're that performance-sensitive, you're probably not writing Go anyway.
+ 
+ ---
+ 
+ *Coming up: Go's switch statement—more powerful than C#'s, with type switching, expression cases, and some surprises around fallthrough.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-switch.md</summary>

**Chunk 1**
Lines added: 432, lines removed: 1

```diff
@@ -1,1 +1,432 @@
- 
+ +++
+ title = "The switch Statement You Always Wanted"
+ date = "2024-12-30"
+ draft = false
+ tags = ["go", "dotnet", "control-flow", "csharp"]
+ +++
+ 
+ C#'s switch statement has evolved a lot over the years. Pattern matching, switch expressions, when guards—it's become genuinely powerful. But Go's switch has some tricks that'll make you wish C# worked this way.
+ 
+ Let's look at what Go's switch can do, including the bits that'll trip you up.
+ 
+ ## Basic Switch: No Fallthrough by Default
+ 
+ First surprise: Go switches don't fall through by default.
+ 
+ &#96;&#96;&#96;csharp
+ // C# - falls through if you forget break (historically)
+ switch (day)
+ {
+     case "Monday":
+         Console.WriteLine("Start of week");
+         break;  // required!
+     case "Friday":
+         Console.WriteLine("End of week");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ &#96;&#96;&#96;go
+ // Go - no break needed, no fallthrough
+ switch day {
+ case "Monday":
+     fmt.Println("Start of week")
+     // automatically breaks here
+ case "Friday":
+     fmt.Println("End of week")
+ }
+ &#96;&#96;&#96;
+ 
+ This is a genuine improvement. The C# pattern of requiring &#96;break&#96; after every case was a source of bugs for decades. Go's default—exit after each case—matches what you almost always want.
+ 
+ ## Multiple Values Per Case
+ 
+ Want the same code for multiple cases? In C#:
+ 
+ &#96;&#96;&#96;csharp
+ switch (day)
+ {
+     case "Saturday":
+     case "Sunday":
+         Console.WriteLine("Weekend");
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ In Go:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Cleaner. Multiple values in one case clause, comma-separated.
+ 
+ ## No Expression Required
+ 
+ Here's something C# can't do. Go's switch doesn't need an expression:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case hour &lt; 12:
+     fmt.Println("Good morning")
+ case hour &lt; 17:
+     fmt.Println("Good afternoon")
+ default:
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ This is equivalent to an if-else chain but often more readable:
+ 
+ &#96;&#96;&#96;go
+ // Equivalent, but more verbose
+ if hour &lt; 12 {
+     fmt.Println("Good morning")
+ } else if hour &lt; 17 {
+     fmt.Println("Good afternoon")
+ } else {
+     fmt.Println("Good evening")
+ }
+ &#96;&#96;&#96;
+ 
+ I use expressionless switch constantly. It's particularly good for range checks and complex conditions.
+ 
+ ## Fallthrough (When You Actually Want It)
+ 
+ Sometimes you genuinely need fallthrough. Go has a &#96;fallthrough&#96; keyword:
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ case "Thursday":
+     fmt.Println("Almost Friday")
+     fallthrough
+ case "Friday":
+     fmt.Println("Weekend soon!")
+ }
+ 
+ // Thursday prints both lines
+ // Friday prints just "Weekend soon!"
+ &#96;&#96;&#96;
+ 
+ Important: &#96;fallthrough&#96; must be the last statement in a case, and it falls into the next case unconditionally—it doesn't re-evaluate the case expression.
+ 
+ &#96;&#96;&#96;go
+ // This is usually wrong
+ switch x {
+ case 1:
+     fallthrough  // falls into case 2 even if x != 2
+ case 2:
+     doSomething()
+ }
+ &#96;&#96;&#96;
+ 
+ In practice, I rarely use &#96;fallthrough&#96;. Multiple values per case covers most needs.
+ 
+ ## Type Switches
+ 
+ This is where Go's switch shines. You can switch on type:
+ 
+ &#96;&#96;&#96;go
+ func describe(i interface{}) {
+     switch v := i.(type) {
+     case int:
+         fmt.Printf("Integer: %d\n", v)
+     case string:
+         fmt.Printf("String: %s\n", v)
+     case bool:
+         fmt.Printf("Boolean: %t\n", v)
+     case []int:
+         fmt.Printf("Slice of ints: %v\n", v)
+     default:
+         fmt.Printf("Unknown type: %T\n", v)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;v := i.(type)&#96; syntax extracts both the type (for the case matching) and the value (as the correctly typed &#96;v&#96;).
+ 
+ C# has pattern matching now which does something similar:
+ 
+ &#96;&#96;&#96;csharp
+ static void Describe(object o)
+ {
+     switch (o)
+     {
+         case int i:
+             Console.WriteLine($"Integer: {i}");
+             break;
+         case string s:
+             Console.WriteLine($"String: {s}");
+             break;
+         // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ Go got there first, and the syntax is arguable cleaner.
+ 
+ ### Multiple Types Per Case
+ 
+ &#96;&#96;&#96;go
+ switch v := i.(type) {
+ case int, int32, int64:
+     fmt.Println("Some kind of integer")
+     // Note: v is interface{} here, not a specific int type
+ case string, []byte:
+     fmt.Println("String-like")
+ default:
+     fmt.Printf("Type: %T\n", v)
+ }
+ &#96;&#96;&#96;
+ 
+ When you match multiple types, &#96;v&#96; has type &#96;interface{}&#96; because the compiler can't know which type matched.
+ 
+ ## Initialisation Statements
+ 
+ Like &#96;if&#96;, you can have an initialisation statement:
+ 
+ &#96;&#96;&#96;go
+ switch os := runtime.GOOS; os {
+ case "darwin":
+     fmt.Println("macOS")
+ case "linux":
+     fmt.Println("Linux")
+ default:
+     fmt.Printf("Other: %s\n", os)
+ }
+ // os is not visible here
+ &#96;&#96;&#96;
+ 
+ Keeps the variable scoped to where it's used.
+ 
+ ## Comparing to C#'s Switch Expressions
+ 
+ C# 8 added switch expressions, which are excellent:
+ 
+ &#96;&#96;&#96;csharp
+ var message = day switch
+ {
+     "Monday" =&gt; "Start of week",
+     "Friday" =&gt; "End of week",
+     "Saturday" or "Sunday" =&gt; "Weekend",
+     _ =&gt; "Midweek"
+ };
+ &#96;&#96;&#96;
+ 
+ Go doesn't have switch expressions—switch is always a statement, not an expression. You can't do:
+ 
+ &#96;&#96;&#96;go
+ // This doesn't work in Go
+ message := switch day {
+ case "Monday":
+     "Start of week"
+ // ...
+ }
+ &#96;&#96;&#96;
+ 
+ You have to use a variable:
+ 
+ &#96;&#96;&#96;go
+ var message string
+ switch day {
+ case "Monday":
+     message = "Start of week"
+ case "Friday":
+     message = "End of week"
+ case "Saturday", "Sunday":
+     message = "Weekend"
+ default:
+     message = "Midweek"
+ }
+ &#96;&#96;&#96;
+ 
+ This is one area where C# is genuinely more elegant.
+ 
+ ## When Guards (Sort Of)
+ 
+ C# has &#96;when&#96; guards in pattern matching:
+ 
+ &#96;&#96;&#96;csharp
+ switch (response)
+ {
+     case HttpResponse { StatusCode: var code } when code &gt;= 400:
+         HandleError(code);
+         break;
+ }
+ &#96;&#96;&#96;
+ 
+ Go doesn't have &#96;when&#96;, but expressionless switch achieves similar things:
+ 
+ &#96;&#96;&#96;go
+ switch {
+ case response.StatusCode &gt;= 500:
+     handleServerError(response)
+ case response.StatusCode &gt;= 400:
+     handleClientError(response)
+ case response.StatusCode &gt;= 200:
+     handleSuccess(response)
+ }
+ &#96;&#96;&#96;
+ 
+ Not quite as powerful as full pattern matching, but covers most cases.
+ 
+ ## The Default Case
+ 
+ Go's &#96;default&#96; case can appear anywhere (not just at the end):
+ 
+ &#96;&#96;&#96;go
+ switch day {
+ default:
+     fmt.Println("Weekday")
+ case "Saturday", "Sunday":
+     fmt.Println("Weekend")
+ }
+ &#96;&#96;&#96;
+ 
+ Convention says put it last, but Go doesn't enforce it.
+ 
+ ## Switching on Errors
+ 
+ A common pattern for error handling:
+ 
+ &#96;&#96;&#96;go
+ err := doSomething()
+ switch {
+ case err == nil:
+     // success
+ case errors.Is(err, ErrNotFound):
+     // handle not found
+ case errors.Is(err, ErrPermissionDenied):
+     // handle permission error
+ default:
+     // unknown error
+     return err
+ }
+ &#96;&#96;&#96;
+ 
+ Sometimes cleaner than a chain of if-else-if.
+ 
+ ## The Comparison
+ 
+ | Feature | C# | Go |
+ |---------|-----|-----|
+ | Break required | No (modern) | No |
+ | Fallthrough | By omitting break (legacy) | &#96;fallthrough&#96; keyword |
+ | Multiple values | &#96;case a, b:&#96; (older) or &#96;case a or b:&#96; | &#96;case a, b:&#96; |
+ | Expression switch | Yes (switch expression) | No (statement only) |
+ | Type switching | Pattern matching | &#96;switch v := x.(type)&#96; |
+ | No expression | No | Yes (&#96;switch { case cond: }&#96;) |
+ | When guards | Yes | No (use expressionless switch) |
+ | Init statement | No | Yes |
+ 
+ ## Practical Patterns
+ 
+ ### State Machine
+ 
+ &#96;&#96;&#96;go
+ type State int
+ 
+ const (
+     StateIdle State = iota
+     StateRunning
+     StatePaused
+     StateStopped
+ )
+ 
+ func (s *Machine) handleEvent(event Event) {
+     switch s.state {
+     case StateIdle:
+         switch event {
+         case EventStart:
+             s.state = StateRunning
+         default:
+             // ignore
+         }
+     case StateRunning:
+         switch event {
+         case EventPause:
+             s.state = StatePaused
+         case EventStop:
+             s.state = StateStopped
+         }
+     // etc.
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Command Dispatch
+ 
+ &#96;&#96;&#96;go
+ func handleCommand(cmd string, args []string) error {
+     switch cmd {
+     case "list":
+         return listItems()
+     case "add":
+         if len(args) &lt; 1 {
+             return errors.New("add requires an item name")
+         }
+         return addItem(args[0])
+     case "remove":
+         if len(args) &lt; 1 {
+             return errors.New("remove requires an item name")
+         }
+         return removeItem(args[0])
+     default:
+         return fmt.Errorf("unknown command: %s", cmd)
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ### Parsing JSON with Type Switch
+ 
+ &#96;&#96;&#96;go
+ func processValue(v interface{}) {
+     switch val := v.(type) {
+     case map[string]interface{}:
+         for k, v := range val {
+             fmt.Printf("Object key: %s\n", k)
+             processValue(v)  // recurse
+         }
+     case []interface{}:
+         for i, item := range val {
+             fmt.Printf("Array index: %d\n", i)
+             processValue(item)  // recurse
+         }
+     case string:
+         fmt.Printf("String: %s\n", val)
+     case float64:  // JSON numbers are float64
+         fmt.Printf("Number: %f\n", val)
+     case bool:
+         fmt.Printf("Boolean: %t\n", val)
+     case nil:
+         fmt.Println("Null")
+     }
+ }
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ Go's switch is one of the language's better features:
+ 
+ **Things I like:**
+ - No fallthrough by default (prevents bugs)
+ - Expressionless switch for complex conditions
+ - Type switches for working with interfaces
+ - Multiple values per case
+ - Init statements for scoping
+ 
+ **Things C# does better:**
+ - Switch expressions (returning values directly)
+ - Pattern matching with &#96;when&#96; guards
+ - Recursive patterns (&#96;case Person { Age: &gt; 18 }&#96;)
+ 
+ **The verdict:**
+ Go's switch is simpler and covers the common cases elegantly. C#'s switch has more features for complex matching. Use what each language gives you.
+ 
+ ---
+ 
+ *That wraps up Phase 3 on control flow and error handling. Next we'll move into concurrency—goroutines, channels, and why Go's approach to parallelism is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the Hugo build passes with all the new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls -la content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls content/posts/dotnet-to-go*.md
```

```
Build successful
      11
---
content/posts/dotnet-to-go-enums.md
content/posts/dotnet-to-go-errors.md
content/posts/dotnet-to-go-generics.md
content/posts/dotnet-to-go-modules.md
content/posts/dotnet-to-go-nil.md
content/posts/dotnet-to-go-panic.md
content/posts/dotnet-to-go-phrasebook.md
content/posts/dotnet-to-go-structs.md
content/posts/dotnet-to-go-switch.md
content/posts/dotnet-to-go-toolchain.md
content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 11 posts are now created and build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Phase 3 posts are done. Here's the complete series (11 posts now):

## C# to Go Series

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"** — `go` command, project structure, build model
2. **"Goodbye .csproj, Hello go.mod"** — Dependencies without NuGet
3. **"The Phrasebook: C# Concepts in Go Terms"** — Terminology swap, operators, quick reference

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"** — Value vs reference, embedding, interfaces
5. **"Where Did My Properties Go?"** — Capitalisation visibility, bare fields
6. **"Generics: Late to the Party"** — Go 1.18+ vs C#'s mature generics
7. **"The Million Dollar Mistake, Differently"** — Nil vs nullable reference types
8. **"No Enums? No Problem (Sort Of)"** — `iota`, const blocks, workarounds

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"** — Why no exceptions, error wrapping, sentinel errors, custom error types, strategies for living with explicit errors
10. **"Panic and Recover: The Emergency Exit"** — When panic is acceptable (`Must` pattern, init, programmer bugs), the boundary pattern, why you'll get judged for using it like exceptions
11. **"The switch Statement You Always Wanted"** — No fallthrough by default, expressionless switch, type switches, comparing to C#'s pattern matching

The Phase 3 posts cover:
- The philosophical shift from exceptions to explicit error values
- `errors.Is()` and `errors.As()` for error inspection
- The `%w` verb for error wrapping
- Panic/recover mechanics and when they're appropriate
- Go's switch being genuinely better in some ways (no break needed, type switches, expressionless form)
- Where C# is still ahead (switch expressions, pattern matching with when guards)

Ready for Phase 4 (concurrency?) whenever you are!

---

_**User (2025-12-29 10:33Z)**_

The next three posts are below, let's go write them! Add a little more snark to these ones, not over the top but be a little cynical because this section is where dotnet is reallllly good



Memory & Pointers

Pointers Without the Pain — What C# hides that Go makes explicit, and why it's less scary than C++
Stack vs Heap: Go's Escape Analysis — You know ref and Span<T>, now meet Go's approach to allocation
Slices Are Not Arrays (And Neither Is List<T>) — Capacity, length, backing arrays, and the gotchas that will bite you

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants three more posts for Phase 4: Memory & Pointers, and they want me to add a bit more snark/cynicism because this is an area where .NET is really strong. So I should be fair but acknowledge that .NET's memory management and abstractions are genuinely excellent, and Go's explicit approach has trade-offs.

Let me write these with a bit more edge - acknowledging that C#/.NET handles a lot of this better in many ways, but explaining what Go does and why.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-pointers.md</summary>

**Chunk 1**
Lines added: 258, lines removed: 1

```diff
@@ -1,1 +1,258 @@
- 
+ +++
+ title = "Pointers Without the Pain"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "pointers", "csharp"]
+ +++
+ 
+ Right, let's talk about pointers. If you've spent your career in C#, you've probably used pointers approximately never. Maybe you've seen &#96;unsafe&#96; blocks in performance-critical library code. Maybe you've used &#96;ref&#96; and &#96;Span&lt;T&gt;&#96; and felt rather clever about it.
+ 
+ In Go, pointers are everywhere. Every method receiver decision involves them. Every struct-passing decision involves them. You can't hide from them.
+ 
+ The good news: Go's pointers are considerably less terrifying than C's. The bad news: you actually have to think about them now.
+ 
+ ## What C# Hides
+ 
+ C# makes a neat distinction: value types live on the stack (mostly), reference types live on the heap (mostly), and the runtime figures out the details. You don't think about addresses. You don't think about dereferencing. You just use stuff.
+ 
+ &#96;&#96;&#96;csharp
+ var user = new User { Name = "Alice" };  // heap, reference semantics
+ var point = new Point(10, 20);           // stack (probably), value semantics
+ 
+ ProcessUser(user);   // passes reference
+ ProcessPoint(point); // passes copy
+ &#96;&#96;&#96;
+ 
+ The runtime decides where things actually live. The JIT optimises. Escape analysis happens. You don't care.
+ 
+ Go is more... honest? Explicit? Annoying? All three, depending on your mood.
+ 
+ &#96;&#96;&#96;go
+ user := User{Name: "Alice"}   // where does this live? Depends!
+ ptr := &amp;User{Name: "Bob"}     // definitely a pointer
+ 
+ ProcessUser(user)   // passes copy
+ ProcessUser(&amp;user)  // passes pointer
+ ProcessUserPtr(ptr) // passes pointer
+ &#96;&#96;&#96;
+ 
+ You have to think about it. Every time.
+ 
+ ## Go Pointer Basics
+ 
+ The syntax is C-style:
+ 
+ &#96;&#96;&#96;go
+ x := 42
+ p := &amp;x    // p is *int, pointing to x
+ fmt.Println(*p)  // 42 - dereference to get value
+ *p = 100   // x is now 100
+ &#96;&#96;&#96;
+ 
+ Creating pointers to composite literals:
+ 
+ &#96;&#96;&#96;go
+ // These are equivalent
+ user := &amp;User{Name: "Alice"}
+ 
+ // vs
+ user := new(User)
+ user.Name = "Alice"
+ 
+ // vs
+ var user User
+ user.Name = "Alice"
+ userPtr := &amp;user
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;&#96; operator gives you a pointer. The &#96;*&#96; operator dereferences. If you've touched C or C++ at any point, this is familiar.
+ 
+ ## The Nice Bit: Automatic Dereferencing
+ 
+ Unlike C, Go automatically dereferences pointers for field and method access:
+ 
+ &#96;&#96;&#96;go
+ type User struct {
+     Name string
+ }
+ 
+ func (u *User) SetName(name string) {
+     u.Name = name  // not (*u).Name, just u.Name
+ }
+ 
+ user := &amp;User{}
+ user.Name = "Alice"  // works, auto-dereferenced
+ user.SetName("Bob")  // works
+ &#96;&#96;&#96;
+ 
+ This is a genuine quality-of-life improvement over C. You don't need &#96;-&gt;&#96; vs &#96;.&#96; confusion. Dot notation works for both values and pointers.
+ 
+ ## The Not-Nice Bit: Nil Pointer Panics
+ 
+ C# has &#96;NullReferenceException&#96;. Go has nil pointer panics. Same problem, different name.
+ 
+ &#96;&#96;&#96;go
+ var user *User = nil
+ fmt.Println(user.Name)  // panic: runtime error: invalid memory address
+ &#96;&#96;&#96;
+ 
+ No nullable reference types. No compile-time null safety. Just runtime panics.
+ 
+ C# 8+ with nullable reference types:
+ 
+ &#96;&#96;&#96;csharp
+ #nullable enable
+ User? user = null;
+ Console.WriteLine(user.Name);  // compiler warning: possible null reference
+ &#96;&#96;&#96;
+ 
+ Go doesn't help you here. You check for nil manually, or you panic at runtime. Welcome to 2009.
+ 
+ ## When to Use Pointers
+ 
+ The decision tree:
+ 
+ **Use pointers when:**
+ 
+ 1. **The method modifies the receiver**
+    &#96;&#96;&#96;go
+    func (u *User) SetEmail(email string) {
+        u.Email = email  // needs to modify the original
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **The struct is large**
+    &#96;&#96;&#96;go
+    type BigStruct struct {
+        Data [1024]byte
+        // ... lots of fields
+    }
+    
+    func Process(b *BigStruct) {  // don't copy 1KB every call
+        // ...
+    }
+    &#96;&#96;&#96;
+ 
+ 3. **You need nil to mean "absent"**
+    &#96;&#96;&#96;go
+    type Config struct {
+        Timeout *time.Duration  // nil means "not set", use default
+    }
+    &#96;&#96;&#96;
+ 
+ 4. **Consistency with other methods on the type**
+    If some methods need pointer receivers, use pointers everywhere for that type. Mixing is legal but confusing.
+ 
+ **Use values when:**
+ 
+ 1. **The data is small and immutable**
+    &#96;&#96;&#96;go
+    type Point struct {
+        X, Y int
+    }
+    
+    func (p Point) Distance(other Point) float64 {
+        // fine to copy two ints
+    }
+    &#96;&#96;&#96;
+ 
+ 2. **You want copy-on-pass safety**
+    Value semantics mean the callee can't modify your data.
+ 
+ 3. **The zero value is useful**
+    &#96;&#96;&#96;go
+    var mu sync.Mutex  // zero Mutex is valid, unlocked
+    &#96;&#96;&#96;
+ 
+ ## The "Everything Is a Pointer Receiver" School
+ 
+ Some Go developers just use pointer receivers everywhere. It's simpler. Consistent. No thinking required.
+ 
+ &#96;&#96;&#96;go
+ func (u *User) Name() string { return u.name }      // pointer receiver
+ func (u *User) SetName(n string) { u.name = n }    // pointer receiver
+ func (u *User) IsActive() bool { return u.active } // pointer receiver
+ &#96;&#96;&#96;
+ 
+ Is this optimal? No. Does it matter? Rarely.
+ 
+ The performance difference between passing a pointer vs a small struct is negligible for most code. Consistency and clarity usually matter more.
+ 
+ ## What You Can't Do
+ 
+ Go's pointers are garbage-collected. You can't:
+ 
+ - Do pointer arithmetic (no &#96;p++&#96; to walk through memory)
+ - Free memory manually (the GC handles it)
+ - Have dangling pointers (the GC keeps referenced memory alive)
+ - Cast pointers to integers (without &#96;unsafe&#96;)
+ 
+ This is why Go pointers are "safe"—they're really just references with explicit syntax. All the scary C stuff is locked behind the &#96;unsafe&#96; package.
+ 
+ ## The &#96;unsafe&#96; Package
+ 
+ Go has an escape hatch:
+ 
+ &#96;&#96;&#96;go
+ import "unsafe"
+ 
+ func scary() {
+     var x int64 = 42
+     ptr := unsafe.Pointer(&amp;x)
+     // Now you can do terrible things
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;unsafe&#96; package lets you:
+ - Convert between pointer types
+ - Do pointer arithmetic
+ - Access struct padding
+ - Generally shoot yourself in the foot
+ 
+ If you're using &#96;unsafe&#96; outside of extremely low-level code, you're probably doing something wrong. It exists for syscalls, memory-mapped I/O, and interop—not for your web handlers.
+ 
+ ## Comparing to C# &#96;ref&#96; and Pointers
+ 
+ C# has several ways to get pointer-like semantics:
+ 
+ | C# | Go Equivalent | Notes |
+ |-----|---------------|-------|
+ | &#96;ref&#96; parameter | &#96;*T&#96; parameter | Pass by reference |
+ | &#96;in&#96; parameter | &#96;*T&#96; (readonly discipline) | Go has no &#96;const&#96; pointers |
+ | &#96;out&#96; parameter | &#96;*T&#96; or multiple returns | Go prefers multiple returns |
+ | &#96;Span&lt;T&gt;&#96; | Slices | Different semantics, similar purpose |
+ | &#96;unsafe&#96; pointers | &#96;unsafe.Pointer&#96; | Both are escape hatches |
+ | &#96;ref struct&#96; | No equivalent | Go doesn't have stack-only types |
+ 
+ C#'s &#96;ref struct&#96; and &#96;Span&lt;T&gt;&#96; are genuinely more sophisticated than anything Go offers. If you're doing zero-allocation parsing or high-performance buffer manipulation, .NET's tooling is better.
+ 
+ Go's answer is "use slices and let the GC handle it." Less control, simpler mental model, occasionally more allocation.
+ 
+ ## The Honest Take
+ 
+ Look, I'll be straight with you: C#'s memory model is more sophisticated. The runtime does more for you. Nullable reference types catch null bugs at compile time. &#96;Span&lt;T&gt;&#96; gives you safe, zero-copy views into memory. &#96;ref struct&#96; prevents heap allocation entirely.
+ 
+ Go gives you... pointers. The same pointers we've had since the 1970s, except garbage-collected so you can't corrupt memory.
+ 
+ **What Go does better:**
+ - Simpler mental model (it's just pointers)
+ - Explicit about copies vs references
+ - No hidden boxing/unboxing
+ - Can't accidentally capture stack memory (escape analysis handles it)
+ 
+ **What C# does better:**
+ - Nullable reference types
+ - &#96;Span&lt;T&gt;&#96; and memory-safe slicing
+ - &#96;ref struct&#96; for stack-only types  
+ - More escape hatches that are actually usable (&#96;stackalloc&#96;, etc.)
+ - The whole &#96;System.Memory&#96; namespace
+ 
+ **The verdict:**
+ If you're writing performance-critical code where every allocation matters, C# has more tools. If you're writing normal application code, Go's "just use pointers" simplicity is fine.
+ 
+ You'll write &#96;*User&#96; a lot. You'll occasionally forget to check for nil. You'll survive.
+ 
+ ---
+ 
+ *Next up: stack vs heap allocation and escape analysis—Go decides where your variables live, and you don't always get a vote.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-escape-analysis.md</summary>

**Chunk 1**
Lines added: 306, lines removed: 1

```diff
@@ -1,1 +1,306 @@
- 
+ +++
+ title = "Stack vs Heap: Go's Escape Analysis"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "performance", "csharp"]
+ +++
+ 
+ In C#, you mostly don't think about where variables live. Value types go on the stack (usually). Reference types go on the heap (always). The runtime and JIT make optimisations. You trust the process.
+ 
+ In Go, you still mostly don't think about it—but for different reasons. Go decides where things live at compile time through something called escape analysis. And sometimes it makes choices that'll surprise you.
+ 
+ ## The C# Mental Model
+ 
+ C#'s rules are pretty clear:
+ 
+ &#96;&#96;&#96;csharp
+ void Example()
+ {
+     int x = 42;           // stack - value type, local variable
+     Point p = new(1, 2);  // stack - value type (assuming Point is a struct)
+     
+     var user = new User(); // heap - reference type, always
+     var boxed = (object)x; // heap - boxing allocates
+ }
+ &#96;&#96;&#96;
+ 
+ Value types on stack (unless boxed, captured in closures, or part of a heap object). Reference types on heap. Simple.
+ 
+ .NET has more tricks now—&#96;stackalloc&#96;, &#96;Span&lt;T&gt;&#96;, &#96;ref struct&#96;—but the basic model is straightforward.
+ 
+ ## Go's Escape Analysis
+ 
+ Go doesn't have value types vs reference types in the C# sense. Structs can live on the stack or heap. The compiler decides based on whether the value "escapes" the function.
+ 
+ &#96;&#96;&#96;go
+ func stackAllocation() {
+     x := 42           // stack (probably)
+     user := User{}    // stack (probably)
+     process(&amp;user)    // might change things...
+ }
+ 
+ func heapAllocation() *User {
+     user := User{}    // heap - returned pointer escapes
+     return &amp;user
+ }
+ &#96;&#96;&#96;
+ 
+ The key insight: **if a pointer to something outlives the function, it must be on the heap**. Go figures this out at compile time.
+ 
+ ## Seeing Escape Analysis
+ 
+ You can ask the compiler what it's doing:
+ 
+ &#96;&#96;&#96;bash
+ go build -gcflags="-m" ./...
+ &#96;&#96;&#96;
+ 
+ Output looks like:
+ 
+ &#96;&#96;&#96;
+ ./main.go:10:2: moved to heap: user
+ ./main.go:15:9: &amp;Config{...} escapes to heap
+ ./main.go:20:2: result does not escape
+ &#96;&#96;&#96;
+ 
+ This is genuinely useful for performance work. You can see exactly what's allocating.
+ 
+ ## What Makes Things Escape
+ 
+ ### Returning Pointers
+ 
+ &#96;&#96;&#96;go
+ func newUser() *User {
+     u := User{Name: "Alice"}  // escapes - returned pointer
+     return &amp;u
+ }
+ &#96;&#96;&#96;
+ 
+ The &#96;&amp;u&#96; pointer is returned, so &#96;u&#96; must outlive the function. Heap.
+ 
+ ### Storing in Interface Values
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     var w io.Writer = &amp;bytes.Buffer{}  // escapes - interface storage
+ }
+ &#96;&#96;&#96;
+ 
+ Interface values often cause heap allocation because the compiler can't always prove the lifetime.
+ 
+ ### Closures Capturing Variables
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42
+     f := func() {
+         fmt.Println(x)  // x escapes - captured by closure
+     }
+     go f()
+ }
+ &#96;&#96;&#96;
+ 
+ Closures that outlive the function (like goroutines) force captures to the heap.
+ 
+ ### Too Large for Stack
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     data := make([]byte, 10*1024*1024)  // 10MB - escapes due to size
+ }
+ &#96;&#96;&#96;
+ 
+ Very large allocations go to the heap regardless of escape.
+ 
+ ### Pointer Stored in Slice or Map
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     users := make([]*User, 0)
+     u := User{Name: "Alice"}
+     users = append(users, &amp;u)  // u escapes - pointer stored in slice
+ }
+ &#96;&#96;&#96;
+ 
+ ## What Stays on the Stack
+ 
+ ### Local Variables Not Referenced
+ 
+ &#96;&#96;&#96;go
+ func example() {
+     x := 42          // stack
+     y := x + 1       // stack
+     fmt.Println(y)   // y's value copied to Println, y stays on stack
+ }
+ &#96;&#96;&#96;
+ 
+ ### Pointers That Don't Escape
+ 
+ &#96;&#96;&#96;go
+ func process(u *User) {
+     u.Name = "modified"  // u doesn't escape, caller's stack
+ }
+ 
+ func example() {
+     user := User{}
+     process(&amp;user)  // user can stay on stack - &amp;user doesn't escape process
+ }
+ &#96;&#96;&#96;
+ 
+ The compiler traces through calls to see if pointers ultimately escape.
+ 
+ ## Comparing to .NET
+ 
+ Here's where I get cynical: .NET's approach is more sophisticated and gives you more control.
+ 
+ ### &#96;stackalloc&#96;
+ 
+ &#96;&#96;&#96;csharp
+ Span&lt;byte&gt; buffer = stackalloc byte[1024];
+ // Guaranteed stack allocation, zero heap involvement
+ &#96;&#96;&#96;
+ 
+ Go can't do this. You can't force stack allocation. The compiler decides.
+ 
+ ### &#96;ref struct&#96;
+ 
+ &#96;&#96;&#96;csharp
+ ref struct Parser 
+ {
+     private Span&lt;char&gt; _buffer;
+     // Can ONLY live on stack, compiler enforced
+ }
+ &#96;&#96;&#96;
+ 
+ Go has no equivalent. You can't declare "this type must never be heap-allocated."
+ 
+ ### &#96;Span&lt;T&gt;&#96; Without Allocation
+ 
+ &#96;&#96;&#96;csharp
+ void Process(ReadOnlySpan&lt;char&gt; text)
+ {
+     var slice = text[10..20];  // no allocation, just pointer arithmetic
+ }
+ &#96;&#96;&#96;
+ 
+ Go slices are similar but the escape analysis is less predictable.
+ 
+ ### What .NET Gets Right
+ 
+ The JIT can do escape analysis too, and it can make different decisions at runtime based on actual usage patterns. Go's compile-time analysis is conservative—it heap-allocates when unsure.
+ 
+ &#96;&#96;&#96;csharp
+ // .NET JIT might stack-allocate this if it proves the object doesn't escape
+ var temp = new StringBuilder();
+ temp.Append("hello");
+ return temp.ToString();
+ // StringBuilder might be optimised away entirely
+ &#96;&#96;&#96;
+ 
+ Go's compiler is good, but it doesn't have runtime profile-guided optimisation.
+ 
+ ## The Practical Impact
+ 
+ Does this matter? Sometimes.
+ 
+ For most code—web handlers, CLI tools, data processing—the GC is fast enough that escape analysis is academic. Things allocate, they get collected, life goes on.
+ 
+ For hot paths processing millions of events per second, allocation pressure matters. And here's the uncomfortable truth: **Go gives you less control than C#**.
+ 
+ You can't say "put this on the stack." You can't create stack-only types. You can write code that the compiler *will* stack-allocate, but you're working with the compiler, not commanding it.
+ 
+ ### Tricks That Help
+ 
+ **Sync.Pool for reusable objects:**
+ 
+ &#96;&#96;&#96;go
+ var bufferPool = sync.Pool{
+     New: func() interface{} {
+         return make([]byte, 4096)
+     },
+ }
+ 
+ func process() {
+     buf := bufferPool.Get().([]byte)
+     defer bufferPool.Put(buf)
+     // use buf...
+ }
+ &#96;&#96;&#96;
+ 
+ This doesn't avoid allocation—it reuses allocations. Different problem, similar goal.
+ 
+ **Passing values instead of pointers for small structs:**
+ 
+ &#96;&#96;&#96;go
+ // This might heap-allocate due to interface
+ func process(r io.Reader) { ... }
+ 
+ // This won't heap-allocate
+ func processBytes(data []byte) { ... }
+ &#96;&#96;&#96;
+ 
+ Sometimes avoiding interfaces avoids allocation. But you lose flexibility.
+ 
+ **Preallocating slices:**
+ 
+ &#96;&#96;&#96;go
+ // Might grow and reallocate multiple times
+ results := make([]Result, 0)
+ 
+ // Single allocation if you know the size
+ results := make([]Result, 0, expectedSize)
+ &#96;&#96;&#96;
+ 
+ ## The Honest Take
+ 
+ I'll be blunt: if you're coming from .NET and you care deeply about allocation control, Go will frustrate you.
+ 
+ .NET gives you:
+ - &#96;stackalloc&#96; for explicit stack allocation
+ - &#96;ref struct&#96; for stack-only types
+ - &#96;Span&lt;T&gt;&#96; for zero-allocation slicing
+ - &#96;ArrayPool&lt;T&gt;&#96; for buffer reuse with a clean API
+ - Object pooling with sophisticated lifetime management
+ - JIT optimisations that can eliminate allocations entirely
+ 
+ Go gives you:
+ - Escape analysis that usually does the right thing
+ - &#96;sync.Pool&#96; for object reuse (but with interface{} boxing before 1.18)
+ - The ability to check what escapes with compiler flags
+ - A fast garbage collector that makes most of this not matter
+ 
+ **When Go's approach works:**
+ - You're building services with reasonable latency requirements
+ - You're not processing millions of messages per second per core
+ - You value simplicity over maximum control
+ - You're okay trading some performance for less complexity
+ 
+ **When you'll miss .NET:**
+ - Sub-millisecond latency requirements
+ - Zero-GC paths are necessary
+ - You need guaranteed stack allocation
+ - High-frequency trading, game engines, real-time systems
+ 
+ For 90% of software, Go's escape analysis is fine. The GC is good. You won't notice. For the other 10%, .NET genuinely has better tools.
+ 
+ ## Checking Your Allocations
+ 
+ Profile before optimising:
+ 
+ &#96;&#96;&#96;bash
+ # Run benchmarks with allocation stats
+ go test -bench=. -benchmem
+ 
+ # Trace allocations
+ go tool pprof -alloc_space profile.out
+ 
+ # See escape decisions
+ go build -gcflags="-m -m" ./...  # extra -m for more detail
+ &#96;&#96;&#96;
+ 
+ Know what's actually allocating before you fight the compiler.
+ 
+ ---
+ 
+ *Next up: slices in depth—they're not arrays, they're not List&lt;T&gt;, and the gotchas around capacity, length, and shared backing arrays will bite you eventually.*
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: /Users/andycross/src/personal/mcp-blogs/content/posts/dotnet-to-go-slices.md</summary>

**Chunk 1**
Lines added: 301, lines removed: 1

```diff
@@ -1,1 +1,301 @@
- 
+ +++
+ title = "Slices Are Not Arrays (And Neither Is List&lt;T&gt;)"
+ date = "2024-12-31"
+ draft = false
+ tags = ["go", "dotnet", "memory", "slices", "csharp"]
+ +++
+ 
+ Every C# developer coming to Go makes the same mistake: they see &#96;[]int&#96; and think "array" or "list." It's neither. It's a slice, and it has semantics that will bite you if you don't understand them.
+ 
+ This is one of those Go concepts that seems simple until it isn't. Let's dig in.
+ 
+ ## What a Slice Actually Is
+ 
+ A slice is a struct with three fields:
+ 
+ &#96;&#96;&#96;go
+ // Conceptually:
+ type slice struct {
+     array *T   // pointer to underlying array
+     len   int  // number of elements in use
+     cap   int  // total capacity of underlying array
+ }
+ &#96;&#96;&#96;
+ 
+ When you create a slice, you're creating this header. The actual data lives in a backing array somewhere.
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3, 4, 5}
+ // s.array -&gt; [1, 2, 3, 4, 5, _, _, _]  (backing array, might have extra capacity)
+ // s.len = 5
+ // s.cap = 5 (or more)
+ &#96;&#96;&#96;
+ 
+ This is fundamentally different from both C# arrays and &#96;List&lt;T&gt;&#96;.
+ 
+ ## The C# Mental Model (And Why It's Wrong Here)
+ 
+ **C# arrays** are fixed-size, directly hold their data:
+ 
+ &#96;&#96;&#96;csharp
+ int[] arr = new int[5];
+ // arr IS the array, fixed size, done
+ &#96;&#96;&#96;
+ 
+ **C# List&lt;T&gt;** wraps an array with growth semantics:
+ 
+ &#96;&#96;&#96;csharp
+ var list = new List&lt;int&gt; { 1, 2, 3 };
+ list.Add(4);  // might reallocate internally
+ // But list is a reference type - you always work with the same list object
+ &#96;&#96;&#96;
+ 
+ **Go slices** are value types that point to arrays:
+ 
+ &#96;&#96;&#96;go
+ s := []int{1, 2, 3}
+ s = append(s, 4)  // might return a NEW slice header pointing to NEW array
+ &#96;&#96;&#96;
+ 
+ That last line is where people get burned. &#96;append&#96; might modify the backing array in place, or it might allocate a new array and return a slice pointing to it. **You must use the return value.**
+ 
+ ## The append Trap
+ 
+ This looks fine:
+ 
+ &#96;&#96;&#96;go
+ func addItem(items []int, item int) {
+     items = append(items, item)
+ }
+ 
+ func main() {
+     s := []int{1, 2, 3}
+     addItem(s, 4)
+     fmt.Println(s)  // [1 2 3] - item wasn't added!
+ }
+ &#96;&#96;&#96;
+ 
+ The slice header is passed by value. &#96;append&#96; creates a new header (possibly pointing to a new array), but that new header only exists inside &#96;addItem&#96;. The caller's &#96;s&#96; is unchanged.
+ 
+ Fixes:
+ 
+ &#96;&#96;&#96;go
+ // Option 1: Return the new slice
+ func addItem(items []int, item int) []int {
+     return append(items, item)
+ }
+ 
+ s = addItem(s, 4)  // use the return value
+ 
+ // Option 2: Use a pointer to slice (less common)
+ func addItem(items *[]int, item int) {
+     *items = append(*items, item)
+ }
+ 
+ addItem(&amp;s, 4)
+ &#96;&#96;&#96;
+ 
+ In C#, this wouldn't be a problem—&#96;List&lt;T&gt;&#96; is a reference type:
+ 
+ &#96;&#96;&#96;csharp
+ void AddItem(List&lt;int&gt; items, int item) {
+     items.Add(item);  // modifies the actual list
+ }
+ &#96;&#96;&#96;
+ 
+ Go's slice is not a reference type. It's a value type that contains a pointer. Subtle but critical difference.
+ 
+ ## Shared Backing Arrays (The Real Gotcha)
+ 
+ Here's where it gets properly dangerous:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice1 := original[1:3]  // [2, 3]
+ slice2 := original[2:4]  // [3, 4]
+ 
+ slice1[1] = 999  // modify slice1
+ 
+ fmt.Println(original)  // [1 2 999 4 5]
+ fmt.Println(slice1)    // [2 999]
+ fmt.Println(slice2)    // [999 4]
+ &#96;&#96;&#96;
+ 
+ All three slices share the same backing array. Modify one, you modify them all.
+ 
+ This is nothing like C#:
+ 
+ &#96;&#96;&#96;csharp
+ var original = new int[] { 1, 2, 3, 4, 5 };
+ var slice = original[1..3];  // creates a NEW array in C# 8+
+ slice[1] = 999;
+ Console.WriteLine(string.Join(", ", original));  // 1, 2, 3, 4, 5 - unchanged
+ &#96;&#96;&#96;
+ 
+ C# ranges create copies. Go slices share memory. Neither is wrong, but they're completely different behaviours.
+ 
+ ### The Capacity Gotcha
+ 
+ It gets worse. When you slice, you might have hidden capacity:
+ 
+ &#96;&#96;&#96;go
+ original := []int{1, 2, 3, 4, 5}
+ slice := original[1:3]  // [2, 3], but capacity is 4!
+ 
+ fmt.Println(len(slice))  // 2
+ fmt.Println(cap(slice))  // 4 - can see elements 1-4 of original
+ 
+ slice = append(slice, 999)  // doesn't allocate new array - overwrites original!
+ 
+ fmt.Println(original)  // [1 2 3 999 5] - element 3 (index 3) was overwritten
+ &#96;&#96;&#96;
+ 
+ The &#96;append&#96; saw capacity, used it, and stomped on data that logically wasn't part of &#96;slice&#96; but physically was in the backing array.
+ 
+ To prevent this:
+ 
+ &#96;&#96;&#96;go
+ // Limit capacity when slicing
+ slice := original[1:3:3]  // [low:high:max] - capacity is high-low = 2
+ 
+ // Or copy explicitly
+ slice := make([]int, 2)
+ copy(slice, original[1:3])
+ &#96;&#96;&#96;
+ 
+ ## Length vs Capacity
+ 
+ This distinction doesn't exist in &#96;List&lt;T&gt;&#96; (internally it does, but you don't see it):
+ 
+ &#96;&#96;&#96;go
+ s := make([]int, 3, 10)  // length 3, capacity 10
+ fmt.Println(len(s))  // 3
+ fmt.Println(cap(s))  // 10
+ 
+ s[0] = 1  // OK
+ s[5] = 1  // panic: index out of range - len is 3!
+ 
+ s = s[:cap(s)]  // extend slice to full capacity
+ s[5] = 1        // now OK
+ &#96;&#96;&#96;
+ 
+ Length is how many elements are accessible. Capacity is how many could be before reallocation. This is an implementation detail that Go exposes and expects you to understand.
+ 
+ ## nil vs Empty Slice
+ 
+ Oh good, more nil pain:
+ 
+ &#96;&#96;&#96;go
+ var s1 []int          // nil slice
+ s2 := []int{}         // empty slice
+ s3 := make([]int, 0)  // empty slice
+ 
+ fmt.Println(s1 == nil)  // true
+ fmt.Println(s2 == nil)  // false
+ fmt.Println(s3 == nil)  // false
+ 
+ // But they all behave the same for most operations
+ fmt.Println(len(s1), len(s2), len(s3))  // 0 0 0
+ &#96;&#96;&#96;
+ 
+ A nil slice and an empty slice are functionally equivalent for &#96;len&#96;, &#96;cap&#96;, &#96;append&#96;, and &#96;range&#96;. But they're not equal to each other, and some JSON encoders treat them differently.
+ 
+ &#96;&#96;&#96;go
+ json.Marshal(s1)  // might produce "null"
+ json.Marshal(s2)  // produces "[]"
+ &#96;&#96;&#96;
+ 
+ Wonderful.
+ 
+ ## Patterns That Help
+ 
+ ### Always Capture append's Return
+ 
+ &#96;&#96;&#96;go
+ s = append(s, item)  // always assign back
+ &#96;&#96;&#96;
+ 
+ ### Copy When Returning Subslices
+ 
+ &#96;&#96;&#96;go
+ func getSubset(data []int) []int {
+     subset := data[10:20]
+     
+     // Bad: caller might have data, mutating subset affects data
+     return subset
+     
+     // Good: caller gets independent slice
+     result := make([]int, len(subset))
+     copy(result, subset)
+     return result
+ }
+ &#96;&#96;&#96;
+ 
+ ### Preallocate When Size Is Known
+ 
+ &#96;&#96;&#96;go
+ // Might reallocate multiple times
+ results := []int{}
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Single allocation
+ results := make([]int, 0, len(items))
+ for _, item := range items {
+     results = append(results, transform(item))
+ }
+ 
+ // Or even better, known length
+ results := make([]int, len(items))
+ for i, item := range items {
+     results[i] = transform(item)
+ }
+ &#96;&#96;&#96;
+ 
+ ### Use the Three-Index Slice for Safety
+ 
+ &#96;&#96;&#96;go
+ // Dangerous: slice might have hidden capacity
+ sub := data[a:b]
+ 
+ // Safe: capacity is limited
+ sub := data[a:b:b]
+ &#96;&#96;&#96;
+ 
+ ## The Comparison
+ 
+ | Aspect | C# Array | C# List&lt;T&gt; | Go Slice |
+ |--------|----------|------------|----------|
+ | Fixed size | Yes | No | No |
+ | Reference type | Yes | Yes | No (value type with pointer) |
+ | Slicing copies | Yes (ranges) | N/A | No (shares memory) |
+ | append semantics | N/A | Add modifies list | Returns new header |
+ | Hidden capacity | No | Yes (internal) | Yes (exposed) |
+ | nil vs empty | null vs new int[0] | null vs new List | Different behaviours |
+ 
+ ## The Honest Take
+ 
+ Slices are Go's most footgun-laden feature. They look simple, they have subtle semantics, and the gotchas aren't obvious until you've been bitten.
+ 
+ **What Go gets right:**
+ - Efficient memory sharing when you want it
+ - Clear distinction between length and capacity
+ - &#96;append&#96; is convenient (when used correctly)
+ - No boxing, good cache locality
+ 
+ **What C# does better:**
+ - &#96;List&lt;T&gt;&#96; is a reference type—modifications are visible everywhere
+ - Range slicing copies by default—no surprise aliasing
+ - &#96;Span&lt;T&gt;&#96; gives you explicit no-copy semantics when you want them
+ - You don't have to remember the three-index slice syntax
+ 
+ **The verdict:**
+ Slices are powerful and efficient. They're also a sharp tool that will cut you. Every Go developer has been bitten by shared backing arrays or forgotten &#96;append&#96; returns.
+ 
+ My advice: be paranoid about slice aliasing. Copy when returning subslices. Always use the return value of &#96;append&#96;. And when something mutates unexpectedly, check your slices first.
+ 
+ ---
+ 
+ *That wraps up the memory section. Next we'll move into concurrency—goroutines, channels, and why Go's approach is fundamentally different from async/await.*
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me verify the build works with all these new posts.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md</summary>

```bash
cd /Users/andycross/src/personal/mcp-blogs && hugo --quiet && echo "Build successful" && ls content/posts/dotnet-to-go*.md | wc -l && echo "---" && ls -la content/posts/dotnet-to-go*.md
```

```
Build successful
      14
---
-rw-r--r--  1 andycross  staff  10095 Dec 28 20:26 content/posts/dotnet-to-go-enums.md
-rw-r--r--  1 andycross  staff   9266 Dec 29 07:53 content/posts/dotnet-to-go-errors.md
-rw-r--r--  1 andycross  staff   8268 Dec 29 15:26 content/posts/dotnet-to-go-escape-analysis.md
-rw-r--r--  1 andycross  staff   8876 Dec 28 20:26 content/posts/dotnet-to-go-generics.md
-rw-r--r--  1 andycross  staff   9547 Dec 28 20:20 content/posts/dotnet-to-go-modules.md
-rw-r--r--  1 andycross  staff   8501 Dec 28 20:26 content/posts/dotnet-to-go-nil.md
-rw-r--r--  1 andycross  staff   8319 Dec 29 07:53 content/posts/dotnet-to-go-panic.md
-rw-r--r--  1 andycross  staff  10755 Dec 29 07:48 content/posts/dotnet-to-go-phrasebook.md
-rw-r--r--  1 andycross  staff   8107 Dec 29 15:25 content/posts/dotnet-to-go-pointers.md
-rw-r--r--  1 andycross  staff   8294 Dec 29 15:27 content/posts/dotnet-to-go-slices.md
-rw-r--r--  1 andycross  staff   8748 Dec 29 07:49 content/posts/dotnet-to-go-structs.md
-rw-r--r--  1 andycross  staff   9594 Dec 29 07:53 content/posts/dotnet-to-go-switch.md
-rw-r--r--  1 andycross  staff   8132 Dec 28 20:20 content/posts/dotnet-to-go-toolchain.md
-rw-r--r--  1 andycross  staff   9253 Dec 28 20:26 content/posts/dotnet-to-go-visibility.md

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
All 14 posts build successfully. Let me summarize the updated series structure for the user.</details></think>

---

All three Memory & Pointers posts are done. 14 posts total now, with appropriate snark about .NET's superiority in this area. Here's the updated series:

## C# to Go Series (14 posts)

### Phase 1: Getting Oriented
1. **"You Know .NET, Now Meet the Go Toolchain"**
2. **"Goodbye .csproj, Hello go.mod"**
3. **"The Phrasebook: C# Concepts in Go Terms"**

### Phase 2: Types & Data
4. **"Your Class Is Now a Struct (And That's Fine)"**
5. **"Where Did My Properties Go?"**
6. **"Generics: Late to the Party"**
7. **"The Million Dollar Mistake, Differently"**
8. **"No Enums? No Problem (Sort Of)"**

### Phase 3: Control Flow & Error Handling
9. **"if err != nil: Your New Reality"**
10. **"Panic and Recover: The Emergency Exit"**
11. **"The switch Statement You Always Wanted"**

### Phase 4: Memory & Pointers ← **NEW**
12. **"Pointers Without the Pain"** — What C# hides, automatic dereferencing, nil panics, when to use pointers, acknowledging that nullable reference types are better
13. **"Stack vs Heap: Go's Escape Analysis"** — Compile-time decisions, what escapes, the `-gcflags="-m"` trick, lamenting the lack of `stackalloc`, `ref struct`, and `Span<T>`
14. **"Slices Are Not Arrays (And Neither Is List<T>)"** — The append trap, shared backing arrays, the three-index slice, capacity gotchas, why this is Go's most footgun-laden feature

Key themes in the memory posts:
- Honest acknowledgment that .NET has better tools (`Span<T>`, `ref struct`, nullable references, `stackalloc`)
- Go gives you less control but a simpler mental model
- The slice semantics will absolutely bite you
- Escape analysis is good but you can't force stack allocation

Ready for Phase 5 (concurrency) whenever you want to tackle goroutines vs async/await!

---

